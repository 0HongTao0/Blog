title: 操作系统
date: 2018-12-23 14:00
tags:

------
### 磁盘存储器的管理
  - **磁盘文件的链接组织方式**
    1. 连续组织：连续分配方法要求每个文件在磁盘上占有一组连续的块。这样所形成的文件结构称为顺序文件结构，此时的物理文件称为顺序文件。
    ![连续分配](https://upload-images.jianshu.io/upload_images/5853159-daa9e2f8a9e6c3aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480/format/webp)
    2. 隐式链接：文件目录的每个目录项中都必须含有指向链接文件的第一个盘块和最后一个盘块的指针。
    ![隐式链接](https://upload-images.jianshu.io/upload_images/5853159-c466c43bbd0b1733.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480/format/webp)
    3. 显式链接：用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。该表在整个磁盘仅设置一张。
    ![显式链接](https://upload-images.jianshu.io/upload_images/5853159-82857d166a7ee990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/348/format/webp)
    4. 单级索引组织方式：每个文件对应的盘块集中在一起，在访问某个文件时候，将该文件所对应的盘块号一起调入内存。
    ![单级索引组织方式](https://upload-images.jianshu.io/upload_images/5853159-bb611eb9b8345da8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/514/format/webp)
    5. 多级索引组织方式
    ![多级索引组织方式](https://upload-images.jianshu.io/upload_images/5853159-17e61aeece5fd1a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/584/format/webp)
    6. 混合索引方式
    ![混合索引方式](https://upload-images.jianshu.io/upload_images/5853159-9616543178004e72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/562/format/webp)
  - **文件存储空间的管理**
    在磁盘上除了需要文件分配表，还需要设置一张 **磁盘分配表**，用于记录可供分配的存储空间。
    - 存储空间的管理方法
      1. 空闲表法（效率低）
      ![空闲盘块表](https://upload-images.jianshu.io/upload_images/5853159-0e4943cc3dafc6ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/326/format/webp)
      2. 空闲链表法（效率低）
      3. **位示图法**
      ![位示图](https://pic2.zhimg.com/80/v2-3c615e6e6f5c2109c6cf27fecd0d816d_hd.jpg)
      盘块的分配：顺序扫描位示图，寻找一个或一组值为 "0"(空闲)位；将找到的一个或一组二进制位转换成相应的盘块号（b = n(i -1) + j ）；修改位示图 map[i, j] = 1。
      盘块的回收：将回收盘块的盘块号转换成位示图中的行号和列号（i= (b -1)DIV n + 1 ， j = (b -1)MOD n + 1 ）；修改位示图。令map[i,j]=0；
      4. 组成链接法

---
### 磁盘存储的性能和调度
  - 改善磁盘系统性能的方法
    1. 选择好的磁盘调度算法，减少磁盘的寻道时间。
    2. 提高磁盘的 I/O 速度，提高对文件的访问速度。
    3. 采取冗余技术，提高磁盘系统的可靠性。
  - 磁盘的结构和布局
  ![磁盘的结构和布局](https://segmentfault.com/img/bV9Xny?w=1023&h=587)
  - **磁盘调度算法**（通过例子学习）
    1. 先来先服务（FCFS）
    ![FCFS 调度算法](https://img-blog.csdnimg.cn/20181031222442555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTAyNDM3,size_16,color_FFFFFF,t_70)
    2. 最短寻道时间优先（SSTF）
    ![SSTF 调度算法](https://img-blog.csdnimg.cn/20181031222758867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTAyNDM3,size_16,color_FFFFFF,t_70)
    3. 扫描算法（SCAN）：先往一个方向扫，当该方向没有需要磁道调度则往回扫。
      ![SCAN 调度算法](https://img-blog.csdnimg.cn/20181031223619951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTAyNDM3,size_16,color_FFFFFF,t_70)
    4. 循环扫描算法（CSCAN）：先往一个方向扫，当该方向没有需要磁道调度则 **跳到另一方向的第一个磁道开始扫描**。
    ![CSCAN 调度算法](https://img-blog.csdnimg.cn/20181031223942351.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTAyNDM3,size_16,color_FFFFFF,t_70)

---
### 虚拟存储器
  - 虚拟存储器：具有请求调入和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本又接近于外存。虚拟存储器的实现建立在 **离散分配存储器管理方式** 的基础上。
  - 虚拟存储器的特征：多次性；对换性；虚拟性；
  - 请求分页存储管理方式 = 分页系统 + 请求调页 + 页面置换
    ![请求分页中的地址变换过程](https://upload-images.jianshu.io/upload_images/5853159-2af551229ffecc6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/662/format/webp)
  -  内存分配策略
    1. 固定分配局部置换：当进程在运行中发现却页，只能从分配给该进程的 n 个页面中选 1 页换出，然后调入 1 页。（进程总页数不变）
    2. 可变分配全局置换：当进程发现缺页时，由系统从空闲物理块 队列中取出一个物理块分配给该进程，并将欲调入的(缺)页装入其中。仅当空闲物理块用完了才从内存中选择一页调出。
    3. 可变分配局部置换：如果进程在运行中频繁地发生缺页中断，则系统须再为该进程分配若干附加的物理块，直至该进程的缺页 率减少到适当程度为止；反之，若一个进程在运行过程中的缺页率特别低，则此时可适当减少分配给该进程的物理块数但不应引起其缺页率的明显增 则此时可适当减少分配给该进程的物理块数，但不应引起其缺页率的明显增加。
  - **页面置换算法**
    1. 最佳置换算法（一个理想状态算法，无法实现）：其所选择的被淘汰页面，将是以后永不使用的，或许是在长(未来)时间内不再被访问被淘汰页面，将是以后永不使用的，或许是在长(未来)时间内不再被访问的页面。
    ![利用最佳页面置换算法时的置换图](https://img-blog.csdn.net/20180519152358280?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTk4MTUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
    2. 先进先出页面置换算法（FIFO）：该算法总是淘汰先进入内存的页面，即选择在内存中驻 留时间久的页面予以淘汰。
    ![利用 FIFO 置换算法时的置换图](https://img-blog.csdn.net/20180519152711829?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTk4MTUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
    3. 最近最久未使用置换算法（LRU）：选择近久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页 面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t值大的，即近久未使用的页面予以淘汰。
    ![利用 LRU 置换算法时的置换图](https://img-blog.csdn.net/20180519153146905?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTk4MTUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
    4. 最少使用置换算法（LFU）
  - 请求分段存储管理方式
  ![请求分段系统中的中断处理过程](https://img-blog.csdn.net/20180606215700696?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fWW9uZ2Jv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  ![请求分段系统的地址变换过程](https://img-blog.csdn.net/20180606215712204?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fWW9uZ2Jv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

---
### 存储器管理
  - 存储器的层次结构(存储介质层次越高，越靠近 CPU，存储介质的访问速度越快，价格越高，配置的存储容量越少)
  ![计算机系统存储层次示意](https://img-blog.csdn.net/20140214214644421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvR2VuaXVzX0xH/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
  - 程序的在系统的运行过程
  ![对用户程序的处理步骤](http://c.biancheng.net/cpp/uploads/allimg/140630/1-1406301T554425.jpg)
    1. 编译，由 Compiler 编译程序对用户的源程序进行编译，形成若干个 **目标模块（Object Module）**。
    2. 链接，由 Linker 链接程序对 **目标模块** 以及它们所需要的库函数链接在一起，形成 **装入模块（Load Module）**。
    3. 装入，由 Loader 装入程序将 **装入模块** 装入内存。
  - 程序的装入
    **逻辑地址：作业程序地址。物理地址（绝对地址）：运行内存地址。**
    1. 绝对装入方式：计算机系统很小，单道程序，用户程序经过编译后产生 **绝对地址（物理地址）**。物理地址 = 逻辑地址
    2. 可重定位装入方式：多道程序，根据内存的具体情况装入模块撞到内存的适当位置。 物理地址 = 逻辑地址 + 内存偏移量
    3. 动态运行时的装入方式：在需要运行过程中将程序的逻辑地址改为物理地址。 物理地址 = 逻辑地址 + 重定位寄存器
  - 程序的链接
    1. 静态链接方式：在运行之前链接成一个完整的装配模块。（对相对地址进行修改，变换外部调用符号）
    2. 装入时动态链接：边装入边链接（便于修改和更新，便于实现对目标模块的共享）
    3. 运行时动态链接：某些模块的链接推迟到程序执行时才进行
  - 连续分配存储器管理方式
    1. 单一连续分配
    2. 固定分区分配（分区大小相等，分区大小不等）
    3. 动态分区分配：根据进程的实际需要，动态分配内存空间。
      内存分配流程图：
      ![内存分配流程](https://img-blog.csdn.net/20180606211357210?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fWW9uZ2Jv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
      内存回收的情况：
      (1) 回收区与插入点的前一个空闲分区F1相邻接，此时应将回收区与插入点的前一分区合并，不必为回收分区分配新表项，而只需修改其前一分区F1的大小。
      (2) 回收区与插入点的后一空闲分区F2相邻接，此时也可将两分区合并，形成新的空闲分区，但用回收区的首址作为新空闲区的首址，大小为两者之和。
      (3) 回收区同时与插入点的前、后两个分区邻接。此时将三个分区合并，使用F1的表项和F1的首址，取消F2的表项，大小为三者之和。
      (4) 回收区既不与F1邻接，又不与F2邻接。这时应为回收区单独建立一新表项，填写回收区的首址和大小，并根据其首址插入到空闲链中的适当位置。
    4. 基于顺序探索的动态分区分配算法
      首次适应算法：从链首开始顺序迭代，找第一个能满足的。
      循环首次适应算法：从上一次找到的空闲分区的下一个分区开始迭代，找第一个能满足的。
      最佳适应算法：空闲分区由小到大排序，找到第一个能满足的。（能满足要求的最小分区）
      最坏适应算法：空闲分区由大到小排序，选第一个是否满足。（选最大的分区）
    5. 基于索引搜索的动态分区分配算法：快速适应算；伙伴系统；哈希算法；
    6. 动态可重定位分区分配
      **紧凑：将零碎的分区通过地址移动变换成连续整块的分区和连续的空闲分区，但是消耗系统效率。**
      ![动态重定位示意图](https://img-blog.csdn.net/20180606211654868?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fWW9uZ2Jv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
      ![动态分区分配算法流程图](https://img-blog.csdn.net/20180606211709523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fWW9uZ2Jv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  - 对换：把内存中暂时不能运行的进程或者暂时不用的程序和数据换出到外存上，以便腾出内存空间。
    1. 对换的类型：整体兑换；分页（分段）对换；
    2. 进程的换出：将内存中的某些进程调出至对换区；
    3. 进程的换入：对换进程将定时执行换入操作，从 PCB 集合中找到 “就绪” 状态但已换出的进程。
  - 分页存储管理方式
    ![页表的作用](https://upload-images.jianshu.io/upload_images/5750276-694f906c0a8145ea..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/298/format/webp)
    ![分页系统的地址变换机构](http://my.csdn.net/uploads/201208/03/1343991424_1705.png)
    ![具有快表的地址变换机构](http://my.csdn.net/uploads/201208/03/1343992527_2941.png)
  - 分段式存储管理方式
    ![利用段表实现地址映射](http://my.csdn.net/uploads/201208/03/1343998285_4135.png)
    ![分段系统的地址变换过程](http://my.csdn.net/uploads/201208/03/1344000618_9034.png)
  - 段页式存储管理方式
    ![利用段表和页表实现地址映射](http://my.csdn.net/uploads/201208/04/1344085996_8950.png)
    ![段页式系统中的地址变换机构](http://my.csdn.net/uploads/201208/04/1344086292_1463.png)
  - 分页和分段的区别
  (1) 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 
  (2) 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。
  (3) 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。 

---
### 死锁
  - 引起死锁的主要资源问题是：需要采用互斥访问方式方法的，不可被抢占的资源（即在进程同步中的 **临界资源**，如打印机，数据文件，队列，信号量等）
  - 资源类型
    1. 可重用性资源：可供用户重复使用多次的资源；只能分配给一个进程使用，不允许多进程共享；单元数目是相对固定，进程运行期间无法创建也不能删除；
    2. 可消耗性资源：有进程动态创建和消耗；单元数目在进程运行期间是可以不断变化的，可以在程序运行期间进行创建和回收；
    3. 可抢占性资源：某进程获得可抢占性资源后，该资源可以被另一个进程或系统抢占；
    4. 不可抢占性资源：进程获得不可抢占性资源后，只能在进程用完后将自行释放；
  - 死锁的起因
    1. **竞争不可抢占性资源**
    2. **竞争可消耗性资源**
    3. 进程推进顺序不当
  - **死锁的定义：在一组死锁进程中，每个进程都在等待另一个死锁进程所占有的资源**
  - 产生死锁的条件
    1. 互斥条件：资源只能被一个进程持有
    2. 请求和保持：进程持有一个资源，又请求其他新资源，新资源被其他进程占有，导致进程进入阻塞
    3. 不可抢占：已经持有的资源无法被其他进程抢占，只能进程运行完自行释放
    4. 循环等待：一组进程运行期间形成 **进程——资源循环链**
  - 处理死锁的方法：预防死锁；避免死锁；检测死锁；解除死锁；
  - 预防死锁
    1. 破坏 “请求与保持” 条件：请求资源时，不能持有不可抢占资源。
    2. 破坏 ”不可抢占” 条件：当进程持有不可抢占资源并请求新资源时，必须要释放所有保持的资源。
    3. 破坏 “循环等待” 条件
  - 避免死锁
    允许进程动态申请资源，但在进行资源分配时必须要先计算此次资源分配的安全性。（若分配会导致系统进入不安全状态，则不能将资源分配给该进程）
    1. 系统安全状态：系统能按某种进程推进顺序为每个进程分配资源，直到满足每个进程对资源的最大需求，并且能使每个进程顺利完成。
    2. **银行家算法**
      一个进程进入系统要声明所需要的资源的最大单元项目（不能超过系统总资源）
      进程请求一组资源时，首先要确定是否有足够的资源分配给该进程。
        - 资源足够，确定系统是否处于安全状态。
          - 分配资源后系统处于安全状态，则可以进行分配。
          - 分配资源后系统处于不安全状态，则需要进行资源回滚。
        - 资源不够，不能进行分配。

      **银行家算法的例子学习：**（不写代码过程太繁琐，直接看例子来理解更容易，书本 P113，或者网上例子）
  - 死锁的检测
    1. 资源分配图: P 是进程， R 是资源。
      ![资源分配图](https://upload-images.jianshu.io/upload_images/5853159-eb277b120721a49c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300/format/webp)
  - 死锁的解除
    1. 抢占资源：从一个或多个进程种抢占足够数量的资源分配给死锁进程。
    2. 终止（或撤销）进程：终止或撤销进程中的一个或多个死锁进程，直到打破循环环路。（终止所有进程或者逐个终止进程）

---
### 处理机调度
  - 处理机调度的层次
    1. 高级调度（对象：作业）
    2. 低级调度（对象：进程）
    3. 终极调度（对象：内存）
  - 处理机调度算法的目标：CPU 利用率高，符合系统要求。
    1. 处理机调度算法的共同目标：资源利用率（CPU工作时间/（CPU 工作时间 + CPU 空闲时间））；公平性；平衡性；策略强制性强；
    2. **批处理系统的目标**：平均周转时间短（周转时间：提交作业至作业完成）；系统吞吐量高；处理机利用率高；
    3. 分时系统的目标：响应时间快；均衡性；
    4. 实时系统的目标：截至时间的保证；可预测性；
  - **作业调度**
    1. 作业：包含通常的程序和数据，还配有一份作业说明书（系统根据说明书来对程序的运行进行控制）
    2. 作业步：“编译”作业步；”链接装配”作业步；“运行”作业步；
    3. 作业控制块（JCB）：保存系统对作业进行管理和调度的所需的全部信息
  - 作业运行的三个阶段和三个状态
    1. 收容阶段：建立 JCB，作业进入“后备状态”
    2. 运行阶段：建立 PCB，程序进入“运行状态”
    3. 完成阶段：回收作业的 JCB 和所有资源，作业进入”完成状态”
  - 作业调度的任务
    1. 接纳多少个作业？根据系统的 CPU 和内存来决定，尽最大可能提高资源和 CPU 的利用率
    2. 接纳哪些作业？取决于采用的 **调度算法** ，各调度算法有不同的特特点和属性。
  - **作业调度算法**
  **带权周转时间 = 周转时间 / 服务时间；周转时间 = 完成时间 - 到达时间；**
    1. 先来先服务调度算法（FCFS）：系统按照作业到达的先后次序来进行调度（优先调度在系统等待时间最长的作业）
    2. 短作业优先的调度算法（SJF）：以作业的长短来计算优先级；作业越短，越快被调度；作业的长短是作业要求的运行时间；
      缺点：必须预知作业的运行时间；对长作业非常不利；人机无法实现交互；未考虑作业的紧迫程度；
    3. 优先级调度算法（PSA）：在外部赋予作业响应的优先级，根据作业的优先级进行调度；
    4. 高相应比优先调度算法（HRRN)：响应比 Rp = （等待时间 + 服务时间） / 服务时间；等待时间越长，响应比相对增加；
  - **进程调度**
    1. 进程调度的任务：保存处理机的现场信息；按某种算法选取进程（从就绪队列中选取）；按处理器分配给进程；
    2. 进程调度机制
      ![进程调度机制](https://img-blog.csdn.net/20180427154109752?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fWW9uZ2Jv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
  -  **进程调度的方式**
    1. 非抢占方式：一旦处理机分配给某进程，就一直运行下去，直到该进程完成，或者进程发生某事件被阻塞才把处理机分配给其他进程
      引起进程调度的因素：进程运行完毕或者发生某事件无法继续运行；进程提出 I/O 请求暂停运行；在进程通信或同步过程中执行了某些原语操作（如：Block 原语）；
    2. **抢占方式**：允许调度程序根据某种原则，暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一个进程；
      需要遵循的原则：优先权原则；短进程优先原则；**时间片原则**；
  - **进程调度算法**
    **带权周转时间 = 周转时间 / 服务时间；周转时间 = 完成时间 - 到达时间；**
    1. 轮转调度算法（基于时间片）
      基本原理：所有就绪进程按 FCFS 策略排成进程就绪队列，系统设置一定时间（时间片）产生一次中断，激活进程调度程序进行调度，把 CPU 分配给队列，**让该进程执行一个时间片**。
      切换时机：进程在一个时间片尚未用完就已经执行完，激活进程调度程序，从就绪队列中移除，进行下一次轮转；在一个时间片内，进程尚未完成，计时中断程序被激活，将进程送往就绪队列尾部，进行下一次轮转；
      时间片大小确定：**一个较为可取的时间片大小是略大于一次典型的交互所需要的时间，使大多数交互式进程能在一个时间片内完成。**
    2. 优先级调度算法
      非抢占式优先级调度算法：等一个进程执行完，分配处理机给最高优先级的进程
      抢占式优先级调度算法：只要出现另一个优先级更高的进程，调度程序就将处理机分配给新到的的优先级最高的进程
      优先级类型：静态优先级（在进程创建时确定）；动态优先级（随进程的推进优先级改变）；
    4. 多队列调度算法
    5. 多级反馈队列调度算法(优先级越高，时间片越短)
    ![多级反馈队列调度算法](https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=f6230aca750e0cf3a0a246fd3a76de27/eac4b74543a98226a98d8cff8d82b9014b90eb9e.jpg)
    6. 基于公平原则的调度算法

  <!--more-->
---
### 进程
  - 前趋图：描述一组进程的顺序和并发执行情况
  ![前趋图](https://upload-images.jianshu.io/upload_images/1711514-10640ee4c2c8c273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/784/format/webp)
  - 进程执行的特征
    1. 顺序执行特征：顺序性，封闭性，可再现性
    2. 并发执行特征：间断性，失去封闭性，不可再现性
  - **进程控制块（PCB）** ：描述进程的基本情况和活动过程，对进程进行控制和管理。
    1. 进程实体 = 程序 + 数据 + 进程控制块
    2. 创建进程就是创建进程的 PCB，撤销进程就是撤销进程的 PCB。
    3. **PCB 的作用：使多道程序能够独立运行。（使进程并发执行）**
    4. PCB 的信息：进程标识符，处理机状态，进程调度信息，进程控制信息。
    5. 操作系统管理 PCB 的方式：线性方式（线性表），链接方式（链表），索引方式（进程状态索引表）  
  - 进程的状态转换
    1. 状态转换图（创建,就绪，执行，阻塞，，终止）
    ![状态转换图](https://images2018.cnblogs.com/blog/1048215/201802/1048215-20180225230728426-2048803863.png)
    2. 引入 **挂起** 状态转换图（创建，活动就绪，静止就绪，活动阻塞，静止阻塞，执行，终止）
    进程挂起 ：进程处于静止状态，若正在执行，则暂停执行；若正在就绪，则不被调度；等待 **激活**。
    ![引入挂起的进程状态转换图](https://images2018.cnblogs.com/blog/1048215/201802/1048215-20180225230737441-833727159.png)
  - 进程的控制
    1. 引起创建：用户登录；作业调度；提供服务；应用请求。
      进程创建：申请空白 PCB；分配资源；初始化 PCB；插入就绪队列（就绪队列有空间）；
    2. 引起终止：正常结束；异常结束（越错界，保护错，非法指令，特权指令错，运行超时，等待超时，算术运算错）；外界干预（操作系统发生了某事件，父进程请求，父进程终止）
      进程终止：根据标识符在 PCB 集合中检索；进程在执行应立即终止执行；若进程有子进程，应终止所有子进程；回收被终止进程的资源；将终止进程的 PCB 从 PCB 集合中移除；
    3. 引起阻塞：共享资源失败；等待某种操作完成；新数据还没到达；等待新任务到达；
      进程阻塞（自身的主动行为）：进程处于执行状态应立即停止执行；PCB 置于阻塞状态；把 PCB 插入阻塞队列；
      进程唤醒：把被阻塞进程从阻塞队列移除；PCB 状态由阻塞改为就绪状态；将 PCB 插入就绪队列。
    4. 引起挂起：终端用户需要；父进程请求；负荷调节；操作系统需要；
      进程挂起：若进程活动就绪，改为静止就绪；若进程活动阻塞，改为静止阻塞；将进程的 PCB 复制到指定的内存区域；
      进程激活：若进程静止就绪，改为活动就绪；若进程静止阻塞，改为活动阻塞；
  - **进程同步**
    1. 进程同步机制：多个进程在执行次序上进行协调；并发执行的进程进行共享系统资源；使程序的执行具有可再现性；
    2. 临界资源：多个进程采取互斥的方式对临界资源实现共享；（多个进程都需要访问的资源）
    3. 临界区：每个进程中访问临界资源的代码块；
    4. 互斥访问：如果该资源未被访问，进程可进行访问该资源，并设置正在被访问标志；如果资源正在被某进程访问，则本进程无法访问该资源；
    5. 同步机制的规则：空闲让进；忙则等待；有限等待；让权等待；
  - 硬件实现进程同步机制
    优点：简单实现
    缺点：访问进程要不断测试是否可以进入，处于“忙等”状态，不符合“让权等待”原则，造成处理机时间浪费。
    1. 关中断实现同步：在进入所测试之前关闭中断，完成锁测试并上锁后打开中断。（进程在临界区执行时，**计算机系统不响应中断**）
      关中断缺点：可能道导致严重后果；影响系统效率；不适用多 CPU 系统；
    2. Test-and-Set 指令实现同步：

    ```c
      boolean TS(boolean *lock){
        Boolean old;
        old = *lock;
        *lock = TRUE;
        return old;
      }
    ```

    ```c
      do {
        非临界资源操作；
        while TS(&lock); /*当临界资源被锁时阻塞在这*/
        临界资源操作;
        lock = FALSE; /*释放临界资源的锁*/
        非临界资源操作;
      }while (TURE)
    ```
    3. Swap 指令实现同步：

    ```c
      void swap(boolean *a, boolean *b){
        boolean temp;
        temp = *a;
        *a = *b;
        *b = temp;
      }
    ```

    ```c
      do {
        key = TURE;
        do {
          swap(&lock, &key);
        } while(key != FALSE); /*当临界资源被锁时阻塞在这*/
        临界资源操作;
        lock = FALSE;
        非临界资源操作;
      } while(TRUE);
    ```
  - 信号量机制实现同步（wait(S) , signal(S)）
    1. 整形信号量(未遵循让权等待，出现 “忙等”)

    ```c
      wait(S){
        while (S <= 0) {
          S--;
        }
      }
      signal(S){
        S++;
      }
    ```
    2. 记录型信号量（符合让权等待，共享一个临界资源，交替共享多个临界资源易发生死锁）

    ```c
      typedef struct {
        int value; //资源数目
        struct process_control_block *list;/*进程链表指针*/
      }semaphore;
      wait(semaphore *S){
        s->value--;
        if (S->value < 0) block(S->list); /*资源不够,阻塞当前进程，放弃处理机*/
      }
      signal(semaphore *S){
        S->value++;
        if (S->value <= 0) wakeup(S->list); /*仍有阻塞进程，唤醒被阻塞的进程*/
      }
    ```
    3. AND 型信号量（共享多个临界资源，一个单位）：多个临界资源要么全部都分配给一个进程，要么都不分配给一个进程。
    实现方式：在 wait 操作中增加一个 "AND" 条件，即 wait 操作要传入多个临界资源，对每个临界资源实现类似 **记录型信号量** 的操作。

    ```c
      Swait(S1, S2, ... ,Sn){
        while (TRUE) {
          if (Si >= 1 && ... && Sn >= 1){
            for (i = 1; i < n; i++) Si--;   /*可以共享*/
            break;
          }else {
            /*资源不够，进程进入阻塞队列，放弃处理机*/
          }
        }
      }
      Ssignal(S1, S2, ... ,Sn){
        while (TRUE) {
          for (i = 1; i <= n; i++) {  /*释放锁*/
            Si++;
            /*进程进入就绪队列*/
          }
        }
      }
    ```
    4. 信号量集（对多个单位的临界资源实现共享）
    Swait(S1, t1, d1 ,..., Sn, tn, dn);
    Ssignal(S1, d1 ,..., Sn, dn);
  - **信号量的应用**
    1. 利用信号量实现进程互斥

    ```c
      semaphore mutex=1;
      Px(){
        while(1){
          wait(mutex);
          临界区;
          signal(mutex);
          剩余区;
        }
      }
    ```
    2. **利用信号量实现前趋关系**
    **巧记：指入 wait；指出 signal**
    通过例子学习：
    ![前趋图举例](https://upload-images.jianshu.io/upload_images/656630-33723c9b511ef3d3.png?imageMogr2/auto-orient/strip|imageView2/1/w/300/h/240)
    前趋关系：S1->S2, S1->S3 设置信号量 a，b；S2->S4,S2->S5,S3->S6,S4->S6,S5->S6 设置信号量 c,d,e,f,g；
    ```c
      P1(){S1; signal(a);signal(b);}
      P2(){wait(a),S2; signal(c);signal(d);}
      P3(){wait(b);S3; signal(e);}
      P4(){wait(c);S4; signal(f);}
      P5(){wait(d);S5; signal(g);}
      P6(){wait(e);wait(f);wait(g);S6;}
      main(){
        semaphore a,b,c,d,e,f,g;
        a.value = b.value = c.value = d.value = e.value = f.value = g.value = 0;
        cobegin
          P1();P2();P3();P4();P5();P6();
        coend
      }
    ```
  - 管程机制（面向对象思想）：用少量信息和对该资源所执行的操作来表征该资源，忽略它们的内部结果过和实现细节，利用共享数据结构抽象表示系统的共享资源。
  - 经典进程同步问题
    1. 生产者-消费者问题（利用各种信号量解决）
    2. 哲学家进餐问题（利用 AND 信号量机制解决）
    3. 读者-写者问题 （利用 记录型信号量 和 信号量集 解决）
  - 进程通信
    1. 共享存储系统
    2. 管道通信系统（UNIX）
    3. 消息传递系统
    4. 客户机-服务器系统（CS 系统）
  - 进程和线程的区别？
    1. 进程是系统进行资源分配和调度的一个独立单位，拥有独立的系统资源空间（内存地址），一个应用程序至少有一个进程，一个进程至少有一个线程。
    2. 线程是进程的一个实体，是 CPU 调度和分配的基本单位，必须依赖应用程序（进程）存在。线程只拥有一点在线程运行过程必须的资源，但是线程之间没有单独的地址空间。
---
