{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/alipay.png","path":"img/alipay.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/weixin.png","path":"img/weixin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1528938290846},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1528938290848},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1528938290869},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1528938290846},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1528938290868},{"_id":"themes/yilia/_config.yml","hash":"671c33894059d5120d598ffeecc40ae63356d4dd","modified":1529330579303},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1528938290867},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1528938290902},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1528938290958},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1528938290869},{"_id":"source/_posts/Android 基础.md","hash":"52515ca5dbdfcc41012e9eaf48721d1319fb1812","modified":1544158391224},{"_id":"source/_posts/Android View.md","hash":"2a2093946fb35911547607055d7226eb92aa6964","modified":1531915752408},{"_id":"source/_posts/Android 屏幕适配.md","hash":"b488df3323b7f13445aedea8ee0fb80aef8ac593","modified":1530868508392},{"_id":"source/_posts/Android 构建知识.md","hash":"46ffc74705b23e7f9f8609dbb8b576470d6122a4","modified":1532313375374},{"_id":"source/_posts/Android Retrofit.md","hash":"684096e73cf201a0cad3bb7d869781efa8a4f226","modified":1532657039175},{"_id":"source/_posts/Android Volley.md","hash":"9e196711fcea350a0076458b20992f7cb82d5c17","modified":1532228264993},{"_id":"source/_posts/JAVA 基础.md","hash":"5d3ce0049682590308924f05301c6098d2bb4544","modified":1544142504093},{"_id":"source/_posts/Android 绘制过程.md","hash":"5203d5a7758324ff8db40fe612f00d96a1cf0fc2","modified":1543981444151},{"_id":"source/_posts/操作系统.md","hash":"047b189898ab70268cd87cd08e96d3993ed61bfe","modified":1543316915598},{"_id":"source/_posts/Android 进程保活.md","hash":"22347d0de08b86f5ff25500ae6f8f7cdf07e88e5","modified":1530868524896},{"_id":"source/_posts/Java Thread.md","hash":"4d5d8d6f9cdc978831e264009e42b7937e161d47","modified":1543318877262},{"_id":"source/_posts/计算机网络.md","hash":"1f7dcfe3502203a6b284fc58db2ce54c702aeb4c","modified":1543834714707},{"_id":"source/_posts/设计模式.md","hash":"877a6bbb342e9147f6f6cc19c17ac9b12bdddf5d","modified":1543834718589},{"_id":"source/_posts/数据结构和算法.md","hash":"32b76d5427923a19f323f6369edb9c1ed9bac778","modified":1543834852254},{"_id":"source/_posts/随手记.md","hash":"3f5d2c133ab06c6857b561251db52ca733c8c607","modified":1543673134468},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1528938290813},{"_id":"themes/yilia/.git/config","hash":"316bc92d9936dc739c39161838a28fb4641cbea2","modified":1528938290824},{"_id":"themes/yilia/.git/index","hash":"8028bbc83b7e3f31c102dd8978b88b0dc064790a","modified":1528967592800},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1528938290807},{"_id":"themes/yilia/.git/ORIG_HEAD","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1529118416613},{"_id":"themes/yilia/.git/FETCH_HEAD","hash":"1efc9d034adf6456e816fcbb20023807ca64bbd0","modified":1529118416273},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1528938278668},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1528938290897},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1528938290898},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1528938290897},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1528938290899},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1528938290900},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1528938290901},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1528938290898},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1528938290952},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1528938290903},{"_id":"themes/yilia/source/slider.e37972.js","hash":"ce5eac88301fe4f2fce0fb6203adfd58eb8313ac","modified":1528938290957},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1528938290871},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1528938290873},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1528938290873},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1528938290872},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1528938290943},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1528938290874},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1528938290875},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1528938290895},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1528938290876},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1528938290956},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1528938278684},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"283ae27ea37ac3e0e45b2e05c2482a4c594b9c25","modified":1528938290954},{"_id":"themes/yilia/.git/logs/HEAD","hash":"eb242ba76aab3ceede27a10498c0b3d5787befd3","modified":1528938290816},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1528938290878},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1528938290878},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1528938290882},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1528938290880},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1528938290879},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1528938290882},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1528938290881},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1528938290884},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1528938290885},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1528938290883},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1528938290883},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1528938290885},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"8dea8f5f93a60185439b330b0f1d1649a6ab4bd0","modified":1528938290879},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1528938290886},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1528938290896},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1528938278670},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1528938278677},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1528938278669},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1528938278676},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1528938278679},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1528938290896},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1528938278678},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1528938278681},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1528938278681},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"18be3eb275c1decd3614e139f5a311b75f1b0ab8","modified":1528938278680},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1528938290945},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1528938278682},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1528938290947},{"_id":"themes/yilia/source/img/alipay.png","hash":"c399ffad91c5ae531b1fd8e682c601ee93032f2c","modified":1528955441411},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1528938290950},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1528938290950},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1528938290946},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1528938290949},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1528938290951},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1528938290948},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1528938290947},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1528938290905},{"_id":"themes/yilia/source/img/weixin.png","hash":"f09f98110c23d0e9dddff3df2e6ffbdc9107956e","modified":1528955549126},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1528938290904},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1528938290905},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1528938290907},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1528938290906},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1528938290909},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1528938290910},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1528938290908},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1528938290910},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1528938290922},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1528938290916},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1528938290922},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1528938290923},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1528938290927},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1528938290924},{"_id":"themes/yilia/source-src/css/main.scss","hash":"9eba1fcf4805256697528fcf3b767cf6dd8d0591","modified":1528938290927},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1528938290931},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1528938290930},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1528938290930},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1528938290932},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1528938290931},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1528938290933},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1528938290929},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1528938290935},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1528938290933},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1528938290934},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1528938290938},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1528938290939},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1528938290938},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1528938290937},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1528938290939},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1528938290940},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1528938290941},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1528938290941},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1528938290936},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1528938290940},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1528938290928},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1528938290942},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1528938290942},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1528938290894},{"_id":"themes/yilia/source/img/avatar.jpg","hash":"5b50e4df88edaf5fe4774f4a3b2a4175505547ac","modified":1523274758283},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1528938290815},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1528938290888},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1528938290888},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1528938290887},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1528938290889},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1528938290890},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1528938290892},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1528938290889},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1528938290892},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1528938290891},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1528938290893},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1528938290921},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1528938290920},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1528938290918},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1528938290919},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1528938290912},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1528938290912},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1528938290913},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1528938290925},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1528938290926},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1528938290914},{"_id":"themes/yilia/.git/objects/pack/pack-b8490dda68e624775e79022edc4d67e2489c374a.idx","hash":"566151aae7e4b3388cf8a52d1249870114e9b0d3","modified":1528938290551},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1528938290925},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1528938290915},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"eb242ba76aab3ceede27a10498c0b3d5787befd3","modified":1528938290818},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1528938290812},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"eb242ba76aab3ceede27a10498c0b3d5787befd3","modified":1528938290812},{"_id":"themes/yilia/.git/objects/pack/pack-b8490dda68e624775e79022edc4d67e2489c374a.pack","hash":"5797696d4c18d63b1238eb31dfba9c4545aeaa83","modified":1528938290621},{"_id":"public/content.json","hash":"d034c6381f3da119333e7d66f7d3d3f79d71cd57","modified":1544322046832},{"_id":"public/2018/11/28/随手记/index.html","hash":"83fb48b1ed58294b1284df925968ebe98a017570","modified":1544322047237},{"_id":"public/2018/11/27/数据结构和算法/index.html","hash":"af9f080f28e8f6376a613401eb8f5f4b138f1c62","modified":1544322047237},{"_id":"public/2018/11/27/设计模式/index.html","hash":"683f62992c2696c26205f572b10bd5ff0b62668a","modified":1544322047238},{"_id":"public/2018/11/27/操作系统/index.html","hash":"58f6bd10b18462a71ade1319897c79b497d455e5","modified":1544322047238},{"_id":"public/2018/11/27/计算机网络/index.html","hash":"1a47edaeeee6219f4c5e3d1fa12cf46d904ec7c6","modified":1544322047238},{"_id":"public/2018/11/27/Android 基础/index.html","hash":"2e7c88e7edc921fbf0bbe9f0f0ba79afe23dd455","modified":1544322047238},{"_id":"public/2018/11/27/JAVA 基础/index.html","hash":"939358c5b774c2ace61bee32066f4c3aaff6e9d0","modified":1544322047238},{"_id":"public/2018/08/02/Android 绘制过程/index.html","hash":"b07dce624d78d5c297d20cd35807a3f4bad474bc","modified":1544322047239},{"_id":"public/2018/07/27/Java Thread/index.html","hash":"d39bc887713fb33e4cb8e711fe862829cc64626e","modified":1544322047239},{"_id":"public/2018/07/26/Android Retrofit/index.html","hash":"a16ea359749e762d3ec5b4a4f8b4cbfaade763f5","modified":1544322047239},{"_id":"public/2018/07/21/Android 构建知识/index.html","hash":"65cec9a3ff97b2adbbd72c8961545a85840f4ac2","modified":1544322047239},{"_id":"public/2018/07/19/Android Volley/index.html","hash":"9f163ca5cb3f8eae75b7ddd9a51a93dc9c38d86f","modified":1544322047240},{"_id":"public/2018/07/18/Android View/index.html","hash":"944ef6c01a720588b29a20e4583034c8d5719169","modified":1544322047240},{"_id":"public/2018/07/06/Android 进程保活/index.html","hash":"dc4d17f39e200819071875e93005d15ad1144a8c","modified":1544322047240},{"_id":"public/2018/07/06/Android 屏幕适配/index.html","hash":"4961c4889d2a0acbd35ca0597905c4e36609ad8a","modified":1544322047240},{"_id":"public/archives/index.html","hash":"e4788196fb874894c4195afbc14d697248a83b5c","modified":1544322047241},{"_id":"public/archives/page/2/index.html","hash":"f22a3aaf7f44579337f99b654851fccde38f42a5","modified":1544322047241},{"_id":"public/archives/2018/index.html","hash":"b28ae138d03c7bc19a0125c182dae1a90927b8bf","modified":1544322047241},{"_id":"public/archives/2018/page/2/index.html","hash":"b858b2344c6f017c00ab4129b670faab93105cf5","modified":1544322047241},{"_id":"public/archives/2018/07/index.html","hash":"4b5907b6be1822c5e6a018bde24a0f528237bc3e","modified":1544322047242},{"_id":"public/archives/2018/08/index.html","hash":"dcffe1fe107e343264e1d16ec8d2267daae7248f","modified":1544322047242},{"_id":"public/archives/2018/11/index.html","hash":"2e11c5a791adb71c3bb47196fb6582ce7aab6b48","modified":1544322047242},{"_id":"public/index.html","hash":"25086b27fd3f425588ade7a9cd139a2c34504856","modified":1544322047242},{"_id":"public/page/2/index.html","hash":"15a4ac49e4cc66eec17a66d8c9ec343cc676005d","modified":1544322047242},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1544322047283},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1544322047283},{"_id":"public/img/alipay.png","hash":"c399ffad91c5ae531b1fd8e682c601ee93032f2c","modified":1544322047283},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1544322047283},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1544322047284},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1544322047284},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1544322047284},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1544322047284},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1544322047284},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1544322047284},{"_id":"public/img/weixin.png","hash":"f09f98110c23d0e9dddff3df2e6ffbdc9107956e","modified":1544322047284},{"_id":"public/img/avatar.jpg","hash":"5b50e4df88edaf5fe4774f4a3b2a4175505547ac","modified":1544322047289},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1544322047302},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1544322047302},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1544322047302},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1544322047303}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Android 基础","date":"2018-11-27T06:52:57.753Z","_content":"### [Android 内存优化](https://mp.weixin.qq.com/s/Z7oMv0IgKWNkhLon_hFakg?)\n  - **RAM优化** ：降低程序在运行时使用的内存，防止由于内存不足导致程序被系统杀死。（LMK 机制：LowMemoryKill）\n  - ROM 优化 : 主要是降低程序的占用空间，降低 Apk 的大小，防止偶遇 ROM 不足导致程序无法被安装。\n\n\n  - 内存泄漏的解决方法\n    1. [AndroidExcludedRefs](https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java) 列出很多由于系统原因导致引用无法释放的例子，通过 hack 的建议去修复。\n    2. 兜底回收内存，Activity 泄漏导致其引用的资源无法释放，兜底回收是指将 Activity 所持有的资源都回收掉（引用置 null），然后剩下的 Activity 就是个空壳。\n  - 降低运行时内存大小\n    1. 减少 bitmap 占用的内存，图片按需求的 View 大小加载。统一使用 bitmap 的加载器，在发生 OOM 时清除缓存。\n    2. 监控程序堆内存的使用率，达到程序的设定值则启动相关模块进行内存释放。\n    3. 多进程：将对于会引发内存泄漏或者占用内存过大的组件放置单独的进程中运行。\n---\n### [Android Retrofit](https://square.github.io/retrofit/)\n  - Retrofit 是一个网络请求的封装库，为什么说它只是个封装库，因为它本身并没有实现网络请求的逻辑，而是底层交给 OkHttp 进行实现网络请求，支持多种数据转换器（Converters，如 GSON, Jackson）。\n  - 使用特性：\n    1. 通过接口注解来描述一个 HTTP 请求，Url 参数和 Request 参数。\n    2. 通过定义返回值为 Observable<> 类型，它还能异步框架 RxJava 结合，实现异步请求网络进行加载数据。\n    3. 支持获取原生的 HTTP 请求数据（Raw）。\n  - 源码实现\n    1. Retrofit 实例化是通过 Builder 设计模式来实现的，可以配置 Retrofit 的 **根 URL**， **数据转换器**， **进行 HTTP 网络请求的客户端**。\n    2. 通过一个接口和接口方法上的注解来定义一个 HTTP 网络请求的 API 接口，这个接口包含 HTTP 请求的类型,参数等信息。\n    3. 在底层 creat() 方法，Retrofit 通过 JAVA 动态代理来获取 HTTP 请求接口的代理对象，代理对象将 HTTP 请求接口方法上面的注解解析成一个 ServiceMethod 类型的对象，再通过该对象构建 OKHttp 的请求。\n    ```Java\n    public <T> T create(final Class<T> service) {\n        Utils.validateServiceInterface(service);\n        if (validateEagerly) {\n          eagerlyValidateMethods(service);\n        }\n        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n            new InvocationHandler() {\n              private final Platform platform = Platform.get();\n\n              @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n                  throws Throwable {\n                // If the method is a method from Object then defer to normal invocation.\n                if (method.getDeclaringClass() == Object.class) {\n                  return method.invoke(this, args);\n                }\n                if (platform.isDefaultMethod(method)) {\n                  return platform.invokeDefaultMethod(method, service, proxy, args);\n                }\n                ServiceMethod<Object, Object> serviceMethod =\n                    (ServiceMethod<Object, Object>) loadServiceMethod(method);\n                OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n                return serviceMethod.adapt(okHttpCall);\n              }\n            });\n      }\n    ```\n---\n### Content Provider\n\n- [Content Provider 的一些理解](https://www.jianshu.com/p/c70ae80cf64d)\n  1. 主要用于不同程序之间实现数据共享的功能，还可以通过 Content Provider 来实现跨进程之间的通信。在 Android 系统自带有很多 Content Provider（通信录，短信等）。\n  2. 在 Content Provider 的 回调方法中， onCreate() 方法是运行在主线程（UI线程）中，在 AMS 通过 ActivityThread 创建并回调 onCreate() 方法，不能再 onCreat() 方法中耗时操作。其他方法 query(), insert(), update(), delete() 等方法都是运行在应用 程序的 Binder 维护的线程池中，所以在其他方法耗时操作不会阻塞主线程。\n\n----\n### [Dagger2](https://www.jianshu.com/p/24af4c102f62)\n  - Dagger 2 是一个依赖注入框架，在编译期间自动生成代码，负责依赖对象的创建。\n  - 使用 Dagger 2 的好处就是项目解耦。\n\n---\n","source":"_posts/Android 基础.md","raw":"title: Android 基础\ndate: 2018-11-30 14.00\ntags:\n\n------\n### [Android 内存优化](https://mp.weixin.qq.com/s/Z7oMv0IgKWNkhLon_hFakg?)\n  - **RAM优化** ：降低程序在运行时使用的内存，防止由于内存不足导致程序被系统杀死。（LMK 机制：LowMemoryKill）\n  - ROM 优化 : 主要是降低程序的占用空间，降低 Apk 的大小，防止偶遇 ROM 不足导致程序无法被安装。\n\n\n  - 内存泄漏的解决方法\n    1. [AndroidExcludedRefs](https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java) 列出很多由于系统原因导致引用无法释放的例子，通过 hack 的建议去修复。\n    2. 兜底回收内存，Activity 泄漏导致其引用的资源无法释放，兜底回收是指将 Activity 所持有的资源都回收掉（引用置 null），然后剩下的 Activity 就是个空壳。\n  - 降低运行时内存大小\n    1. 减少 bitmap 占用的内存，图片按需求的 View 大小加载。统一使用 bitmap 的加载器，在发生 OOM 时清除缓存。\n    2. 监控程序堆内存的使用率，达到程序的设定值则启动相关模块进行内存释放。\n    3. 多进程：将对于会引发内存泄漏或者占用内存过大的组件放置单独的进程中运行。\n---\n### [Android Retrofit](https://square.github.io/retrofit/)\n  - Retrofit 是一个网络请求的封装库，为什么说它只是个封装库，因为它本身并没有实现网络请求的逻辑，而是底层交给 OkHttp 进行实现网络请求，支持多种数据转换器（Converters，如 GSON, Jackson）。\n  - 使用特性：\n    1. 通过接口注解来描述一个 HTTP 请求，Url 参数和 Request 参数。\n    2. 通过定义返回值为 Observable<> 类型，它还能异步框架 RxJava 结合，实现异步请求网络进行加载数据。\n    3. 支持获取原生的 HTTP 请求数据（Raw）。\n  - 源码实现\n    1. Retrofit 实例化是通过 Builder 设计模式来实现的，可以配置 Retrofit 的 **根 URL**， **数据转换器**， **进行 HTTP 网络请求的客户端**。\n    2. 通过一个接口和接口方法上的注解来定义一个 HTTP 网络请求的 API 接口，这个接口包含 HTTP 请求的类型,参数等信息。\n    3. 在底层 creat() 方法，Retrofit 通过 JAVA 动态代理来获取 HTTP 请求接口的代理对象，代理对象将 HTTP 请求接口方法上面的注解解析成一个 ServiceMethod 类型的对象，再通过该对象构建 OKHttp 的请求。\n    ```Java\n    public <T> T create(final Class<T> service) {\n        Utils.validateServiceInterface(service);\n        if (validateEagerly) {\n          eagerlyValidateMethods(service);\n        }\n        return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },\n            new InvocationHandler() {\n              private final Platform platform = Platform.get();\n\n              @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args)\n                  throws Throwable {\n                // If the method is a method from Object then defer to normal invocation.\n                if (method.getDeclaringClass() == Object.class) {\n                  return method.invoke(this, args);\n                }\n                if (platform.isDefaultMethod(method)) {\n                  return platform.invokeDefaultMethod(method, service, proxy, args);\n                }\n                ServiceMethod<Object, Object> serviceMethod =\n                    (ServiceMethod<Object, Object>) loadServiceMethod(method);\n                OkHttpCall<Object> okHttpCall = new OkHttpCall<>(serviceMethod, args);\n                return serviceMethod.adapt(okHttpCall);\n              }\n            });\n      }\n    ```\n---\n### Content Provider\n\n- [Content Provider 的一些理解](https://www.jianshu.com/p/c70ae80cf64d)\n  1. 主要用于不同程序之间实现数据共享的功能，还可以通过 Content Provider 来实现跨进程之间的通信。在 Android 系统自带有很多 Content Provider（通信录，短信等）。\n  2. 在 Content Provider 的 回调方法中， onCreate() 方法是运行在主线程（UI线程）中，在 AMS 通过 ActivityThread 创建并回调 onCreate() 方法，不能再 onCreat() 方法中耗时操作。其他方法 query(), insert(), update(), delete() 等方法都是运行在应用 程序的 Binder 维护的线程池中，所以在其他方法耗时操作不会阻塞主线程。\n\n----\n### [Dagger2](https://www.jianshu.com/p/24af4c102f62)\n  - Dagger 2 是一个依赖注入框架，在编译期间自动生成代码，负责依赖对象的创建。\n  - 使用 Dagger 2 的好处就是项目解耦。\n\n---\n","slug":"Android 基础","published":1,"updated":"2018-12-07T04:53:11.224Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzbf0000s8o5d5vgwwbp","content":"<h3 id=\"Android-内存优化\"><a href=\"#Android-内存优化\" class=\"headerlink\" title=\"Android 内存优化\"></a><a href=\"https://mp.weixin.qq.com/s/Z7oMv0IgKWNkhLon_hFakg?\" target=\"_blank\" rel=\"noopener\">Android 内存优化</a></h3><ul>\n<li><strong>RAM优化</strong> ：降低程序在运行时使用的内存，防止由于内存不足导致程序被系统杀死。（LMK 机制：LowMemoryKill）</li>\n<li>ROM 优化 : 主要是降低程序的占用空间，降低 Apk 的大小，防止偶遇 ROM 不足导致程序无法被安装。</li>\n</ul>\n<ul>\n<li>内存泄漏的解决方法<ol>\n<li><a href=\"https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java\" target=\"_blank\" rel=\"noopener\">AndroidExcludedRefs</a> 列出很多由于系统原因导致引用无法释放的例子，通过 hack 的建议去修复。</li>\n<li>兜底回收内存，Activity 泄漏导致其引用的资源无法释放，兜底回收是指将 Activity 所持有的资源都回收掉（引用置 null），然后剩下的 Activity 就是个空壳。</li>\n</ol>\n</li>\n<li>降低运行时内存大小<ol>\n<li>减少 bitmap 占用的内存，图片按需求的 View 大小加载。统一使用 bitmap 的加载器，在发生 OOM 时清除缓存。</li>\n<li>监控程序堆内存的使用率，达到程序的设定值则启动相关模块进行内存释放。</li>\n<li>多进程：将对于会引发内存泄漏或者占用内存过大的组件放置单独的进程中运行。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"Android-Retrofit\"><a href=\"#Android-Retrofit\" class=\"headerlink\" title=\"Android Retrofit\"></a><a href=\"https://square.github.io/retrofit/\" target=\"_blank\" rel=\"noopener\">Android Retrofit</a></h3><ul>\n<li>Retrofit 是一个网络请求的封装库，为什么说它只是个封装库，因为它本身并没有实现网络请求的逻辑，而是底层交给 OkHttp 进行实现网络请求，支持多种数据转换器（Converters，如 GSON, Jackson）。</li>\n<li>使用特性：<ol>\n<li>通过接口注解来描述一个 HTTP 请求，Url 参数和 Request 参数。</li>\n<li>通过定义返回值为 Observable&lt;&gt; 类型，它还能异步框架 RxJava 结合，实现异步请求网络进行加载数据。</li>\n<li>支持获取原生的 HTTP 请求数据（Raw）。</li>\n</ol>\n</li>\n<li>源码实现<ol>\n<li>Retrofit 实例化是通过 Builder 设计模式来实现的，可以配置 Retrofit 的 <strong>根 URL</strong>， <strong>数据转换器</strong>， <strong>进行 HTTP 网络请求的客户端</strong>。</li>\n<li>通过一个接口和接口方法上的注解来定义一个 HTTP 网络请求的 API 接口，这个接口包含 HTTP 请求的类型,参数等信息。</li>\n<li>在底层 creat() 方法，Retrofit 通过 JAVA 动态代理来获取 HTTP 请求接口的代理对象，代理对象将 HTTP 请求接口方法上面的注解解析成一个 ServiceMethod 类型的对象，再通过该对象构建 OKHttp 的请求。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">              <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class=\"line\">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class=\"line\">            OkHttpCall&lt;Object&gt; okHttpCall = <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"Content-Provider\"><a href=\"#Content-Provider\" class=\"headerlink\" title=\"Content Provider\"></a>Content Provider</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/c70ae80cf64d\" target=\"_blank\" rel=\"noopener\">Content Provider 的一些理解</a><ol>\n<li>主要用于不同程序之间实现数据共享的功能，还可以通过 Content Provider 来实现跨进程之间的通信。在 Android 系统自带有很多 Content Provider（通信录，短信等）。</li>\n<li>在 Content Provider 的 回调方法中， onCreate() 方法是运行在主线程（UI线程）中，在 AMS 通过 ActivityThread 创建并回调 onCreate() 方法，不能再 onCreat() 方法中耗时操作。其他方法 query(), insert(), update(), delete() 等方法都是运行在应用 程序的 Binder 维护的线程池中，所以在其他方法耗时操作不会阻塞主线程。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"Dagger2\"><a href=\"#Dagger2\" class=\"headerlink\" title=\"Dagger2\"></a><a href=\"https://www.jianshu.com/p/24af4c102f62\" target=\"_blank\" rel=\"noopener\">Dagger2</a></h3><ul>\n<li>Dagger 2 是一个依赖注入框架，在编译期间自动生成代码，负责依赖对象的创建。</li>\n<li>使用 Dagger 2 的好处就是项目解耦。</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Android-内存优化\"><a href=\"#Android-内存优化\" class=\"headerlink\" title=\"Android 内存优化\"></a><a href=\"https://mp.weixin.qq.com/s/Z7oMv0IgKWNkhLon_hFakg?\" target=\"_blank\" rel=\"noopener\">Android 内存优化</a></h3><ul>\n<li><strong>RAM优化</strong> ：降低程序在运行时使用的内存，防止由于内存不足导致程序被系统杀死。（LMK 机制：LowMemoryKill）</li>\n<li>ROM 优化 : 主要是降低程序的占用空间，降低 Apk 的大小，防止偶遇 ROM 不足导致程序无法被安装。</li>\n</ul>\n<ul>\n<li>内存泄漏的解决方法<ol>\n<li><a href=\"https://github.com/square/leakcanary/blob/master/leakcanary-android/src/main/java/com/squareup/leakcanary/AndroidExcludedRefs.java\" target=\"_blank\" rel=\"noopener\">AndroidExcludedRefs</a> 列出很多由于系统原因导致引用无法释放的例子，通过 hack 的建议去修复。</li>\n<li>兜底回收内存，Activity 泄漏导致其引用的资源无法释放，兜底回收是指将 Activity 所持有的资源都回收掉（引用置 null），然后剩下的 Activity 就是个空壳。</li>\n</ol>\n</li>\n<li>降低运行时内存大小<ol>\n<li>减少 bitmap 占用的内存，图片按需求的 View 大小加载。统一使用 bitmap 的加载器，在发生 OOM 时清除缓存。</li>\n<li>监控程序堆内存的使用率，达到程序的设定值则启动相关模块进行内存释放。</li>\n<li>多进程：将对于会引发内存泄漏或者占用内存过大的组件放置单独的进程中运行。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"Android-Retrofit\"><a href=\"#Android-Retrofit\" class=\"headerlink\" title=\"Android Retrofit\"></a><a href=\"https://square.github.io/retrofit/\" target=\"_blank\" rel=\"noopener\">Android Retrofit</a></h3><ul>\n<li>Retrofit 是一个网络请求的封装库，为什么说它只是个封装库，因为它本身并没有实现网络请求的逻辑，而是底层交给 OkHttp 进行实现网络请求，支持多种数据转换器（Converters，如 GSON, Jackson）。</li>\n<li>使用特性：<ol>\n<li>通过接口注解来描述一个 HTTP 请求，Url 参数和 Request 参数。</li>\n<li>通过定义返回值为 Observable&lt;&gt; 类型，它还能异步框架 RxJava 结合，实现异步请求网络进行加载数据。</li>\n<li>支持获取原生的 HTTP 请求数据（Raw）。</li>\n</ol>\n</li>\n<li>源码实现<ol>\n<li>Retrofit 实例化是通过 Builder 设计模式来实现的，可以配置 Retrofit 的 <strong>根 URL</strong>， <strong>数据转换器</strong>， <strong>进行 HTTP 网络请求的客户端</strong>。</li>\n<li>通过一个接口和接口方法上的注解来定义一个 HTTP 网络请求的 API 接口，这个接口包含 HTTP 请求的类型,参数等信息。</li>\n<li>在底层 creat() 方法，Retrofit 通过 JAVA 动态代理来获取 HTTP 请求接口的代理对象，代理对象将 HTTP 请求接口方法上面的注解解析成一个 ServiceMethod 类型的对象，再通过该对象构建 OKHttp 的请求。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">T <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class=\"line\">    Utils.validateServiceInterface(service);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validateEagerly) &#123;</span><br><span class=\"line\">      eagerlyValidateMethods(service);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> InvocationHandler() &#123;</span><br><span class=\"line\">          <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Platform platform = Platform.get();</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class=\"line\"><span class=\"function\">              <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> method.invoke(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ServiceMethod&lt;Object, Object&gt; serviceMethod =</span><br><span class=\"line\">                (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class=\"line\">            OkHttpCall&lt;Object&gt; okHttpCall = <span class=\"keyword\">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"Content-Provider\"><a href=\"#Content-Provider\" class=\"headerlink\" title=\"Content Provider\"></a>Content Provider</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/c70ae80cf64d\" target=\"_blank\" rel=\"noopener\">Content Provider 的一些理解</a><ol>\n<li>主要用于不同程序之间实现数据共享的功能，还可以通过 Content Provider 来实现跨进程之间的通信。在 Android 系统自带有很多 Content Provider（通信录，短信等）。</li>\n<li>在 Content Provider 的 回调方法中， onCreate() 方法是运行在主线程（UI线程）中，在 AMS 通过 ActivityThread 创建并回调 onCreate() 方法，不能再 onCreat() 方法中耗时操作。其他方法 query(), insert(), update(), delete() 等方法都是运行在应用 程序的 Binder 维护的线程池中，所以在其他方法耗时操作不会阻塞主线程。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"Dagger2\"><a href=\"#Dagger2\" class=\"headerlink\" title=\"Dagger2\"></a><a href=\"https://www.jianshu.com/p/24af4c102f62\" target=\"_blank\" rel=\"noopener\">Dagger2</a></h3><ul>\n<li>Dagger 2 是一个依赖注入框架，在编译期间自动生成代码，负责依赖对象的创建。</li>\n<li>使用 Dagger 2 的好处就是项目解耦。</li>\n</ul>\n<hr>\n"},{"title":"Android View","date":"2018-07-18T08:20:47.000Z","_content":"\n##### 自定义控件的核心\n\n- UI 界面的绘制（自定义 View，自绘 UI）\n\n- 业务逻辑的控制（View 控件的事件监听，数据绑定）\n\n##### 自定义控件实现\n\n- 继承系统控件：如：继承 TextView 添加一些事件监听\n\n- 组合系统控件：如：继承 LinearLayout，通过 LayoutInflater 动态加载布局文件到此 LinearLayout 中形成一个新控件。\n\n- 自定义绘制控件：如：继承 View ，通过重写 onDraw() 方法，在 Canvas 中绘制所需的 UI 界面\n\n  以上实现方式，即可单独使用，又可以联合使用。\n\n\n<!--more-->\n\n\n##### 介绍几个重要的类\n\n- LayoutInflater：一个用于动态加载布局的类。\n\n  获得 LayoutInflater 的方式\n\n  ```java\n  //通过 Context 获取，其实也是通过系统服务获取，只是 Android 封装了一层方便使用\n   LayoutInflater inflater = LayoutInflater.from(context);\n  // 通过 SystemService （系统服务） 获取\n  LayoutInflater inflater =(LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n  ```\n\n  如何使用 LayoutInflater 动态加载布局\n\n  ```java\n  // resource : XNL layout 布局的资源 id\n  // root ： 动态加载布局的父布局\n  // attachToRoot ： 是否要将加载的布局添加到 root（父容器）中\n  View view =  inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot);\n  ```\n\n  关于 attachToRoot 的说明\n\n| attachToRoot | root     | 作用                                   |\n|:------------:|:--------:|:------------------------------------:|\n| *            | null     | 不起作用                                 |\n| true         | not null | 将加载的布局指定父布局为（root） 根节点的属性都有效         |\n| false        | not null | 加载的布局没有指定父布局，根节点的属性失效。需要手动 addView（） |\n| 不填           | not null | 不填默认就是 attachToRoot = true           |\n\n- AttributeSet ：XML 资源文件中定义属性的集合。如：在资源文件中定义的 layout_height layout_width 等属性，可以在 java 代码中获取到属性对应的值，进而对控件的逻辑进行实现扩展。自定义 AttrbuteSet 与 获取 AttrbuteSet 值\n  - 在 res 资源文件夹的 values 下创建 attrs.xml 文件\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <resources>\n        <!--name：指定自定义属性所对应的自定义控件。NewCalendar 是自定义的控件-->\n        <declare-styleable name=\"NewCalendar\">\n            <!--name：自定义属性的名字-->\n            <!--format：自定义属性值的属性-->\n            <attr name=\"dateFormat\" format=\"string\"/>\n        </declare-styleable>\n    </resources>\n    ```\n\n  - 在布局 XML 文件中使用\n\n    ```xml\n    <xyz.awqingnian.study.view.NewCalendar\n        app:dateFormat=\"yyyy M\"\n        android:id=\"@+id/main_nc_calendar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n    </xyz.awqingnian.study.view.NewCalendar>\n    ```\n\n  - 在 java 代码中取出对应的自定义属性的值\n\n    ```java\n    // 获取对应控件的属性\n    TypedArray typedArray = getContext().obtainStyledAttributes(attrs,R.styleable.NewCalendar);\n    // R.styleable.NewCalendar_dateFormat 此值是 Android 通过 attrs.xml 拼接生成的值\n    String format = typedArray.getString(R.styleable.NewCalendar_dateFormat);\n    // 回收 typeArray ，让下一个调用者使用。在 typedArray.recycle() 后不能再使用 typedArray 的东西\n    typedArray.recycle();\n    ```\n\n##### 继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：\n\n- 继承 Android 已有的控件\n\n- 重写 onDraw() 方法\n\n- 给自定义控件设置数据，并在自定义控件的 onDraw() 方法中进行逻辑操作\n\n下面一个简单的例子：通过设置 isToday 的数据，在此自定义控件中的 onDraw() 方法内画个圆圈\n\n```java\n/**\n * 继承 Android 系统已有的控件（AppCompatTextView）\n */\npublic class CalendarDayTextView extends android.support.v7.widget.AppCompatTextView {\n    /**\n     * 自定义控件的数据部分（当然也可以通过 set 方法进行设置）\n     */\n    public boolean isToday = false;\n    private Paint mPaint = new Paint();\n\n    public CalendarDayTextView(Context context) {\n        super(context);\n        initControl();\n    }\n\n    public CalendarDayTextView(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        initControl();\n    }\n\n    public CalendarDayTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initControl();\n    }\n\n    private void initControl() {\n        mPaint.setStyle(Paint.Style.STROKE);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        // 自定义控件的数据逻辑操作部分\n        if (isToday) {\n            canvas.translate(getWidth() / 2, getHeight() / 2);\n            canvas.drawCircle(0, 0, getWidth() / 2, mPaint);\n        }\n    }\n}\n```\n\n##### 组合系统控件实现步骤：\n\n- 新建布局文件，并将需要组合的控件添加进去并进行排版操作。（calendar_view.xml）\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:layout_margin=\"16dp\"\n    android:orientation=\"vertical\">\n\n    <RelativeLayout\n        android:id=\"@+id/calendar_header\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"30dp\">\n        <!--详细设计省略-->\n    </RelativeLayout>\n\n    <LinearLayout\n        android:id=\"@+id/calender_ll_week_header\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:orientation=\"horizontal\">\n    <!--详细设计省略-->\n  </LinearLayout>\n\n    <GridView\n        android:id=\"@+id/calender_gv_date\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:gravity=\"center\"\n        android:numColumns=\"7\"></GridView>\n</LinearLayout>\n```\n\n- 创建 java 文件，继承 ViewGroup 的子类(如：LinearLayout ，RelativeLayout 等)，主要是在此布局中加载步骤一的布局文件，所以要用到 ViewGroup 的子类 装载子控件。(NewCalendar.java)\n\n```java\npublic class NewCalendar extends LinearLayout {\n    private ImageView mIvPrev;\n    private ImageView mIvNext;\n    private TextView mTvDate;\n    private GridView mGvDate;\n    private Calendar mCalendar = Calendar.getInstance();\n    private String displayFormat = \"yyyy M\";\n    public NewCalendarListener mNewCalendarListener;\n\n    public NewCalendar(Context context) {\n        super(context);\n    }\n\n    public NewCalendar(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        initControl(context, attrs);\n    }\n\n    public NewCalendar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initControl(context, attrs);\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n\n    }\n\n    private void initControl(Context context, AttributeSet attrs) {\n        binView(context);\n        bindViewEvent();\n        renderCalender();\n    }\n\n    /**\n     * 加载布局文件，并且 findViewById 找到布局文件中各控件\n     *\n     * @param context\n     */\n    private void binView(Context context) {\n          // 获取 LayoutInflater\n        LayoutInflater inflater = LayoutInflater.from(context);\n          // 通过 inflater 加载 R.layout.calendar_view 到 this（LinearLayout） 中\n        View view = inflater.inflate(R.layout.calendar_view, this);\n                // 通过 view 找到对应 res ID 的控件\n        mIvPrev = view.findViewById(R.id.calendar_iv_prev);\n        mIvNext = view.findViewById(R.id.calendar_iv_next);\n        mTvDate = view.findViewById(R.id.calendar_tv_date);\n        mGvDate = view.findViewById(R.id.calender_gv_date);\n    }\n\n    private void bindViewEvent() {\n        //······ 具体逻辑操作省略 ······\n    }\n\n    private void renderCalender() {\n        //······ 具体逻辑操作省略 ······\n    }\n\n    /**\n     * 日历控件的 Adapter\n     */\n    private class CalendarAdapter extends ArrayAdapter<Date> {\n\n        LayoutInflater mLayoutInflater;\n\n        public CalendarAdapter(@NonNull Context context, int resource, List<Date> dates) {\n            super(context, resource, dates);\n            mLayoutInflater = LayoutInflater.from(context);\n        }\n\n        @NonNull\n        @Override\n        public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {\n           //······ 具体逻辑操作省略 ······\n            return convertView;\n        }\n    }\n}\n```\n\n- 使用方法，直接在资源文件中像普通控件一样使用\n\n```xml\n<xyz.awqingnian.study.view.NewCalendar\n    android:id=\"@+id/main_nc_calendar\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n</xyz.awqingnian.study.view.NewCalendar>\n```\n\n#### 上面具体代码实现就是一个自定义日历控件。\n\n#### 具体代码可参考[GitHub](https://github.com/0HongTao0/CalendarView)\n\n![CalendarViewPicture](https://github.com/0HongTao0/CalendarView/blob/master/CalendarViewTest.jpg?raw=true)\n","source":"_posts/Android View.md","raw":"---\n\ntitle: Android View\n\ndate: 2018-07-18 16:20:47\n\n## tags:\n\n---\n\n##### 自定义控件的核心\n\n- UI 界面的绘制（自定义 View，自绘 UI）\n\n- 业务逻辑的控制（View 控件的事件监听，数据绑定）\n\n##### 自定义控件实现\n\n- 继承系统控件：如：继承 TextView 添加一些事件监听\n\n- 组合系统控件：如：继承 LinearLayout，通过 LayoutInflater 动态加载布局文件到此 LinearLayout 中形成一个新控件。\n\n- 自定义绘制控件：如：继承 View ，通过重写 onDraw() 方法，在 Canvas 中绘制所需的 UI 界面\n\n  以上实现方式，即可单独使用，又可以联合使用。\n\n\n<!--more-->\n\n\n##### 介绍几个重要的类\n\n- LayoutInflater：一个用于动态加载布局的类。\n\n  获得 LayoutInflater 的方式\n\n  ```java\n  //通过 Context 获取，其实也是通过系统服务获取，只是 Android 封装了一层方便使用\n   LayoutInflater inflater = LayoutInflater.from(context);\n  // 通过 SystemService （系统服务） 获取\n  LayoutInflater inflater =(LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n  ```\n\n  如何使用 LayoutInflater 动态加载布局\n\n  ```java\n  // resource : XNL layout 布局的资源 id\n  // root ： 动态加载布局的父布局\n  // attachToRoot ： 是否要将加载的布局添加到 root（父容器）中\n  View view =  inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot);\n  ```\n\n  关于 attachToRoot 的说明\n\n| attachToRoot | root     | 作用                                   |\n|:------------:|:--------:|:------------------------------------:|\n| *            | null     | 不起作用                                 |\n| true         | not null | 将加载的布局指定父布局为（root） 根节点的属性都有效         |\n| false        | not null | 加载的布局没有指定父布局，根节点的属性失效。需要手动 addView（） |\n| 不填           | not null | 不填默认就是 attachToRoot = true           |\n\n- AttributeSet ：XML 资源文件中定义属性的集合。如：在资源文件中定义的 layout_height layout_width 等属性，可以在 java 代码中获取到属性对应的值，进而对控件的逻辑进行实现扩展。自定义 AttrbuteSet 与 获取 AttrbuteSet 值\n  - 在 res 资源文件夹的 values 下创建 attrs.xml 文件\n\n    ```xml\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <resources>\n        <!--name：指定自定义属性所对应的自定义控件。NewCalendar 是自定义的控件-->\n        <declare-styleable name=\"NewCalendar\">\n            <!--name：自定义属性的名字-->\n            <!--format：自定义属性值的属性-->\n            <attr name=\"dateFormat\" format=\"string\"/>\n        </declare-styleable>\n    </resources>\n    ```\n\n  - 在布局 XML 文件中使用\n\n    ```xml\n    <xyz.awqingnian.study.view.NewCalendar\n        app:dateFormat=\"yyyy M\"\n        android:id=\"@+id/main_nc_calendar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n    </xyz.awqingnian.study.view.NewCalendar>\n    ```\n\n  - 在 java 代码中取出对应的自定义属性的值\n\n    ```java\n    // 获取对应控件的属性\n    TypedArray typedArray = getContext().obtainStyledAttributes(attrs,R.styleable.NewCalendar);\n    // R.styleable.NewCalendar_dateFormat 此值是 Android 通过 attrs.xml 拼接生成的值\n    String format = typedArray.getString(R.styleable.NewCalendar_dateFormat);\n    // 回收 typeArray ，让下一个调用者使用。在 typedArray.recycle() 后不能再使用 typedArray 的东西\n    typedArray.recycle();\n    ```\n\n##### 继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：\n\n- 继承 Android 已有的控件\n\n- 重写 onDraw() 方法\n\n- 给自定义控件设置数据，并在自定义控件的 onDraw() 方法中进行逻辑操作\n\n下面一个简单的例子：通过设置 isToday 的数据，在此自定义控件中的 onDraw() 方法内画个圆圈\n\n```java\n/**\n * 继承 Android 系统已有的控件（AppCompatTextView）\n */\npublic class CalendarDayTextView extends android.support.v7.widget.AppCompatTextView {\n    /**\n     * 自定义控件的数据部分（当然也可以通过 set 方法进行设置）\n     */\n    public boolean isToday = false;\n    private Paint mPaint = new Paint();\n\n    public CalendarDayTextView(Context context) {\n        super(context);\n        initControl();\n    }\n\n    public CalendarDayTextView(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        initControl();\n    }\n\n    public CalendarDayTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initControl();\n    }\n\n    private void initControl() {\n        mPaint.setStyle(Paint.Style.STROKE);\n        mPaint.setColor(Color.BLUE);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        // 自定义控件的数据逻辑操作部分\n        if (isToday) {\n            canvas.translate(getWidth() / 2, getHeight() / 2);\n            canvas.drawCircle(0, 0, getWidth() / 2, mPaint);\n        }\n    }\n}\n```\n\n##### 组合系统控件实现步骤：\n\n- 新建布局文件，并将需要组合的控件添加进去并进行排版操作。（calendar_view.xml）\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:layout_margin=\"16dp\"\n    android:orientation=\"vertical\">\n\n    <RelativeLayout\n        android:id=\"@+id/calendar_header\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"30dp\">\n        <!--详细设计省略-->\n    </RelativeLayout>\n\n    <LinearLayout\n        android:id=\"@+id/calender_ll_week_header\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:orientation=\"horizontal\">\n    <!--详细设计省略-->\n  </LinearLayout>\n\n    <GridView\n        android:id=\"@+id/calender_gv_date\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:gravity=\"center\"\n        android:numColumns=\"7\"></GridView>\n</LinearLayout>\n```\n\n- 创建 java 文件，继承 ViewGroup 的子类(如：LinearLayout ，RelativeLayout 等)，主要是在此布局中加载步骤一的布局文件，所以要用到 ViewGroup 的子类 装载子控件。(NewCalendar.java)\n\n```java\npublic class NewCalendar extends LinearLayout {\n    private ImageView mIvPrev;\n    private ImageView mIvNext;\n    private TextView mTvDate;\n    private GridView mGvDate;\n    private Calendar mCalendar = Calendar.getInstance();\n    private String displayFormat = \"yyyy M\";\n    public NewCalendarListener mNewCalendarListener;\n\n    public NewCalendar(Context context) {\n        super(context);\n    }\n\n    public NewCalendar(Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        initControl(context, attrs);\n    }\n\n    public NewCalendar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        initControl(context, attrs);\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n\n    }\n\n    private void initControl(Context context, AttributeSet attrs) {\n        binView(context);\n        bindViewEvent();\n        renderCalender();\n    }\n\n    /**\n     * 加载布局文件，并且 findViewById 找到布局文件中各控件\n     *\n     * @param context\n     */\n    private void binView(Context context) {\n          // 获取 LayoutInflater\n        LayoutInflater inflater = LayoutInflater.from(context);\n          // 通过 inflater 加载 R.layout.calendar_view 到 this（LinearLayout） 中\n        View view = inflater.inflate(R.layout.calendar_view, this);\n                // 通过 view 找到对应 res ID 的控件\n        mIvPrev = view.findViewById(R.id.calendar_iv_prev);\n        mIvNext = view.findViewById(R.id.calendar_iv_next);\n        mTvDate = view.findViewById(R.id.calendar_tv_date);\n        mGvDate = view.findViewById(R.id.calender_gv_date);\n    }\n\n    private void bindViewEvent() {\n        //······ 具体逻辑操作省略 ······\n    }\n\n    private void renderCalender() {\n        //······ 具体逻辑操作省略 ······\n    }\n\n    /**\n     * 日历控件的 Adapter\n     */\n    private class CalendarAdapter extends ArrayAdapter<Date> {\n\n        LayoutInflater mLayoutInflater;\n\n        public CalendarAdapter(@NonNull Context context, int resource, List<Date> dates) {\n            super(context, resource, dates);\n            mLayoutInflater = LayoutInflater.from(context);\n        }\n\n        @NonNull\n        @Override\n        public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {\n           //······ 具体逻辑操作省略 ······\n            return convertView;\n        }\n    }\n}\n```\n\n- 使用方法，直接在资源文件中像普通控件一样使用\n\n```xml\n<xyz.awqingnian.study.view.NewCalendar\n    android:id=\"@+id/main_nc_calendar\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n</xyz.awqingnian.study.view.NewCalendar>\n```\n\n#### 上面具体代码实现就是一个自定义日历控件。\n\n#### 具体代码可参考[GitHub](https://github.com/0HongTao0/CalendarView)\n\n![CalendarViewPicture](https://github.com/0HongTao0/CalendarView/blob/master/CalendarViewTest.jpg?raw=true)\n","slug":"Android View","published":1,"updated":"2018-07-18T12:09:12.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzbq0001s8o5ydlo0spb","content":"<h5 id=\"自定义控件的核心\"><a href=\"#自定义控件的核心\" class=\"headerlink\" title=\"自定义控件的核心\"></a>自定义控件的核心</h5><ul>\n<li><p>UI 界面的绘制（自定义 View，自绘 UI）</p>\n</li>\n<li><p>业务逻辑的控制（View 控件的事件监听，数据绑定）</p>\n</li>\n</ul>\n<h5 id=\"自定义控件实现\"><a href=\"#自定义控件实现\" class=\"headerlink\" title=\"自定义控件实现\"></a>自定义控件实现</h5><ul>\n<li><p>继承系统控件：如：继承 TextView 添加一些事件监听</p>\n</li>\n<li><p>组合系统控件：如：继承 LinearLayout，通过 LayoutInflater 动态加载布局文件到此 LinearLayout 中形成一个新控件。</p>\n</li>\n<li><p>自定义绘制控件：如：继承 View ，通过重写 onDraw() 方法，在 Canvas 中绘制所需的 UI 界面</p>\n<p>以上实现方式，即可单独使用，又可以联合使用。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h5 id=\"介绍几个重要的类\"><a href=\"#介绍几个重要的类\" class=\"headerlink\" title=\"介绍几个重要的类\"></a>介绍几个重要的类</h5><ul>\n<li><p>LayoutInflater：一个用于动态加载布局的类。</p>\n<p>获得 LayoutInflater 的方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过 Context 获取，其实也是通过系统服务获取，只是 Android 封装了一层方便使用</span></span><br><span class=\"line\"> LayoutInflater inflater = LayoutInflater.from(context);</span><br><span class=\"line\"><span class=\"comment\">// 通过 SystemService （系统服务） 获取</span></span><br><span class=\"line\">LayoutInflater inflater =(LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure>\n<p>如何使用 LayoutInflater 动态加载布局</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// resource : XNL layout 布局的资源 id</span></span><br><span class=\"line\"><span class=\"comment\">// root ： 动态加载布局的父布局</span></span><br><span class=\"line\"><span class=\"comment\">// attachToRoot ： 是否要将加载的布局添加到 root（父容器）中</span></span><br><span class=\"line\">View view =  inflate(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> resource, <span class=\"meta\">@Nullable</span> ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot);</span><br></pre></td></tr></table></figure>\n<p>关于 attachToRoot 的说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">attachToRoot</th>\n<th style=\"text-align:center\">root</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">*</td>\n<td style=\"text-align:center\">null</td>\n<td style=\"text-align:center\">不起作用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">not null</td>\n<td style=\"text-align:center\">将加载的布局指定父布局为（root） 根节点的属性都有效</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">not null</td>\n<td style=\"text-align:center\">加载的布局没有指定父布局，根节点的属性失效。需要手动 addView（）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">不填</td>\n<td style=\"text-align:center\">not null</td>\n<td style=\"text-align:center\">不填默认就是 attachToRoot = true</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>AttributeSet ：XML 资源文件中定义属性的集合。如：在资源文件中定义的 layout_height layout_width 等属性，可以在 java 代码中获取到属性对应的值，进而对控件的逻辑进行实现扩展。自定义 AttrbuteSet 与 获取 AttrbuteSet 值</p>\n<ul>\n<li><p>在 res 资源文件夹的 values 下创建 attrs.xml 文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--name：指定自定义属性所对应的自定义控件。NewCalendar 是自定义的控件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">declare-styleable</span> <span class=\"attr\">name</span>=<span class=\"string\">\"NewCalendar\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--name：自定义属性的名字--&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--format：自定义属性值的属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">attr</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dateFormat\"</span> <span class=\"attr\">format</span>=<span class=\"string\">\"string\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">declare-styleable</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在布局 XML 文件中使用</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xyz.awqingnian.study.view.NewCalendar</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:dateFormat</span>=<span class=\"string\">\"yyyy M\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/main_nc_calendar\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xyz.awqingnian.study.view.NewCalendar</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 java 代码中取出对应的自定义属性的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取对应控件的属性</span></span><br><span class=\"line\">TypedArray typedArray = getContext().obtainStyledAttributes(attrs,R.styleable.NewCalendar);</span><br><span class=\"line\"><span class=\"comment\">// R.styleable.NewCalendar_dateFormat 此值是 Android 通过 attrs.xml 拼接生成的值</span></span><br><span class=\"line\">String format = typedArray.getString(R.styleable.NewCalendar_dateFormat);</span><br><span class=\"line\"><span class=\"comment\">// 回收 typeArray ，让下一个调用者使用。在 typedArray.recycle() 后不能再使用 typedArray 的东西</span></span><br><span class=\"line\">typedArray.recycle();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：\"><a href=\"#继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：\" class=\"headerlink\" title=\"继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：\"></a>继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：</h5><ul>\n<li><p>继承 Android 已有的控件</p>\n</li>\n<li><p>重写 onDraw() 方法</p>\n</li>\n<li><p>给自定义控件设置数据，并在自定义控件的 onDraw() 方法中进行逻辑操作</p>\n</li>\n</ul>\n<p>下面一个简单的例子：通过设置 isToday 的数据，在此自定义控件中的 onDraw() 方法内画个圆圈</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 继承 Android 系统已有的控件（AppCompatTextView）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CalendarDayTextView</span> <span class=\"keyword\">extends</span> <span class=\"title\">android</span>.<span class=\"title\">support</span>.<span class=\"title\">v7</span>.<span class=\"title\">widget</span>.<span class=\"title\">AppCompatTextView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 自定义控件的数据部分（当然也可以通过 set 方法进行设置）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> isToday = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint = <span class=\"keyword\">new</span> Paint();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CalendarDayTextView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        initControl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CalendarDayTextView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        initControl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CalendarDayTextView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        initControl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initControl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mPaint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDraw(canvas);</span><br><span class=\"line\">        <span class=\"comment\">// 自定义控件的数据逻辑操作部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isToday) &#123;</span><br><span class=\"line\">            canvas.translate(getWidth() / <span class=\"number\">2</span>, getHeight() / <span class=\"number\">2</span>);</span><br><span class=\"line\">            canvas.drawCircle(<span class=\"number\">0</span>, <span class=\"number\">0</span>, getWidth() / <span class=\"number\">2</span>, mPaint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"组合系统控件实现步骤：\"><a href=\"#组合系统控件实现步骤：\" class=\"headerlink\" title=\"组合系统控件实现步骤：\"></a>组合系统控件实现步骤：</h5><ul>\n<li>新建布局文件，并将需要组合的控件添加进去并进行排版操作。（calendar_view.xml）</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_margin</span>=<span class=\"string\">\"16dp\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">RelativeLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/calendar_header\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"30dp\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--详细设计省略--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">RelativeLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/calender_ll_week_header\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"40dp\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"horizontal\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--详细设计省略--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">GridView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/calender_gv_date\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:gravity</span>=<span class=\"string\">\"center\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:numColumns</span>=<span class=\"string\">\"7\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">GridView</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建 java 文件，继承 ViewGroup 的子类(如：LinearLayout ，RelativeLayout 等)，主要是在此布局中加载步骤一的布局文件，所以要用到 ViewGroup 的子类 装载子控件。(NewCalendar.java)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewCalendar</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinearLayout</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ImageView mIvPrev;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ImageView mIvNext;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextView mTvDate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> GridView mGvDate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Calendar mCalendar = Calendar.getInstance();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String displayFormat = <span class=\"string\">\"yyyy M\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> NewCalendarListener mNewCalendarListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewCalendar</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewCalendar</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        initControl(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewCalendar</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        initControl(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initControl</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        binView(context);</span><br><span class=\"line\">        bindViewEvent();</span><br><span class=\"line\">        renderCalender();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加载布局文件，并且 findViewById 找到布局文件中各控件</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">binView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 获取 LayoutInflater</span></span><br><span class=\"line\">        LayoutInflater inflater = LayoutInflater.from(context);</span><br><span class=\"line\">          <span class=\"comment\">// 通过 inflater 加载 R.layout.calendar_view 到 this（LinearLayout） 中</span></span><br><span class=\"line\">        View view = inflater.inflate(R.layout.calendar_view, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 通过 view 找到对应 res ID 的控件</span></span><br><span class=\"line\">        mIvPrev = view.findViewById(R.id.calendar_iv_prev);</span><br><span class=\"line\">        mIvNext = view.findViewById(R.id.calendar_iv_next);</span><br><span class=\"line\">        mTvDate = view.findViewById(R.id.calendar_tv_date);</span><br><span class=\"line\">        mGvDate = view.findViewById(R.id.calender_gv_date);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bindViewEvent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//······ 具体逻辑操作省略 ······</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">renderCalender</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//······ 具体逻辑操作省略 ······</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 日历控件的 Adapter</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CalendarAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">ArrayAdapter</span>&lt;<span class=\"title\">Date</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        LayoutInflater mLayoutInflater;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CalendarAdapter</span><span class=\"params\">(@NonNull Context context, <span class=\"keyword\">int</span> resource, List&lt;Date&gt; dates)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(context, resource, dates);</span><br><span class=\"line\">            mLayoutInflater = LayoutInflater.from(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> position, @Nullable View convertView, @NonNull ViewGroup parent)</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"comment\">//······ 具体逻辑操作省略 ······</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> convertView;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用方法，直接在资源文件中像普通控件一样使用</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xyz.awqingnian.study.view.NewCalendar</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/main_nc_calendar\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xyz.awqingnian.study.view.NewCalendar</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"上面具体代码实现就是一个自定义日历控件。\"><a href=\"#上面具体代码实现就是一个自定义日历控件。\" class=\"headerlink\" title=\"上面具体代码实现就是一个自定义日历控件。\"></a>上面具体代码实现就是一个自定义日历控件。</h4><h4 id=\"具体代码可参考GitHub\"><a href=\"#具体代码可参考GitHub\" class=\"headerlink\" title=\"具体代码可参考GitHub\"></a>具体代码可参考<a href=\"https://github.com/0HongTao0/CalendarView\" target=\"_blank\" rel=\"noopener\">GitHub</a></h4><p><img src=\"https://github.com/0HongTao0/CalendarView/blob/master/CalendarViewTest.jpg?raw=true\" alt=\"CalendarViewPicture\"></p>\n","site":{"data":{}},"excerpt":"<h5 id=\"自定义控件的核心\"><a href=\"#自定义控件的核心\" class=\"headerlink\" title=\"自定义控件的核心\"></a>自定义控件的核心</h5><ul>\n<li><p>UI 界面的绘制（自定义 View，自绘 UI）</p>\n</li>\n<li><p>业务逻辑的控制（View 控件的事件监听，数据绑定）</p>\n</li>\n</ul>\n<h5 id=\"自定义控件实现\"><a href=\"#自定义控件实现\" class=\"headerlink\" title=\"自定义控件实现\"></a>自定义控件实现</h5><ul>\n<li><p>继承系统控件：如：继承 TextView 添加一些事件监听</p>\n</li>\n<li><p>组合系统控件：如：继承 LinearLayout，通过 LayoutInflater 动态加载布局文件到此 LinearLayout 中形成一个新控件。</p>\n</li>\n<li><p>自定义绘制控件：如：继承 View ，通过重写 onDraw() 方法，在 Canvas 中绘制所需的 UI 界面</p>\n<p>以上实现方式，即可单独使用，又可以联合使用。</p>\n</li>\n</ul>","more":"<h5 id=\"介绍几个重要的类\"><a href=\"#介绍几个重要的类\" class=\"headerlink\" title=\"介绍几个重要的类\"></a>介绍几个重要的类</h5><ul>\n<li><p>LayoutInflater：一个用于动态加载布局的类。</p>\n<p>获得 LayoutInflater 的方式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过 Context 获取，其实也是通过系统服务获取，只是 Android 封装了一层方便使用</span></span><br><span class=\"line\"> LayoutInflater inflater = LayoutInflater.from(context);</span><br><span class=\"line\"><span class=\"comment\">// 通过 SystemService （系统服务） 获取</span></span><br><span class=\"line\">LayoutInflater inflater =(LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure>\n<p>如何使用 LayoutInflater 动态加载布局</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// resource : XNL layout 布局的资源 id</span></span><br><span class=\"line\"><span class=\"comment\">// root ： 动态加载布局的父布局</span></span><br><span class=\"line\"><span class=\"comment\">// attachToRoot ： 是否要将加载的布局添加到 root（父容器）中</span></span><br><span class=\"line\">View view =  inflate(<span class=\"meta\">@LayoutRes</span> <span class=\"keyword\">int</span> resource, <span class=\"meta\">@Nullable</span> ViewGroup root, <span class=\"keyword\">boolean</span> attachToRoot);</span><br></pre></td></tr></table></figure>\n<p>关于 attachToRoot 的说明</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">attachToRoot</th>\n<th style=\"text-align:center\">root</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">*</td>\n<td style=\"text-align:center\">null</td>\n<td style=\"text-align:center\">不起作用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">not null</td>\n<td style=\"text-align:center\">将加载的布局指定父布局为（root） 根节点的属性都有效</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">not null</td>\n<td style=\"text-align:center\">加载的布局没有指定父布局，根节点的属性失效。需要手动 addView（）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">不填</td>\n<td style=\"text-align:center\">not null</td>\n<td style=\"text-align:center\">不填默认就是 attachToRoot = true</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p>AttributeSet ：XML 资源文件中定义属性的集合。如：在资源文件中定义的 layout_height layout_width 等属性，可以在 java 代码中获取到属性对应的值，进而对控件的逻辑进行实现扩展。自定义 AttrbuteSet 与 获取 AttrbuteSet 值</p>\n<ul>\n<li><p>在 res 资源文件夹的 values 下创建 attrs.xml 文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">resources</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--name：指定自定义属性所对应的自定义控件。NewCalendar 是自定义的控件--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">declare-styleable</span> <span class=\"attr\">name</span>=<span class=\"string\">\"NewCalendar\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--name：自定义属性的名字--&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--format：自定义属性值的属性--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">attr</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dateFormat\"</span> <span class=\"attr\">format</span>=<span class=\"string\">\"string\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">declare-styleable</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在布局 XML 文件中使用</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xyz.awqingnian.study.view.NewCalendar</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">app:dateFormat</span>=<span class=\"string\">\"yyyy M\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/main_nc_calendar\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xyz.awqingnian.study.view.NewCalendar</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在 java 代码中取出对应的自定义属性的值</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取对应控件的属性</span></span><br><span class=\"line\">TypedArray typedArray = getContext().obtainStyledAttributes(attrs,R.styleable.NewCalendar);</span><br><span class=\"line\"><span class=\"comment\">// R.styleable.NewCalendar_dateFormat 此值是 Android 通过 attrs.xml 拼接生成的值</span></span><br><span class=\"line\">String format = typedArray.getString(R.styleable.NewCalendar_dateFormat);</span><br><span class=\"line\"><span class=\"comment\">// 回收 typeArray ，让下一个调用者使用。在 typedArray.recycle() 后不能再使用 typedArray 的东西</span></span><br><span class=\"line\">typedArray.recycle();</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：\"><a href=\"#继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：\" class=\"headerlink\" title=\"继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：\"></a>继承系统控件与自定义绘制控件实现步骤（两者通常都是一起实现的）：</h5><ul>\n<li><p>继承 Android 已有的控件</p>\n</li>\n<li><p>重写 onDraw() 方法</p>\n</li>\n<li><p>给自定义控件设置数据，并在自定义控件的 onDraw() 方法中进行逻辑操作</p>\n</li>\n</ul>\n<p>下面一个简单的例子：通过设置 isToday 的数据，在此自定义控件中的 onDraw() 方法内画个圆圈</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 继承 Android 系统已有的控件（AppCompatTextView）</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CalendarDayTextView</span> <span class=\"keyword\">extends</span> <span class=\"title\">android</span>.<span class=\"title\">support</span>.<span class=\"title\">v7</span>.<span class=\"title\">widget</span>.<span class=\"title\">AppCompatTextView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 自定义控件的数据部分（当然也可以通过 set 方法进行设置）</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> isToday = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Paint mPaint = <span class=\"keyword\">new</span> Paint();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CalendarDayTextView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">        initControl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CalendarDayTextView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        initControl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CalendarDayTextView</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        initControl();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initControl</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mPaint.setStyle(Paint.Style.STROKE);</span><br><span class=\"line\">        mPaint.setColor(Color.BLUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDraw</span><span class=\"params\">(Canvas canvas)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.onDraw(canvas);</span><br><span class=\"line\">        <span class=\"comment\">// 自定义控件的数据逻辑操作部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isToday) &#123;</span><br><span class=\"line\">            canvas.translate(getWidth() / <span class=\"number\">2</span>, getHeight() / <span class=\"number\">2</span>);</span><br><span class=\"line\">            canvas.drawCircle(<span class=\"number\">0</span>, <span class=\"number\">0</span>, getWidth() / <span class=\"number\">2</span>, mPaint);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"组合系统控件实现步骤：\"><a href=\"#组合系统控件实现步骤：\" class=\"headerlink\" title=\"组合系统控件实现步骤：\"></a>组合系统控件实现步骤：</h5><ul>\n<li>新建布局文件，并将需要组合的控件添加进去并进行排版操作。（calendar_view.xml）</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:android</span>=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_margin</span>=<span class=\"string\">\"16dp\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"vertical\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">RelativeLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/calendar_header\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"30dp\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--详细设计省略--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">RelativeLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">LinearLayout</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/calender_ll_week_header\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"40dp\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:orientation</span>=<span class=\"string\">\"horizontal\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--详细设计省略--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">GridView</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/calender_gv_date\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:gravity</span>=<span class=\"string\">\"center\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">android:numColumns</span>=<span class=\"string\">\"7\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">GridView</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>创建 java 文件，继承 ViewGroup 的子类(如：LinearLayout ，RelativeLayout 等)，主要是在此布局中加载步骤一的布局文件，所以要用到 ViewGroup 的子类 装载子控件。(NewCalendar.java)</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewCalendar</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinearLayout</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ImageView mIvPrev;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ImageView mIvNext;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextView mTvDate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> GridView mGvDate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Calendar mCalendar = Calendar.getInstance();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String displayFormat = <span class=\"string\">\"yyyy M\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> NewCalendarListener mNewCalendarListener;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewCalendar</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewCalendar</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs);</span><br><span class=\"line\">        initControl(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewCalendar</span><span class=\"params\">(Context context, @Nullable AttributeSet attrs, <span class=\"keyword\">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(context, attrs, defStyleAttr);</span><br><span class=\"line\">        initControl(context, attrs);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onLayout</span><span class=\"params\">(<span class=\"keyword\">boolean</span> changed, <span class=\"keyword\">int</span> l, <span class=\"keyword\">int</span> t, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initControl</span><span class=\"params\">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class=\"line\">        binView(context);</span><br><span class=\"line\">        bindViewEvent();</span><br><span class=\"line\">        renderCalender();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 加载布局文件，并且 findViewById 找到布局文件中各控件</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> context</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">binView</span><span class=\"params\">(Context context)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 获取 LayoutInflater</span></span><br><span class=\"line\">        LayoutInflater inflater = LayoutInflater.from(context);</span><br><span class=\"line\">          <span class=\"comment\">// 通过 inflater 加载 R.layout.calendar_view 到 this（LinearLayout） 中</span></span><br><span class=\"line\">        View view = inflater.inflate(R.layout.calendar_view, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 通过 view 找到对应 res ID 的控件</span></span><br><span class=\"line\">        mIvPrev = view.findViewById(R.id.calendar_iv_prev);</span><br><span class=\"line\">        mIvNext = view.findViewById(R.id.calendar_iv_next);</span><br><span class=\"line\">        mTvDate = view.findViewById(R.id.calendar_tv_date);</span><br><span class=\"line\">        mGvDate = view.findViewById(R.id.calender_gv_date);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">bindViewEvent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//······ 具体逻辑操作省略 ······</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">renderCalender</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//······ 具体逻辑操作省略 ······</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 日历控件的 Adapter</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CalendarAdapter</span> <span class=\"keyword\">extends</span> <span class=\"title\">ArrayAdapter</span>&lt;<span class=\"title\">Date</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        LayoutInflater mLayoutInflater;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CalendarAdapter</span><span class=\"params\">(@NonNull Context context, <span class=\"keyword\">int</span> resource, List&lt;Date&gt; dates)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">super</span>(context, resource, dates);</span><br><span class=\"line\">            mLayoutInflater = LayoutInflater.from(context);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@NonNull</span></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> View <span class=\"title\">getView</span><span class=\"params\">(<span class=\"keyword\">int</span> position, @Nullable View convertView, @NonNull ViewGroup parent)</span> </span>&#123;</span><br><span class=\"line\">           <span class=\"comment\">//······ 具体逻辑操作省略 ······</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> convertView;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用方法，直接在资源文件中像普通控件一样使用</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">xyz.awqingnian.study.view.NewCalendar</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:id</span>=<span class=\"string\">\"@+id/main_nc_calendar\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_width</span>=<span class=\"string\">\"match_parent\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">android:layout_height</span>=<span class=\"string\">\"match_parent\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">xyz.awqingnian.study.view.NewCalendar</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"上面具体代码实现就是一个自定义日历控件。\"><a href=\"#上面具体代码实现就是一个自定义日历控件。\" class=\"headerlink\" title=\"上面具体代码实现就是一个自定义日历控件。\"></a>上面具体代码实现就是一个自定义日历控件。</h4><h4 id=\"具体代码可参考GitHub\"><a href=\"#具体代码可参考GitHub\" class=\"headerlink\" title=\"具体代码可参考GitHub\"></a>具体代码可参考<a href=\"https://github.com/0HongTao0/CalendarView\" target=\"_blank\" rel=\"noopener\">GitHub</a></h4><p><img src=\"https://github.com/0HongTao0/CalendarView/blob/master/CalendarViewTest.jpg?raw=true\" alt=\"CalendarViewPicture\"></p>"},{"title":"Android 屏幕适配","date":"2018-07-06T04:14:52.000Z","_content":"\n- 屏幕适配\n\n  1. 屏幕尺寸（inch）：屏幕的对角线（5寸，6寸）\n\n  2. 分辨率（px）：1920*1080 （像素点）\n\n  3. 屏幕密度（dpi）：一英寸长度中可显示输出的像素个数\n\n  4. 三者关系 \n  ![三者关系](https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOgM19n6iawpWQRCfcibxicoBYG51prmqwNCLAVALyK5Rhv4uSbrU5FQKQL6bZI3iaibTJaz3NMpEQ8zWAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n<!--more-->\n- 单位之间的转换\n\n  1. px = density * dp\n\n  2. density = dpi / 160\n\n  3. px = dp * (dpi / 160)\n\n- [Android 官方给出的屏幕适配](https://developer.android.com/guide/practices/screens_support)\n\n  1. wrap_content 和 match_parent\n\n  2. 按照屏幕尺寸加载不同的资源文件\n\n     _ldpi_（低）~120dpi\n\n     mdpi_（中）~160dpi\n\n     _hdpi_（高）~240dpi\n\n     _xhdpi_（超高）~320dpi\n\n     _xxhdpi_（超超高）~480dpi\n\n     _xxxhdpi_（超超超高）~640dpi\n\n- [其他方案]([https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA](https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA)\n\n  1. 修改源码 density\n","source":"_posts/Android 屏幕适配.md","raw":"---\ntitle: Android 屏幕适配\ndate: 2018-07-06 12:14:52\ntags:\n---\n\n- 屏幕适配\n\n  1. 屏幕尺寸（inch）：屏幕的对角线（5寸，6寸）\n\n  2. 分辨率（px）：1920*1080 （像素点）\n\n  3. 屏幕密度（dpi）：一英寸长度中可显示输出的像素个数\n\n  4. 三者关系 \n  ![三者关系](https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOgM19n6iawpWQRCfcibxicoBYG51prmqwNCLAVALyK5Rhv4uSbrU5FQKQL6bZI3iaibTJaz3NMpEQ8zWAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)\n<!--more-->\n- 单位之间的转换\n\n  1. px = density * dp\n\n  2. density = dpi / 160\n\n  3. px = dp * (dpi / 160)\n\n- [Android 官方给出的屏幕适配](https://developer.android.com/guide/practices/screens_support)\n\n  1. wrap_content 和 match_parent\n\n  2. 按照屏幕尺寸加载不同的资源文件\n\n     _ldpi_（低）~120dpi\n\n     mdpi_（中）~160dpi\n\n     _hdpi_（高）~240dpi\n\n     _xhdpi_（超高）~320dpi\n\n     _xxhdpi_（超超高）~480dpi\n\n     _xxxhdpi_（超超超高）~640dpi\n\n- [其他方案]([https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA](https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA)\n\n  1. 修改源码 density\n","slug":"Android 屏幕适配","published":1,"updated":"2018-07-06T09:15:08.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzbx0002s8o5hlb7k6m7","content":"<ul>\n<li><p>屏幕适配</p>\n<ol>\n<li><p>屏幕尺寸（inch）：屏幕的对角线（5寸，6寸）</p>\n</li>\n<li><p>分辨率（px）：1920*1080 （像素点）</p>\n</li>\n<li><p>屏幕密度（dpi）：一英寸长度中可显示输出的像素个数</p>\n</li>\n<li><p>三者关系<br><img src=\"https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOgM19n6iawpWQRCfcibxicoBYG51prmqwNCLAVALyK5Rhv4uSbrU5FQKQL6bZI3iaibTJaz3NMpEQ8zWAA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"三者关系\"></p>\n<a id=\"more\"></a></li>\n</ol>\n</li>\n<li><p>单位之间的转换</p>\n<ol>\n<li><p>px = density * dp</p>\n</li>\n<li><p>density = dpi / 160</p>\n</li>\n<li><p>px = dp * (dpi / 160)</p>\n</li>\n</ol>\n</li>\n<li><p><a href=\"https://developer.android.com/guide/practices/screens_support\" target=\"_blank\" rel=\"noopener\">Android 官方给出的屏幕适配</a></p>\n<ol>\n<li><p>wrap_content 和 match_parent</p>\n</li>\n<li><p>按照屏幕尺寸加载不同的资源文件</p>\n<p><em>ldpi</em>（低）~120dpi</p>\n<p>mdpi_（中）~160dpi</p>\n<p><em>hdpi</em>（高）~240dpi</p>\n<p><em>xhdpi</em>（超高）~320dpi</p>\n<p><em>xxhdpi</em>（超超高）~480dpi</p>\n<p><em>xxxhdpi</em>（超超超高）~640dpi</p>\n</li>\n</ol>\n</li>\n<li><p><a href=\"[https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA](https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA\">其他方案</a></p>\n<ol>\n<li>修改源码 density</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>屏幕适配</p>\n<ol>\n<li><p>屏幕尺寸（inch）：屏幕的对角线（5寸，6寸）</p>\n</li>\n<li><p>分辨率（px）：1920*1080 （像素点）</p>\n</li>\n<li><p>屏幕密度（dpi）：一英寸长度中可显示输出的像素个数</p>\n</li>\n<li><p>三者关系<br><img src=\"https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOgM19n6iawpWQRCfcibxicoBYG51prmqwNCLAVALyK5Rhv4uSbrU5FQKQL6bZI3iaibTJaz3NMpEQ8zWAA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"三者关系\"></p>","more":"</li>\n</ol>\n</li>\n<li><p>单位之间的转换</p>\n<ol>\n<li><p>px = density * dp</p>\n</li>\n<li><p>density = dpi / 160</p>\n</li>\n<li><p>px = dp * (dpi / 160)</p>\n</li>\n</ol>\n</li>\n<li><p><a href=\"https://developer.android.com/guide/practices/screens_support\" target=\"_blank\" rel=\"noopener\">Android 官方给出的屏幕适配</a></p>\n<ol>\n<li><p>wrap_content 和 match_parent</p>\n</li>\n<li><p>按照屏幕尺寸加载不同的资源文件</p>\n<p><em>ldpi</em>（低）~120dpi</p>\n<p>mdpi_（中）~160dpi</p>\n<p><em>hdpi</em>（高）~240dpi</p>\n<p><em>xhdpi</em>（超高）~320dpi</p>\n<p><em>xxhdpi</em>（超超高）~480dpi</p>\n<p><em>xxxhdpi</em>（超超超高）~640dpi</p>\n</li>\n</ol>\n</li>\n<li><p><a href=\"[https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA](https://mp.weixin.qq.com/s/d9QCoBP6kV9VSWvVldVVwA\">其他方案</a></p>\n<ol>\n<li>修改源码 density</li>\n</ol>\n</li>\n</ul>"},{"title":"Android 构建知识","date":"2018-07-21T01:16:55.000Z","_content":"\n##### 简单介绍一下 [Gradle Build Tool](https://gradle.org/)\n\n- 可以帮助团队更快地构建，自动化和交付更好的软件。\n\n- 使用一种基于 Groovy 语言来**声明项目设置**。\n\n- 支持多语言构建：Java,  C++, Python, Android , IOS 等等。\n\n- Gradle 的优势：自动处理 dependencies 关系（Maven 概念），自动处理部署问题（Ant 概念），可以使用条件判断写法（Groovy语言）\n\n<!--more-->\n\n##### Android 构建流程步骤\n\n- 编译器（Compilers）将源代码（SourceCode）转换成 DEX 文件（Dalvik Executable，Dalvik 是运行在 Android 上面的虚拟机，.dex 文件包括运行在 Android 上的字节码），并且将其他内容转换成已编译资源。\n\n- APK 打包器将 DEX 文件和已编译文件合并成单个 APK，不过要先进行对 APK 进行签名。\n\n- APK 打包器使用调试（Debug）或发布（Release）密钥来对 APK 进行签名处理。（1）构建 Debug 版本，则 Android Studio 自动生成 Debug 的签名密钥。（2）构建 Release 版本则需要用户自己生成签名密钥。\n\n- 在生成最终 APK 之前，打包器使用 zipalign 工具进行对 APK 优化。（减少运行内存占用，zipalign 是一个进行对未压缩数据对齐工具）\n\n![Android 构建流程](https://github.com/0HongTao0/Blog/blob/master/pic/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.png?raw=true)\n\n##### Android 构建的配置文件\n\n首先我们新建的 Android 项目，通常 Android Studio 帮我们自动创建了几个 gradle 文件\n\n![AndroidStudio 新建项目](https://github.com/0HongTao0/Blog/blob/master/pic/AndroidStudio%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.jpg?raw=true)\n\n- settings.gradle 文件（位于项目根目录），此 gradle 文件用于指示 Gradle 在构建应用时包含哪些模块（Module）在内。\n\n  如下面代码包含 app 本身模块以及 alpha 模块\n\n  ```groovy\n  include ':app'\n  include ':alpha'\n  ```\n\n- 顶级构建文件 build.gradle（位于项目根目录），此 gradle 文件适用于项目所有模块的构建配置\n\n  ```groovy\n  buildscript {\n    // 下载远程依赖的仓库地址（远程仓库地址有JCenter, Maven Central, and Ivy，当然也可以用国内的某些镜像）\n      repositories {\n          google()\n          jcenter()\n      }\n    // 指定需要用于构建项目的 Gradle 版本信息\n      dependencies {\n          classpath 'com.android.tools.build:gradle:3.1.1'\n      }\n  }\n  // 配置项目中所有模块使用的远程仓库地址和依赖\n  allprojects {\n      repositories {\n          google()\n          jcenter()\n      }\n  }\n  ```\n\n- 模块级构建文件 build.gradle （位于模块的根目录下），此 gradle 文件用于配置所在模块的构建设置。\n\n  ```groovy\n  // 构建的插件                    \n  apply plugin: 'com.android.application'\n  \n  //配置 android 应用程序的构建环境和使用环境\n  android {\n        // 指定使用哪个版本的 SDK 编译 app\n      compileSdkVersion 27\n      defaultConfig {\n            //通常使用包名来定义 applicationId ，由main / AndroidManifest.xml文件中的package属性定义。\n          applicationId \"xyz.awqingnian.touchpull\"\n            // Android 设备要运行此 app 最小的 SDK 版本\n          minSdkVersion 21\n            // 指定用于测试此 app 的 SDK 版本\n          targetSdkVersion 27\n            // app 的版本号\n          versionCode 1\n            // app 的版本名字\n          versionName \"1.0\"\n          testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n      }\n      buildTypes {\n            //发布版本的配置信息\n          release {\n              minifyEnabled false //是否启用代码压缩（否）\n              proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n          }\n      }\n  }\n  // 模块中用到的第三方依赖\n  dependencies {\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n      implementation 'com.android.support:appcompat-v7:27.0.2'\n      implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n      testImplementation 'junit:junit:4.12'\n      androidTestImplementation 'com.android.support.test:runner:1.0.1'\n      androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n  }\n  ```\n\n\n\n| dependencies 配置 | 引用生命期                                                                                                                                 |\n| --------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| implementation  | 依赖项在编译时对模块可用，并且仅在运行时对模块的消费者可用。 对于大型多项目构建，使用`implementation`而不是`api`/`compile`可以**显著缩短构建时间**，因为它可以减少构建系统需要重新编译的项目量。 大多数应用和测试模块都应使用此配置。 |\n| api             | 依赖项在编译时对模块可用，并且在编译时和运行时还对模块的消费者可用。 此配置的行为类似于`compile`（现在已弃用），一般情况下，您应当仅在库模块中使用它。 应用模块应使用`implementation`，除非您想要将其 API 公开给单独的测试模块。      |\n| compileOnly     | 依赖项仅在编译时对模块可用，并且在编译或运行时对其消费者不可用。 此配置的行为类似于`provided`（现在已弃用）。                                                                          |\n| runtimeOnly     | 依赖项仅在运行时对模块及其消费者可用。 此配置的行为类似于`apk`（现在已弃用）。                                                                                            |\n\n\n\n##### Gradle 属性文件\n\n- gradle.properties ： 配置项目范围 Gradle 设置，例如 Gradle 后台进程的最大堆大小。\n\n- local.properties ： 为构建系统配置本地环境属性，例如 SDK 安装路径。由于该文件的内容由 Android Studio 自动生成并且专用于本地开发者环境，因此您不应手动修改该文件，或将其纳入您的版本控制系统。\n","source":"_posts/Android 构建知识.md","raw":"---\ntitle: Android 构建知识\n\ndate: 2018-07-21 09:16:55\n\ntags:\n\n---\n\n##### 简单介绍一下 [Gradle Build Tool](https://gradle.org/)\n\n- 可以帮助团队更快地构建，自动化和交付更好的软件。\n\n- 使用一种基于 Groovy 语言来**声明项目设置**。\n\n- 支持多语言构建：Java,  C++, Python, Android , IOS 等等。\n\n- Gradle 的优势：自动处理 dependencies 关系（Maven 概念），自动处理部署问题（Ant 概念），可以使用条件判断写法（Groovy语言）\n\n<!--more-->\n\n##### Android 构建流程步骤\n\n- 编译器（Compilers）将源代码（SourceCode）转换成 DEX 文件（Dalvik Executable，Dalvik 是运行在 Android 上面的虚拟机，.dex 文件包括运行在 Android 上的字节码），并且将其他内容转换成已编译资源。\n\n- APK 打包器将 DEX 文件和已编译文件合并成单个 APK，不过要先进行对 APK 进行签名。\n\n- APK 打包器使用调试（Debug）或发布（Release）密钥来对 APK 进行签名处理。（1）构建 Debug 版本，则 Android Studio 自动生成 Debug 的签名密钥。（2）构建 Release 版本则需要用户自己生成签名密钥。\n\n- 在生成最终 APK 之前，打包器使用 zipalign 工具进行对 APK 优化。（减少运行内存占用，zipalign 是一个进行对未压缩数据对齐工具）\n\n![Android 构建流程](https://github.com/0HongTao0/Blog/blob/master/pic/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.png?raw=true)\n\n##### Android 构建的配置文件\n\n首先我们新建的 Android 项目，通常 Android Studio 帮我们自动创建了几个 gradle 文件\n\n![AndroidStudio 新建项目](https://github.com/0HongTao0/Blog/blob/master/pic/AndroidStudio%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.jpg?raw=true)\n\n- settings.gradle 文件（位于项目根目录），此 gradle 文件用于指示 Gradle 在构建应用时包含哪些模块（Module）在内。\n\n  如下面代码包含 app 本身模块以及 alpha 模块\n\n  ```groovy\n  include ':app'\n  include ':alpha'\n  ```\n\n- 顶级构建文件 build.gradle（位于项目根目录），此 gradle 文件适用于项目所有模块的构建配置\n\n  ```groovy\n  buildscript {\n    // 下载远程依赖的仓库地址（远程仓库地址有JCenter, Maven Central, and Ivy，当然也可以用国内的某些镜像）\n      repositories {\n          google()\n          jcenter()\n      }\n    // 指定需要用于构建项目的 Gradle 版本信息\n      dependencies {\n          classpath 'com.android.tools.build:gradle:3.1.1'\n      }\n  }\n  // 配置项目中所有模块使用的远程仓库地址和依赖\n  allprojects {\n      repositories {\n          google()\n          jcenter()\n      }\n  }\n  ```\n\n- 模块级构建文件 build.gradle （位于模块的根目录下），此 gradle 文件用于配置所在模块的构建设置。\n\n  ```groovy\n  // 构建的插件                    \n  apply plugin: 'com.android.application'\n  \n  //配置 android 应用程序的构建环境和使用环境\n  android {\n        // 指定使用哪个版本的 SDK 编译 app\n      compileSdkVersion 27\n      defaultConfig {\n            //通常使用包名来定义 applicationId ，由main / AndroidManifest.xml文件中的package属性定义。\n          applicationId \"xyz.awqingnian.touchpull\"\n            // Android 设备要运行此 app 最小的 SDK 版本\n          minSdkVersion 21\n            // 指定用于测试此 app 的 SDK 版本\n          targetSdkVersion 27\n            // app 的版本号\n          versionCode 1\n            // app 的版本名字\n          versionName \"1.0\"\n          testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n      }\n      buildTypes {\n            //发布版本的配置信息\n          release {\n              minifyEnabled false //是否启用代码压缩（否）\n              proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n          }\n      }\n  }\n  // 模块中用到的第三方依赖\n  dependencies {\n      implementation fileTree(dir: 'libs', include: ['*.jar'])\n      implementation 'com.android.support:appcompat-v7:27.0.2'\n      implementation 'com.android.support.constraint:constraint-layout:1.0.2'\n      testImplementation 'junit:junit:4.12'\n      androidTestImplementation 'com.android.support.test:runner:1.0.1'\n      androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'\n  }\n  ```\n\n\n\n| dependencies 配置 | 引用生命期                                                                                                                                 |\n| --------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| implementation  | 依赖项在编译时对模块可用，并且仅在运行时对模块的消费者可用。 对于大型多项目构建，使用`implementation`而不是`api`/`compile`可以**显著缩短构建时间**，因为它可以减少构建系统需要重新编译的项目量。 大多数应用和测试模块都应使用此配置。 |\n| api             | 依赖项在编译时对模块可用，并且在编译时和运行时还对模块的消费者可用。 此配置的行为类似于`compile`（现在已弃用），一般情况下，您应当仅在库模块中使用它。 应用模块应使用`implementation`，除非您想要将其 API 公开给单独的测试模块。      |\n| compileOnly     | 依赖项仅在编译时对模块可用，并且在编译或运行时对其消费者不可用。 此配置的行为类似于`provided`（现在已弃用）。                                                                          |\n| runtimeOnly     | 依赖项仅在运行时对模块及其消费者可用。 此配置的行为类似于`apk`（现在已弃用）。                                                                                            |\n\n\n\n##### Gradle 属性文件\n\n- gradle.properties ： 配置项目范围 Gradle 设置，例如 Gradle 后台进程的最大堆大小。\n\n- local.properties ： 为构建系统配置本地环境属性，例如 SDK 安装路径。由于该文件的内容由 Android Studio 自动生成并且专用于本地开发者环境，因此您不应手动修改该文件，或将其纳入您的版本控制系统。\n","slug":"Android 构建知识","published":1,"updated":"2018-07-23T02:36:15.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzc00003s8o53p17wrdp","content":"<h5 id=\"简单介绍一下-Gradle-Build-Tool\"><a href=\"#简单介绍一下-Gradle-Build-Tool\" class=\"headerlink\" title=\"简单介绍一下 Gradle Build Tool\"></a>简单介绍一下 <a href=\"https://gradle.org/\" target=\"_blank\" rel=\"noopener\">Gradle Build Tool</a></h5><ul>\n<li><p>可以帮助团队更快地构建，自动化和交付更好的软件。</p>\n</li>\n<li><p>使用一种基于 Groovy 语言来<strong>声明项目设置</strong>。</p>\n</li>\n<li><p>支持多语言构建：Java,  C++, Python, Android , IOS 等等。</p>\n</li>\n<li><p>Gradle 的优势：自动处理 dependencies 关系（Maven 概念），自动处理部署问题（Ant 概念），可以使用条件判断写法（Groovy语言）</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h5 id=\"Android-构建流程步骤\"><a href=\"#Android-构建流程步骤\" class=\"headerlink\" title=\"Android 构建流程步骤\"></a>Android 构建流程步骤</h5><ul>\n<li><p>编译器（Compilers）将源代码（SourceCode）转换成 DEX 文件（Dalvik Executable，Dalvik 是运行在 Android 上面的虚拟机，.dex 文件包括运行在 Android 上的字节码），并且将其他内容转换成已编译资源。</p>\n</li>\n<li><p>APK 打包器将 DEX 文件和已编译文件合并成单个 APK，不过要先进行对 APK 进行签名。</p>\n</li>\n<li><p>APK 打包器使用调试（Debug）或发布（Release）密钥来对 APK 进行签名处理。（1）构建 Debug 版本，则 Android Studio 自动生成 Debug 的签名密钥。（2）构建 Release 版本则需要用户自己生成签名密钥。</p>\n</li>\n<li><p>在生成最终 APK 之前，打包器使用 zipalign 工具进行对 APK 优化。（减少运行内存占用，zipalign 是一个进行对未压缩数据对齐工具）</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/0HongTao0/Blog/blob/master/pic/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.png?raw=true\" alt=\"Android 构建流程\"></p>\n<h5 id=\"Android-构建的配置文件\"><a href=\"#Android-构建的配置文件\" class=\"headerlink\" title=\"Android 构建的配置文件\"></a>Android 构建的配置文件</h5><p>首先我们新建的 Android 项目，通常 Android Studio 帮我们自动创建了几个 gradle 文件</p>\n<p><img src=\"https://github.com/0HongTao0/Blog/blob/master/pic/AndroidStudio%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.jpg?raw=true\" alt=\"AndroidStudio 新建项目\"></p>\n<ul>\n<li><p>settings.gradle 文件（位于项目根目录），此 gradle 文件用于指示 Gradle 在构建应用时包含哪些模块（Module）在内。</p>\n<p>如下面代码包含 app 本身模块以及 alpha 模块</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">':app'</span></span><br><span class=\"line\">include <span class=\"string\">':alpha'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>顶级构建文件 build.gradle（位于项目根目录），此 gradle 文件适用于项目所有模块的构建配置</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 下载远程依赖的仓库地址（远程仓库地址有JCenter, Maven Central, and Ivy，当然也可以用国内的某些镜像）</span></span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 指定需要用于构建项目的 Gradle 版本信息</span></span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:3.1.1'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 配置项目中所有模块使用的远程仓库地址和依赖</span></span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模块级构建文件 build.gradle （位于模块的根目录下），此 gradle 文件用于配置所在模块的构建设置。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构建的插件                    </span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//配置 android 应用程序的构建环境和使用环境</span></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 指定使用哪个版本的 SDK 编译 app</span></span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">          <span class=\"comment\">//通常使用包名来定义 applicationId ，由main / AndroidManifest.xml文件中的package属性定义。</span></span><br><span class=\"line\">        applicationId <span class=\"string\">\"xyz.awqingnian.touchpull\"</span></span><br><span class=\"line\">          <span class=\"comment\">// Android 设备要运行此 app 最小的 SDK 版本</span></span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">          <span class=\"comment\">// 指定用于测试此 app 的 SDK 版本</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">          <span class=\"comment\">// app 的版本号</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">          <span class=\"comment\">// app 的版本名字</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">          <span class=\"comment\">//发布版本的配置信息</span></span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"literal\">false</span> <span class=\"comment\">//是否启用代码压缩（否）</span></span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 模块中用到的第三方依赖</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support:appcompat-v7:27.0.2'</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support.constraint:constraint-layout:1.0.2'</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">'junit:junit:4.12'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test:runner:1.0.1'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test.espresso:espresso-core:3.0.1'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>dependencies 配置</th>\n<th>引用生命期</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>implementation</td>\n<td>依赖项在编译时对模块可用，并且仅在运行时对模块的消费者可用。 对于大型多项目构建，使用<code>implementation</code>而不是<code>api</code>/<code>compile</code>可以<strong>显著缩短构建时间</strong>，因为它可以减少构建系统需要重新编译的项目量。 大多数应用和测试模块都应使用此配置。</td>\n</tr>\n<tr>\n<td>api</td>\n<td>依赖项在编译时对模块可用，并且在编译时和运行时还对模块的消费者可用。 此配置的行为类似于<code>compile</code>（现在已弃用），一般情况下，您应当仅在库模块中使用它。 应用模块应使用<code>implementation</code>，除非您想要将其 API 公开给单独的测试模块。</td>\n</tr>\n<tr>\n<td>compileOnly</td>\n<td>依赖项仅在编译时对模块可用，并且在编译或运行时对其消费者不可用。 此配置的行为类似于<code>provided</code>（现在已弃用）。</td>\n</tr>\n<tr>\n<td>runtimeOnly</td>\n<td>依赖项仅在运行时对模块及其消费者可用。 此配置的行为类似于<code>apk</code>（现在已弃用）。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Gradle-属性文件\"><a href=\"#Gradle-属性文件\" class=\"headerlink\" title=\"Gradle 属性文件\"></a>Gradle 属性文件</h5><ul>\n<li><p>gradle.properties ： 配置项目范围 Gradle 设置，例如 Gradle 后台进程的最大堆大小。</p>\n</li>\n<li><p>local.properties ： 为构建系统配置本地环境属性，例如 SDK 安装路径。由于该文件的内容由 Android Studio 自动生成并且专用于本地开发者环境，因此您不应手动修改该文件，或将其纳入您的版本控制系统。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h5 id=\"简单介绍一下-Gradle-Build-Tool\"><a href=\"#简单介绍一下-Gradle-Build-Tool\" class=\"headerlink\" title=\"简单介绍一下 Gradle Build Tool\"></a>简单介绍一下 <a href=\"https://gradle.org/\" target=\"_blank\" rel=\"noopener\">Gradle Build Tool</a></h5><ul>\n<li><p>可以帮助团队更快地构建，自动化和交付更好的软件。</p>\n</li>\n<li><p>使用一种基于 Groovy 语言来<strong>声明项目设置</strong>。</p>\n</li>\n<li><p>支持多语言构建：Java,  C++, Python, Android , IOS 等等。</p>\n</li>\n<li><p>Gradle 的优势：自动处理 dependencies 关系（Maven 概念），自动处理部署问题（Ant 概念），可以使用条件判断写法（Groovy语言）</p>\n</li>\n</ul>","more":"<h5 id=\"Android-构建流程步骤\"><a href=\"#Android-构建流程步骤\" class=\"headerlink\" title=\"Android 构建流程步骤\"></a>Android 构建流程步骤</h5><ul>\n<li><p>编译器（Compilers）将源代码（SourceCode）转换成 DEX 文件（Dalvik Executable，Dalvik 是运行在 Android 上面的虚拟机，.dex 文件包括运行在 Android 上的字节码），并且将其他内容转换成已编译资源。</p>\n</li>\n<li><p>APK 打包器将 DEX 文件和已编译文件合并成单个 APK，不过要先进行对 APK 进行签名。</p>\n</li>\n<li><p>APK 打包器使用调试（Debug）或发布（Release）密钥来对 APK 进行签名处理。（1）构建 Debug 版本，则 Android Studio 自动生成 Debug 的签名密钥。（2）构建 Release 版本则需要用户自己生成签名密钥。</p>\n</li>\n<li><p>在生成最终 APK 之前，打包器使用 zipalign 工具进行对 APK 优化。（减少运行内存占用，zipalign 是一个进行对未压缩数据对齐工具）</p>\n</li>\n</ul>\n<p><img src=\"https://github.com/0HongTao0/Blog/blob/master/pic/Android_%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.png?raw=true\" alt=\"Android 构建流程\"></p>\n<h5 id=\"Android-构建的配置文件\"><a href=\"#Android-构建的配置文件\" class=\"headerlink\" title=\"Android 构建的配置文件\"></a>Android 构建的配置文件</h5><p>首先我们新建的 Android 项目，通常 Android Studio 帮我们自动创建了几个 gradle 文件</p>\n<p><img src=\"https://github.com/0HongTao0/Blog/blob/master/pic/AndroidStudio%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.jpg?raw=true\" alt=\"AndroidStudio 新建项目\"></p>\n<ul>\n<li><p>settings.gradle 文件（位于项目根目录），此 gradle 文件用于指示 Gradle 在构建应用时包含哪些模块（Module）在内。</p>\n<p>如下面代码包含 app 本身模块以及 alpha 模块</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">include <span class=\"string\">':app'</span></span><br><span class=\"line\">include <span class=\"string\">':alpha'</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>顶级构建文件 build.gradle（位于项目根目录），此 gradle 文件适用于项目所有模块的构建配置</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buildscript &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 下载远程依赖的仓库地址（远程仓库地址有JCenter, Maven Central, and Ivy，当然也可以用国内的某些镜像）</span></span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 指定需要用于构建项目的 Gradle 版本信息</span></span><br><span class=\"line\">    dependencies &#123;</span><br><span class=\"line\">        classpath <span class=\"string\">'com.android.tools.build:gradle:3.1.1'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 配置项目中所有模块使用的远程仓库地址和依赖</span></span><br><span class=\"line\">allprojects &#123;</span><br><span class=\"line\">    repositories &#123;</span><br><span class=\"line\">        google()</span><br><span class=\"line\">        jcenter()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模块级构建文件 build.gradle （位于模块的根目录下），此 gradle 文件用于配置所在模块的构建设置。</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构建的插件                    </span></span><br><span class=\"line\">apply <span class=\"string\">plugin:</span> <span class=\"string\">'com.android.application'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//配置 android 应用程序的构建环境和使用环境</span></span><br><span class=\"line\">android &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 指定使用哪个版本的 SDK 编译 app</span></span><br><span class=\"line\">    compileSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">    defaultConfig &#123;</span><br><span class=\"line\">          <span class=\"comment\">//通常使用包名来定义 applicationId ，由main / AndroidManifest.xml文件中的package属性定义。</span></span><br><span class=\"line\">        applicationId <span class=\"string\">\"xyz.awqingnian.touchpull\"</span></span><br><span class=\"line\">          <span class=\"comment\">// Android 设备要运行此 app 最小的 SDK 版本</span></span><br><span class=\"line\">        minSdkVersion <span class=\"number\">21</span></span><br><span class=\"line\">          <span class=\"comment\">// 指定用于测试此 app 的 SDK 版本</span></span><br><span class=\"line\">        targetSdkVersion <span class=\"number\">27</span></span><br><span class=\"line\">          <span class=\"comment\">// app 的版本号</span></span><br><span class=\"line\">        versionCode <span class=\"number\">1</span></span><br><span class=\"line\">          <span class=\"comment\">// app 的版本名字</span></span><br><span class=\"line\">        versionName <span class=\"string\">\"1.0\"</span></span><br><span class=\"line\">        testInstrumentationRunner <span class=\"string\">\"android.support.test.runner.AndroidJUnitRunner\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buildTypes &#123;</span><br><span class=\"line\">          <span class=\"comment\">//发布版本的配置信息</span></span><br><span class=\"line\">        release &#123;</span><br><span class=\"line\">            minifyEnabled <span class=\"literal\">false</span> <span class=\"comment\">//是否启用代码压缩（否）</span></span><br><span class=\"line\">            proguardFiles getDefaultProguardFile(<span class=\"string\">'proguard-android.txt'</span>), <span class=\"string\">'proguard-rules.pro'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 模块中用到的第三方依赖</span></span><br><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation fileTree(<span class=\"string\">dir:</span> <span class=\"string\">'libs'</span>, <span class=\"string\">include:</span> [<span class=\"string\">'*.jar'</span>])</span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support:appcompat-v7:27.0.2'</span></span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.support.constraint:constraint-layout:1.0.2'</span></span><br><span class=\"line\">    testImplementation <span class=\"string\">'junit:junit:4.12'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test:runner:1.0.1'</span></span><br><span class=\"line\">    androidTestImplementation <span class=\"string\">'com.android.support.test.espresso:espresso-core:3.0.1'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>dependencies 配置</th>\n<th>引用生命期</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>implementation</td>\n<td>依赖项在编译时对模块可用，并且仅在运行时对模块的消费者可用。 对于大型多项目构建，使用<code>implementation</code>而不是<code>api</code>/<code>compile</code>可以<strong>显著缩短构建时间</strong>，因为它可以减少构建系统需要重新编译的项目量。 大多数应用和测试模块都应使用此配置。</td>\n</tr>\n<tr>\n<td>api</td>\n<td>依赖项在编译时对模块可用，并且在编译时和运行时还对模块的消费者可用。 此配置的行为类似于<code>compile</code>（现在已弃用），一般情况下，您应当仅在库模块中使用它。 应用模块应使用<code>implementation</code>，除非您想要将其 API 公开给单独的测试模块。</td>\n</tr>\n<tr>\n<td>compileOnly</td>\n<td>依赖项仅在编译时对模块可用，并且在编译或运行时对其消费者不可用。 此配置的行为类似于<code>provided</code>（现在已弃用）。</td>\n</tr>\n<tr>\n<td>runtimeOnly</td>\n<td>依赖项仅在运行时对模块及其消费者可用。 此配置的行为类似于<code>apk</code>（现在已弃用）。</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"Gradle-属性文件\"><a href=\"#Gradle-属性文件\" class=\"headerlink\" title=\"Gradle 属性文件\"></a>Gradle 属性文件</h5><ul>\n<li><p>gradle.properties ： 配置项目范围 Gradle 设置，例如 Gradle 后台进程的最大堆大小。</p>\n</li>\n<li><p>local.properties ： 为构建系统配置本地环境属性，例如 SDK 安装路径。由于该文件的内容由 Android Studio 自动生成并且专用于本地开发者环境，因此您不应手动修改该文件，或将其纳入您的版本控制系统。</p>\n</li>\n</ul>"},{"title":"Android Retrofit","date":"2018-07-26T02:48:42.000Z","_content":"\n##### 简单介绍一下 [Retrofit](https://square.github.io/retrofit/)\n\n- Type-safe HTTP client for Android and Java by Square ，适用于 Android 和 Java 客户端进行网络请求。\n\n- 通过注解描述 Http 请求，Url 参数和 Request 请求参数。\n\n- 支持自定义 Header，多类型请求体，文件上传和下载，**模仿服务器返回的 Response（Mocking Responses）**\n\n<!--more-->\n\n##### 项目导入 Retrofit\n\n- Gradle 文件添加依赖**(Retrofit 1.9 以下版本需要自行添加 OKHttp 的依赖)**\n\n  ```groovy\n  implementation 'com.squareup.retrofit2:retrofit:2.4.0' //Retrofit 的依赖包\n  implementation 'com.squareup.retrofit2:converter-gson:2.3.0' // Retrofit 的 Gson 转换器依赖包\n  ```\n\n- 添加网络权限\n\n  ```xml\n  <uses-permission android:name=\"android.permission.INTERNET\"/>\n  ```\n\n##### 使用 Retrofit 进行简单的网络请求（借用 [Github 仓库接口](https://api.github.com/users/{user}/repos)）\n\n- 定义进行网络请求的 Api 接口\n\n  ```java\n  public interface GitHubClient {\n      //请求方法 GET，填入的是 url ，请求参数 user 对应接口方法 reposForUser 的 user 值\n      @GET(\"/users/{user}/repos\") \n      Call<List<GitHubRepo>> reposForUser(\n              @Path(\"user\") String user\n      );\n  }\n  ```\n\n- 根据数据返回类型进行定义 Model （数据返回较多，选取部分进行解析）\n\n  ```java\n  public class GitHubRepo {\n      private int id;\n      private String name;\n  \n      public GitHubRepo() {\n      }\n  \n      public int getId() {\n          return id;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  }\n  ```\n\n- 进行网络请求（Request）和获取返回结果（Response）\n\n  ```java\n  // 获取 Retrofit 的构造器,通过构造器构造 Retrofit 实例\n  Retrofit retrofit = new Retrofit.Builder()\n          //baseUrl 要与配置接口中的请求方法中的 url 拼接\n          .baseUrl(API_BASE_URL) \n          //转换器是 Gson 转换器，通过 GsonConverterFactory 获得\n          .addConverterFactory(GsonConverterFactory.create())\n          //使用 OKHttp 进行网络请求\n          .client(NetWordStudyApplication.getHttpClient().build()) \n          .build();\n  //获得对应接口的网络请求\n  GitHubClient client = retrofit.create(GitHubClient.class);\n  //进行网络请求，并且获取请求结果\n  Call<List<GitHubRepo>> call = client.reposForUser(\"Xiao\");\n  // Callback 的泛型解释：经过 Gson 转换器通过此泛型对返回数据进行转换解析。\n  call.enqueue(new Callback<List<GitHubRepo>>() {\n      @Override\n      public void onResponse(Call<List<GitHubRepo>> call, Response<List<GitHubRepo>> response){\n          //请求成功并返回结果在此进行处理，请求数据在 response.body() 里面（对应 Callback 泛型）\n      }\n  \n      @Override\n      public void onFailure(Call<List<GitHubRepo>> call, Throwable t) {\n          //请求失败，在此获取请求失败的 Throwable 原因等。\n      }\n  });\n  ```\n\n##### 使用 Java 注解来定义 Api 接口的内容\n\n通常，我们的 Api 接口都应该包含 3 部分：请求方法名字，返回类型，请求方法参数。\n\n- 请求方法：Retrofit 提供 5 种 Http 请求方法，使用注解：@GET, @POST, @PUT, @DELETE, @PATCH, @HEAD。具体功能是 [Http 协议](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods)内容，在此不再累述。此外，你需要添加**相对的 Api Url** 作为请求方法的参数，因为 Retrofit 提供一个设置 baseUrl 的方法（优点：方便改变全局 Url ），也可以直接定义**完整的 Api Url 路径**，或者你不用直接定义 Url，而是通过参数传入，**动态指定请求 Url** 。\n\n- 返回类型：Call<T> 中的泛型 T ，就是 Converter（Retrofit 转换器）通过解析请求 Api 接口的返回数据成的实例。假如想获得原始数据，而不是解析出来的数据，则该泛型 T 应该设置为 ResponseBody 。或者你根本不需要知道此请求的结果，也可以将泛型 T 设置为 Void 。\n\n- 请求方法参数：\n\n| 请求方法参数注解   | 解释                                                       |\n|:----------:|:--------------------------------------------------------:|\n| @Body      | 将 Java 对象进行解析作为请求体（Request Body）发送（当转换器为 GSON ，解析成 JSON） |\n| @Url       | 动态传入的 Url                                                |\n| @Filed     | 将数据作为 Form 表单发送                                          |\n| @Header    | 动态为请求加上头部（Request Header ）                               |\n| @HeaderMap | 动态为请求加上头部集合（Request Header ）                             |\n\n  以下是对应的一些例子：\n\n```java\n  public interface FutureStudioClient {  \n      @GET(\"/user/info\")\n      Call<UserInfo> getUserInfo();\n\n      @PUT(\"/user/info\")\n      Call<UserInfo> updateUserInfo(\n          @Body UserInfo userInfo\n      );\n\n      @DELETE(\"/user\")\n      Call<Void> deleteUser();\n\n      @GET(\"https://futurestud.io/tutorials/rss/\") //完整的 Api Url 路径\n      Call<FutureStudioRssFeed> getRssFeed();\n\n      @GET\n      Call<ResponseBody> getUserProfilePhoto(\n          @Url String profilePhotoUrl //动态传入 Url\n      );\n  }\n```\n\nApi 的请求参数：一般来说，我们的 Api 请求方法是 GET 和 POST，GET 的请求参数是直接拼接在 Url 进行请求，而 POST 的请求参数是放在 Body 里面进行请求。\n\n- Api Url 为 https://api.github.com/users/{user}/repos （**REST APIs**）这种占位符形式，使用 @Path 让接口方法的参数替换在 Url 中  {user} 的值。例子：\n\n  ```java\n  public interface GitHubClient {  \n      @GET(\"/users/{user}/repos\")\n      Call<List<GitHubRepo>> reposForUser(\n          @Path(\"user\") String user\n      );\n  }\n  ```\n\n- Api Url 为：https://futurestud.io/tutorials?page=page&order=order&author=author&published_at=date ，其中 ?Xxx=xxx 就是以一种键值对的形式传入。此时可以使用 @Query 将接口方法参数拼接成这种形式的 Url 。例子：\n\n  ```java\n  public interface NewsService() {  \n      @GET(\"/news\")\n      Call<List<News>> getNews(\n              @Query(\"page\") int page,\n              @Query(\"order\") String order,\n              @Query(\"author\") String author,\n              @Query(\"published_at\") Date date,\n      );\n  }\n  ```\n\n  当然，多个请求参数可以使用 @QueryMap，上面请求参数的表现形式等同于：\n\n  ```java\n  public interface NewsService() {  \n      @GET(\"/news\")\n      Call<List<News>> getNews(\n          @QueryMap Map<String, String> options\n      );\n  }\n  \n  private void fetchNews() {  \n      Map<String, String> data = new HashMap<>();\n      data.put(\"author\", \"Marcus\");\n      data.put(\"page\", String.valueOf(2));\n      //.....\n      Call<List<News>> call = newsService.getNews(data);\n      call.enqueue(…);\n  }\n  ```\n\n##### 对 Retrofit 进行封装（ServiceGenerator）\n\n```java\npublic class ServiceGenerator {\n    // App 中的 BaseUrl，若更改 Url，即可在此直接修改。\n    private static final String BASE_URL = \"https://api.github.com/\";\n    // Gson 转换器\n      private static GsonConverterFactory gsonFactory = GsonConverterFactory.create(); \n\n    private static Retrofit.Builder builder = new Retrofit.Builder()\n                    .baseUrl(BASE_URL)\n                    .addConverterFactory(gsonFactory);\n\n    private static Retrofit retrofit = builder.build();\n    //自定义的登录拦截器\n    private static HttpLoggingInterceptor logging = new HttpLoggingInterceptor()\n                    .setLevel(HttpLoggingInterceptor.Level.BODY);\n    //使用 OKHttp 进行网络请求\n    private static OkHttpClient.Builder httpClient =new OkHttpClient.Builder(); \n\n    // Api 接口泛型封装，参数：带注解配置的 Api 请求接口，返回即可执行网络请求。\n    public static <S> S createService(Class<S> serviceClass) {\n          //在此对 OKHttp 添加登录拦截器的拦截\n          if (!httpClient.interceptors().contains(logging)) {\n            httpClient.addInterceptor(logging);\n            builder.client(httpClient.build());\n            retrofit = builder.build();\n        }\n        return retrofit.create(serviceClass);\n    }\n}\n```\n\n**上面的成员变量和成员方法都是 static （静态）的，原因是整个 App 进行网络请求也只要有一个出口就行，不需要那么多实例（节约资源），static（静态）方法和变量是加载该类的时候就已经加载了的，类对应的实例只有一个该静态变量，所以性能上比较快。**\n\n在经过封装后的 Retrofit 调用就非常简单了。之前的创建 GitHubClient 实例的例子等同于下面代码：\n\n```java\nGitHubClient client = ServiceGenerator.createService(GitHubClient.class);//带注解配置的 Api 请求接口\n```\n\n上面只是一个简单的封装，在 App 中的所有网络请求都会经过 ServiceGenerator 类的 createService(Class<S&dt; serviceClass) 方法，还有 Retrofit 进行网络请求的是 OKHttp ，所有我们可以在此类加入 [OKHttp 的拦截器](https://github.com/square/okhttp/wiki/Interceptors) 进行对网络请求的**请求（Request）**和**返回（Response）**进行一些判断处理（是否登录等）。\n\n##### 如何公用一个 OKHttpClient 对不同 Url 进行请求以及设置不同的拦截器。\n\n- OKHttp 只需要一个就行,多开会导致资源浪费，影响 App 性能。共用同一个 OKHttpClient 就是共用 RequestPool ，diskcache， routing logic 等等资源。\n\n- 不同拦截器，比如登录拦截器，资源访问拦截器，权限拦截器等，但是他们的 Url 都是以 BaseUrl 为基础，但是又不相同的。\n\n```java\nOkHttpClient baseOkHttpClient = new OkHttpClient();\n\nOkHttpClient okHttpClientV1 = baseOkHttpClient  \n        .newBuilder()\n        .followRedirects(false)\n        .build()\n\nRetrofit retrofitApiV1 = new Retrofit.Builder()  \n        .baseUrl(\"https://futurestud.io/v1/\")\n        .client(okHttpClientV1)\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n\nOkHttpClient okHttpClientV2 = baseOkHttpClient  \n        .newBuilder()\n        .addInterceptor(...)\n        .build()\n\nRetrofit retrofitApiV2 = new Retrofit.Builder()  \n        .baseUrl(\"https://futurestud.io/v2/\")\n        .client(okHttpClientV2)\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n```\n\n##### 同步请求与异步请求\n\n- **Retrofit 2 中的同步请求和异步请求的接口定义是一样的（没有区别），所以在使用 Retrofit 进行网络请求的时候，UI 线程（Main 线程）会阻塞。需要另开子线程进行网络请求（Retrofit 需要开发者自己实现异步）。**\n\n  以 Call<T&dt; 为接口方法的返回值，T 为根据返回数据的解析类型。\n\n  ```java\n  //请求接口定义\n  public interface TaskService {\n      @GET(\"/tasks\")\n      Call<List<Task>> getTasks();\n  }\n  \n  //同步请求和异步请求（相同）\n  TaskService taskService = ServiceGenerator.createService(TaskService.class);  \n  Call<List<Task>> call = taskService.getTasks();  \n  call.enqueue(new Callback<List<Task>>() {  \n      @Override\n      public void onResponse(Call<List<Task>> call, Response<List<Task>> response) {\n  \n      }\n  \n      @Override\n      public void onFailure(Call<List<Task>> call, Throwable t) {\n  \n      }\n  }\n  ```\n\n- Retrofit 1 中的同步请求接口方法返回值直接是经过解析后的值（对比 Retrofit 没有 Call 封装）；异步请求接口没有返回值（Void），但是在接口方法有接口回调 Callback<T&dt; cb ，在 Callback 的 onResponse 和 onFailure 回调方法处理结果。\n\n  ```java\n  //请求接口定义\n  public interface TaskService {  \n      @GET(\"/tasks\")\n      void getTasks(Callback<List<Task>> cb);\n  }\n  \n  //同步请求\n  TaskService taskService = ServiceGenerator.createService(TaskService.class);  \n  List<Task> tasks = taskService.getTasks();  \n  \n  //异步请求\n  TaskService taskService = ServiceGenerator.createService(TaskService.class);  \n  taskService.getTasks(new Callback<List<Task>>() {  \n      @Override\n      public void success(List<Task> tasks, Response response) {\n  \n      }\n  \n      @Override\n      public void failure(RetrofitError error) {\n  \n      }\n  });\n  ```\n\n##### 获取原始的 Http 返回数据的方法。（Raw Response）\n\n- 上文提过，将 Call<T&dt; 的返回类型设置成 ResponsBody，可以取到响应体的内容。也就是转换器的解析内容。\n\n- 通过 response.raw() 获取原生返回数据（OKHttp 的 Response 内容）。\n","source":"_posts/Android Retrofit.md","raw":"---\ntitle: Android Retrofit\ndate: 2018-07-26 10:48:42\ntags:\n\n\n---\n\n##### 简单介绍一下 [Retrofit](https://square.github.io/retrofit/)\n\n- Type-safe HTTP client for Android and Java by Square ，适用于 Android 和 Java 客户端进行网络请求。\n\n- 通过注解描述 Http 请求，Url 参数和 Request 请求参数。\n\n- 支持自定义 Header，多类型请求体，文件上传和下载，**模仿服务器返回的 Response（Mocking Responses）**\n\n<!--more-->\n\n##### 项目导入 Retrofit\n\n- Gradle 文件添加依赖**(Retrofit 1.9 以下版本需要自行添加 OKHttp 的依赖)**\n\n  ```groovy\n  implementation 'com.squareup.retrofit2:retrofit:2.4.0' //Retrofit 的依赖包\n  implementation 'com.squareup.retrofit2:converter-gson:2.3.0' // Retrofit 的 Gson 转换器依赖包\n  ```\n\n- 添加网络权限\n\n  ```xml\n  <uses-permission android:name=\"android.permission.INTERNET\"/>\n  ```\n\n##### 使用 Retrofit 进行简单的网络请求（借用 [Github 仓库接口](https://api.github.com/users/{user}/repos)）\n\n- 定义进行网络请求的 Api 接口\n\n  ```java\n  public interface GitHubClient {\n      //请求方法 GET，填入的是 url ，请求参数 user 对应接口方法 reposForUser 的 user 值\n      @GET(\"/users/{user}/repos\") \n      Call<List<GitHubRepo>> reposForUser(\n              @Path(\"user\") String user\n      );\n  }\n  ```\n\n- 根据数据返回类型进行定义 Model （数据返回较多，选取部分进行解析）\n\n  ```java\n  public class GitHubRepo {\n      private int id;\n      private String name;\n  \n      public GitHubRepo() {\n      }\n  \n      public int getId() {\n          return id;\n      }\n  \n      public String getName() {\n          return name;\n      }\n  }\n  ```\n\n- 进行网络请求（Request）和获取返回结果（Response）\n\n  ```java\n  // 获取 Retrofit 的构造器,通过构造器构造 Retrofit 实例\n  Retrofit retrofit = new Retrofit.Builder()\n          //baseUrl 要与配置接口中的请求方法中的 url 拼接\n          .baseUrl(API_BASE_URL) \n          //转换器是 Gson 转换器，通过 GsonConverterFactory 获得\n          .addConverterFactory(GsonConverterFactory.create())\n          //使用 OKHttp 进行网络请求\n          .client(NetWordStudyApplication.getHttpClient().build()) \n          .build();\n  //获得对应接口的网络请求\n  GitHubClient client = retrofit.create(GitHubClient.class);\n  //进行网络请求，并且获取请求结果\n  Call<List<GitHubRepo>> call = client.reposForUser(\"Xiao\");\n  // Callback 的泛型解释：经过 Gson 转换器通过此泛型对返回数据进行转换解析。\n  call.enqueue(new Callback<List<GitHubRepo>>() {\n      @Override\n      public void onResponse(Call<List<GitHubRepo>> call, Response<List<GitHubRepo>> response){\n          //请求成功并返回结果在此进行处理，请求数据在 response.body() 里面（对应 Callback 泛型）\n      }\n  \n      @Override\n      public void onFailure(Call<List<GitHubRepo>> call, Throwable t) {\n          //请求失败，在此获取请求失败的 Throwable 原因等。\n      }\n  });\n  ```\n\n##### 使用 Java 注解来定义 Api 接口的内容\n\n通常，我们的 Api 接口都应该包含 3 部分：请求方法名字，返回类型，请求方法参数。\n\n- 请求方法：Retrofit 提供 5 种 Http 请求方法，使用注解：@GET, @POST, @PUT, @DELETE, @PATCH, @HEAD。具体功能是 [Http 协议](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods)内容，在此不再累述。此外，你需要添加**相对的 Api Url** 作为请求方法的参数，因为 Retrofit 提供一个设置 baseUrl 的方法（优点：方便改变全局 Url ），也可以直接定义**完整的 Api Url 路径**，或者你不用直接定义 Url，而是通过参数传入，**动态指定请求 Url** 。\n\n- 返回类型：Call<T> 中的泛型 T ，就是 Converter（Retrofit 转换器）通过解析请求 Api 接口的返回数据成的实例。假如想获得原始数据，而不是解析出来的数据，则该泛型 T 应该设置为 ResponseBody 。或者你根本不需要知道此请求的结果，也可以将泛型 T 设置为 Void 。\n\n- 请求方法参数：\n\n| 请求方法参数注解   | 解释                                                       |\n|:----------:|:--------------------------------------------------------:|\n| @Body      | 将 Java 对象进行解析作为请求体（Request Body）发送（当转换器为 GSON ，解析成 JSON） |\n| @Url       | 动态传入的 Url                                                |\n| @Filed     | 将数据作为 Form 表单发送                                          |\n| @Header    | 动态为请求加上头部（Request Header ）                               |\n| @HeaderMap | 动态为请求加上头部集合（Request Header ）                             |\n\n  以下是对应的一些例子：\n\n```java\n  public interface FutureStudioClient {  \n      @GET(\"/user/info\")\n      Call<UserInfo> getUserInfo();\n\n      @PUT(\"/user/info\")\n      Call<UserInfo> updateUserInfo(\n          @Body UserInfo userInfo\n      );\n\n      @DELETE(\"/user\")\n      Call<Void> deleteUser();\n\n      @GET(\"https://futurestud.io/tutorials/rss/\") //完整的 Api Url 路径\n      Call<FutureStudioRssFeed> getRssFeed();\n\n      @GET\n      Call<ResponseBody> getUserProfilePhoto(\n          @Url String profilePhotoUrl //动态传入 Url\n      );\n  }\n```\n\nApi 的请求参数：一般来说，我们的 Api 请求方法是 GET 和 POST，GET 的请求参数是直接拼接在 Url 进行请求，而 POST 的请求参数是放在 Body 里面进行请求。\n\n- Api Url 为 https://api.github.com/users/{user}/repos （**REST APIs**）这种占位符形式，使用 @Path 让接口方法的参数替换在 Url 中  {user} 的值。例子：\n\n  ```java\n  public interface GitHubClient {  \n      @GET(\"/users/{user}/repos\")\n      Call<List<GitHubRepo>> reposForUser(\n          @Path(\"user\") String user\n      );\n  }\n  ```\n\n- Api Url 为：https://futurestud.io/tutorials?page=page&order=order&author=author&published_at=date ，其中 ?Xxx=xxx 就是以一种键值对的形式传入。此时可以使用 @Query 将接口方法参数拼接成这种形式的 Url 。例子：\n\n  ```java\n  public interface NewsService() {  \n      @GET(\"/news\")\n      Call<List<News>> getNews(\n              @Query(\"page\") int page,\n              @Query(\"order\") String order,\n              @Query(\"author\") String author,\n              @Query(\"published_at\") Date date,\n      );\n  }\n  ```\n\n  当然，多个请求参数可以使用 @QueryMap，上面请求参数的表现形式等同于：\n\n  ```java\n  public interface NewsService() {  \n      @GET(\"/news\")\n      Call<List<News>> getNews(\n          @QueryMap Map<String, String> options\n      );\n  }\n  \n  private void fetchNews() {  \n      Map<String, String> data = new HashMap<>();\n      data.put(\"author\", \"Marcus\");\n      data.put(\"page\", String.valueOf(2));\n      //.....\n      Call<List<News>> call = newsService.getNews(data);\n      call.enqueue(…);\n  }\n  ```\n\n##### 对 Retrofit 进行封装（ServiceGenerator）\n\n```java\npublic class ServiceGenerator {\n    // App 中的 BaseUrl，若更改 Url，即可在此直接修改。\n    private static final String BASE_URL = \"https://api.github.com/\";\n    // Gson 转换器\n      private static GsonConverterFactory gsonFactory = GsonConverterFactory.create(); \n\n    private static Retrofit.Builder builder = new Retrofit.Builder()\n                    .baseUrl(BASE_URL)\n                    .addConverterFactory(gsonFactory);\n\n    private static Retrofit retrofit = builder.build();\n    //自定义的登录拦截器\n    private static HttpLoggingInterceptor logging = new HttpLoggingInterceptor()\n                    .setLevel(HttpLoggingInterceptor.Level.BODY);\n    //使用 OKHttp 进行网络请求\n    private static OkHttpClient.Builder httpClient =new OkHttpClient.Builder(); \n\n    // Api 接口泛型封装，参数：带注解配置的 Api 请求接口，返回即可执行网络请求。\n    public static <S> S createService(Class<S> serviceClass) {\n          //在此对 OKHttp 添加登录拦截器的拦截\n          if (!httpClient.interceptors().contains(logging)) {\n            httpClient.addInterceptor(logging);\n            builder.client(httpClient.build());\n            retrofit = builder.build();\n        }\n        return retrofit.create(serviceClass);\n    }\n}\n```\n\n**上面的成员变量和成员方法都是 static （静态）的，原因是整个 App 进行网络请求也只要有一个出口就行，不需要那么多实例（节约资源），static（静态）方法和变量是加载该类的时候就已经加载了的，类对应的实例只有一个该静态变量，所以性能上比较快。**\n\n在经过封装后的 Retrofit 调用就非常简单了。之前的创建 GitHubClient 实例的例子等同于下面代码：\n\n```java\nGitHubClient client = ServiceGenerator.createService(GitHubClient.class);//带注解配置的 Api 请求接口\n```\n\n上面只是一个简单的封装，在 App 中的所有网络请求都会经过 ServiceGenerator 类的 createService(Class<S&dt; serviceClass) 方法，还有 Retrofit 进行网络请求的是 OKHttp ，所有我们可以在此类加入 [OKHttp 的拦截器](https://github.com/square/okhttp/wiki/Interceptors) 进行对网络请求的**请求（Request）**和**返回（Response）**进行一些判断处理（是否登录等）。\n\n##### 如何公用一个 OKHttpClient 对不同 Url 进行请求以及设置不同的拦截器。\n\n- OKHttp 只需要一个就行,多开会导致资源浪费，影响 App 性能。共用同一个 OKHttpClient 就是共用 RequestPool ，diskcache， routing logic 等等资源。\n\n- 不同拦截器，比如登录拦截器，资源访问拦截器，权限拦截器等，但是他们的 Url 都是以 BaseUrl 为基础，但是又不相同的。\n\n```java\nOkHttpClient baseOkHttpClient = new OkHttpClient();\n\nOkHttpClient okHttpClientV1 = baseOkHttpClient  \n        .newBuilder()\n        .followRedirects(false)\n        .build()\n\nRetrofit retrofitApiV1 = new Retrofit.Builder()  \n        .baseUrl(\"https://futurestud.io/v1/\")\n        .client(okHttpClientV1)\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n\nOkHttpClient okHttpClientV2 = baseOkHttpClient  \n        .newBuilder()\n        .addInterceptor(...)\n        .build()\n\nRetrofit retrofitApiV2 = new Retrofit.Builder()  \n        .baseUrl(\"https://futurestud.io/v2/\")\n        .client(okHttpClientV2)\n        .addConverterFactory(GsonConverterFactory.create())\n        .build();\n```\n\n##### 同步请求与异步请求\n\n- **Retrofit 2 中的同步请求和异步请求的接口定义是一样的（没有区别），所以在使用 Retrofit 进行网络请求的时候，UI 线程（Main 线程）会阻塞。需要另开子线程进行网络请求（Retrofit 需要开发者自己实现异步）。**\n\n  以 Call<T&dt; 为接口方法的返回值，T 为根据返回数据的解析类型。\n\n  ```java\n  //请求接口定义\n  public interface TaskService {\n      @GET(\"/tasks\")\n      Call<List<Task>> getTasks();\n  }\n  \n  //同步请求和异步请求（相同）\n  TaskService taskService = ServiceGenerator.createService(TaskService.class);  \n  Call<List<Task>> call = taskService.getTasks();  \n  call.enqueue(new Callback<List<Task>>() {  \n      @Override\n      public void onResponse(Call<List<Task>> call, Response<List<Task>> response) {\n  \n      }\n  \n      @Override\n      public void onFailure(Call<List<Task>> call, Throwable t) {\n  \n      }\n  }\n  ```\n\n- Retrofit 1 中的同步请求接口方法返回值直接是经过解析后的值（对比 Retrofit 没有 Call 封装）；异步请求接口没有返回值（Void），但是在接口方法有接口回调 Callback<T&dt; cb ，在 Callback 的 onResponse 和 onFailure 回调方法处理结果。\n\n  ```java\n  //请求接口定义\n  public interface TaskService {  \n      @GET(\"/tasks\")\n      void getTasks(Callback<List<Task>> cb);\n  }\n  \n  //同步请求\n  TaskService taskService = ServiceGenerator.createService(TaskService.class);  \n  List<Task> tasks = taskService.getTasks();  \n  \n  //异步请求\n  TaskService taskService = ServiceGenerator.createService(TaskService.class);  \n  taskService.getTasks(new Callback<List<Task>>() {  \n      @Override\n      public void success(List<Task> tasks, Response response) {\n  \n      }\n  \n      @Override\n      public void failure(RetrofitError error) {\n  \n      }\n  });\n  ```\n\n##### 获取原始的 Http 返回数据的方法。（Raw Response）\n\n- 上文提过，将 Call<T&dt; 的返回类型设置成 ResponsBody，可以取到响应体的内容。也就是转换器的解析内容。\n\n- 通过 response.raw() 获取原生返回数据（OKHttp 的 Response 内容）。\n","slug":"Android Retrofit","published":1,"updated":"2018-07-27T02:03:59.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzc40004s8o5ts8mas5f","content":"<h5 id=\"简单介绍一下-Retrofit\"><a href=\"#简单介绍一下-Retrofit\" class=\"headerlink\" title=\"简单介绍一下 Retrofit\"></a>简单介绍一下 <a href=\"https://square.github.io/retrofit/\" target=\"_blank\" rel=\"noopener\">Retrofit</a></h5><ul>\n<li><p>Type-safe HTTP client for Android and Java by Square ，适用于 Android 和 Java 客户端进行网络请求。</p>\n</li>\n<li><p>通过注解描述 Http 请求，Url 参数和 Request 请求参数。</p>\n</li>\n<li><p>支持自定义 Header，多类型请求体，文件上传和下载，<strong>模仿服务器返回的 Response（Mocking Responses）</strong></p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h5 id=\"项目导入-Retrofit\"><a href=\"#项目导入-Retrofit\" class=\"headerlink\" title=\"项目导入 Retrofit\"></a>项目导入 Retrofit</h5><ul>\n<li><p>Gradle 文件添加依赖<strong>(Retrofit 1.9 以下版本需要自行添加 OKHttp 的依赖)</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:retrofit:2.4.0'</span> <span class=\"comment\">//Retrofit 的依赖包</span></span><br><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:converter-gson:2.3.0'</span> <span class=\"comment\">// Retrofit 的 Gson 转换器依赖包</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加网络权限</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.INTERNET\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"使用-Retrofit-进行简单的网络请求（借用-Github-仓库接口）\"><a href=\"#使用-Retrofit-进行简单的网络请求（借用-Github-仓库接口）\" class=\"headerlink\" title=\"使用 Retrofit 进行简单的网络请求（借用 Github 仓库接口）\"></a>使用 Retrofit 进行简单的网络请求（借用 <a href=\"https://api.github.com/users/{user}/repos\" target=\"_blank\" rel=\"noopener\">Github 仓库接口</a>）</h5><ul>\n<li><p>定义进行网络请求的 Api 接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//请求方法 GET，填入的是 url ，请求参数 user 对应接口方法 reposForUser 的 user 值</span></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/users/&#123;user&#125;/repos\"</span>) </span><br><span class=\"line\">    Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser(</span><br><span class=\"line\">            <span class=\"meta\">@Path</span>(<span class=\"string\">\"user\"</span>) String user</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据数据返回类型进行定义 Model （数据返回较多，选取部分进行解析）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitHubRepo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GitHubRepo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进行网络请求（Request）和获取返回结果（Response）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 Retrofit 的构造器,通过构造器构造 Retrofit 实例</span></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        <span class=\"comment\">//baseUrl 要与配置接口中的请求方法中的 url 拼接</span></span><br><span class=\"line\">        .baseUrl(API_BASE_URL) </span><br><span class=\"line\">        <span class=\"comment\">//转换器是 Gson 转换器，通过 GsonConverterFactory 获得</span></span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">        <span class=\"comment\">//使用 OKHttp 进行网络请求</span></span><br><span class=\"line\">        .client(NetWordStudyApplication.getHttpClient().build()) </span><br><span class=\"line\">        .build();</span><br><span class=\"line\"><span class=\"comment\">//获得对应接口的网络请求</span></span><br><span class=\"line\">GitHubClient client = retrofit.create(GitHubClient.class);</span><br><span class=\"line\"><span class=\"comment\">//进行网络请求，并且获取请求结果</span></span><br><span class=\"line\">Call&lt;List&lt;GitHubRepo&gt;&gt; call = client.reposForUser(<span class=\"string\">\"Xiao\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Callback 的泛型解释：经过 Gson 转换器通过此泛型对返回数据进行转换解析。</span></span><br><span class=\"line\">call.enqueue(<span class=\"keyword\">new</span> Callback&lt;List&lt;GitHubRepo&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;List&lt;GitHubRepo&gt;&gt; call, Response&lt;List&lt;GitHubRepo&gt;&gt; response)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//请求成功并返回结果在此进行处理，请求数据在 response.body() 里面（对应 Callback 泛型）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;List&lt;GitHubRepo&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//请求失败，在此获取请求失败的 Throwable 原因等。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"使用-Java-注解来定义-Api-接口的内容\"><a href=\"#使用-Java-注解来定义-Api-接口的内容\" class=\"headerlink\" title=\"使用 Java 注解来定义 Api 接口的内容\"></a>使用 Java 注解来定义 Api 接口的内容</h5><p>通常，我们的 Api 接口都应该包含 3 部分：请求方法名字，返回类型，请求方法参数。</p>\n<ul>\n<li><p>请求方法：Retrofit 提供 5 种 Http 请求方法，使用注解：@GET, @POST, @PUT, @DELETE, @PATCH, @HEAD。具体功能是 <a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods\" target=\"_blank\" rel=\"noopener\">Http 协议</a>内容，在此不再累述。此外，你需要添加<strong>相对的 Api Url</strong> 作为请求方法的参数，因为 Retrofit 提供一个设置 baseUrl 的方法（优点：方便改变全局 Url ），也可以直接定义<strong>完整的 Api Url 路径</strong>，或者你不用直接定义 Url，而是通过参数传入，<strong>动态指定请求 Url</strong> 。</p>\n</li>\n<li><p>返回类型：Call<t> 中的泛型 T ，就是 Converter（Retrofit 转换器）通过解析请求 Api 接口的返回数据成的实例。假如想获得原始数据，而不是解析出来的数据，则该泛型 T 应该设置为 ResponseBody 。或者你根本不需要知道此请求的结果，也可以将泛型 T 设置为 Void 。</t></p>\n</li>\n<li><p>请求方法参数：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">请求方法参数注解</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">@Body</td>\n<td style=\"text-align:center\">将 Java 对象进行解析作为请求体（Request Body）发送（当转换器为 GSON ，解析成 JSON）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Url</td>\n<td style=\"text-align:center\">动态传入的 Url</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Filed</td>\n<td style=\"text-align:center\">将数据作为 Form 表单发送</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Header</td>\n<td style=\"text-align:center\">动态为请求加上头部（Request Header ）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@HeaderMap</td>\n<td style=\"text-align:center\">动态为请求加上头部集合（Request Header ）</td>\n</tr>\n</tbody>\n</table>\n<p>  以下是对应的一些例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FutureStudioClient</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/user/info\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;UserInfo&gt; <span class=\"title\">getUserInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PUT</span>(<span class=\"string\">\"/user/info\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;UserInfo&gt; <span class=\"title\">updateUserInfo</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Body UserInfo userInfo</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DELETE</span>(<span class=\"string\">\"/user\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;Void&gt; <span class=\"title\">deleteUser</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"https://futurestud.io/tutorials/rss/\"</span>) <span class=\"comment\">//完整的 Api Url 路径</span></span><br><span class=\"line\">    <span class=\"function\">Call&lt;FutureStudioRssFeed&gt; <span class=\"title\">getRssFeed</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GET</span></span><br><span class=\"line\">    <span class=\"function\">Call&lt;ResponseBody&gt; <span class=\"title\">getUserProfilePhoto</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Url String profilePhotoUrl //动态传入 Url</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Api 的请求参数：一般来说，我们的 Api 请求方法是 GET 和 POST，GET 的请求参数是直接拼接在 Url 进行请求，而 POST 的请求参数是放在 Body 里面进行请求。</p>\n<ul>\n<li><p>Api Url 为 <a href=\"https://api.github.com/users/{user}/repos\" target=\"_blank\" rel=\"noopener\">https://api.github.com/users/{user}/repos</a> （<strong>REST APIs</strong>）这种占位符形式，使用 @Path 让接口方法的参数替换在 Url 中  {user} 的值。例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubClient</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/users/&#123;user&#125;/repos\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser(</span><br><span class=\"line\">        <span class=\"meta\">@Path</span>(<span class=\"string\">\"user\"</span>) String user</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Api Url 为：<a href=\"https://futurestud.io/tutorials?page=page&amp;order=order&amp;author=author&amp;published_at=date\" target=\"_blank\" rel=\"noopener\">https://futurestud.io/tutorials?page=page&amp;order=order&amp;author=author&amp;published_at=date</a> ，其中 ?Xxx=xxx 就是以一种键值对的形式传入。此时可以使用 @Query 将接口方法参数拼接成这种形式的 Url 。例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">NewsService</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/news\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;News&gt;&gt; getNews(</span><br><span class=\"line\">            <span class=\"meta\">@Query</span>(<span class=\"string\">\"page\"</span>) <span class=\"keyword\">int</span> page,</span><br><span class=\"line\">            <span class=\"meta\">@Query</span>(<span class=\"string\">\"order\"</span>) String order,</span><br><span class=\"line\">            <span class=\"meta\">@Query</span>(<span class=\"string\">\"author\"</span>) String author,</span><br><span class=\"line\">            <span class=\"meta\">@Query</span>(<span class=\"string\">\"published_at\"</span>) Date date,</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，多个请求参数可以使用 @QueryMap，上面请求参数的表现形式等同于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">NewsService</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/news\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;News&gt;&gt; getNews(</span><br><span class=\"line\">        <span class=\"meta\">@QueryMap</span> Map&lt;String, String&gt; options</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fetchNews</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    Map&lt;String, String&gt; data = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    data.put(<span class=\"string\">\"author\"</span>, <span class=\"string\">\"Marcus\"</span>);</span><br><span class=\"line\">    data.put(<span class=\"string\">\"page\"</span>, String.valueOf(<span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"comment\">//.....</span></span><br><span class=\"line\">    Call&lt;List&lt;News&gt;&gt; call = newsService.getNews(data);</span><br><span class=\"line\">    call.enqueue(…);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"对-Retrofit-进行封装（ServiceGenerator）\"><a href=\"#对-Retrofit-进行封装（ServiceGenerator）\" class=\"headerlink\" title=\"对 Retrofit 进行封装（ServiceGenerator）\"></a>对 Retrofit 进行封装（ServiceGenerator）</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// App 中的 BaseUrl，若更改 Url，即可在此直接修改。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BASE_URL = <span class=\"string\">\"https://api.github.com/\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Gson 转换器</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> GsonConverterFactory gsonFactory = GsonConverterFactory.create(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Retrofit.Builder builder = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">                    .baseUrl(BASE_URL)</span><br><span class=\"line\">                    .addConverterFactory(gsonFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Retrofit retrofit = builder.build();</span><br><span class=\"line\">    <span class=\"comment\">//自定义的登录拦截器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HttpLoggingInterceptor logging = <span class=\"keyword\">new</span> HttpLoggingInterceptor()</span><br><span class=\"line\">                    .setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class=\"line\">    <span class=\"comment\">//使用 OKHttp 进行网络请求</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> OkHttpClient.Builder httpClient =<span class=\"keyword\">new</span> OkHttpClient.Builder(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Api 接口泛型封装，参数：带注解配置的 Api 请求接口，返回即可执行网络请求。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; <span class=\"function\">S <span class=\"title\">createService</span><span class=\"params\">(Class&lt;S&gt; serviceClass)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//在此对 OKHttp 添加登录拦截器的拦截</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!httpClient.interceptors().contains(logging)) &#123;</span><br><span class=\"line\">            httpClient.addInterceptor(logging);</span><br><span class=\"line\">            builder.client(httpClient.build());</span><br><span class=\"line\">            retrofit = builder.build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> retrofit.create(serviceClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>上面的成员变量和成员方法都是 static （静态）的，原因是整个 App 进行网络请求也只要有一个出口就行，不需要那么多实例（节约资源），static（静态）方法和变量是加载该类的时候就已经加载了的，类对应的实例只有一个该静态变量，所以性能上比较快。</strong></p>\n<p>在经过封装后的 Retrofit 调用就非常简单了。之前的创建 GitHubClient 实例的例子等同于下面代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GitHubClient client = ServiceGenerator.createService(GitHubClient.class);<span class=\"comment\">//带注解配置的 Api 请求接口</span></span><br></pre></td></tr></table></figure>\n<p>上面只是一个简单的封装，在 App 中的所有网络请求都会经过 ServiceGenerator 类的 createService(Class&lt;S&dt; serviceClass) 方法，还有 Retrofit 进行网络请求的是 OKHttp ，所有我们可以在此类加入 <a href=\"https://github.com/square/okhttp/wiki/Interceptors\" target=\"_blank\" rel=\"noopener\">OKHttp 的拦截器</a> 进行对网络请求的<strong>请求（Request）</strong>和<strong>返回（Response）</strong>进行一些判断处理（是否登录等）。</p>\n<h5 id=\"如何公用一个-OKHttpClient-对不同-Url-进行请求以及设置不同的拦截器。\"><a href=\"#如何公用一个-OKHttpClient-对不同-Url-进行请求以及设置不同的拦截器。\" class=\"headerlink\" title=\"如何公用一个 OKHttpClient 对不同 Url 进行请求以及设置不同的拦截器。\"></a>如何公用一个 OKHttpClient 对不同 Url 进行请求以及设置不同的拦截器。</h5><ul>\n<li><p>OKHttp 只需要一个就行,多开会导致资源浪费，影响 App 性能。共用同一个 OKHttpClient 就是共用 RequestPool ，diskcache， routing logic 等等资源。</p>\n</li>\n<li><p>不同拦截器，比如登录拦截器，资源访问拦截器，权限拦截器等，但是他们的 Url 都是以 BaseUrl 为基础，但是又不相同的。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient baseOkHttpClient = <span class=\"keyword\">new</span> OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">OkHttpClient okHttpClientV1 = baseOkHttpClient  </span><br><span class=\"line\">        .newBuilder()</span><br><span class=\"line\">        .followRedirects(<span class=\"keyword\">false</span>)</span><br><span class=\"line\">        .build()</span><br><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofitApiV1 = <span class=\"keyword\">new</span> Retrofit.Builder()  </span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"https://futurestud.io/v1/\"</span>)</span><br><span class=\"line\">        .client(okHttpClientV1)</span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">OkHttpClient okHttpClientV2 = baseOkHttpClient  </span><br><span class=\"line\">        .newBuilder()</span><br><span class=\"line\">        .addInterceptor(...)</span><br><span class=\"line\">        .build()</span><br><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofitApiV2 = <span class=\"keyword\">new</span> Retrofit.Builder()  </span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"https://futurestud.io/v2/\"</span>)</span><br><span class=\"line\">        .client(okHttpClientV2)</span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<h5 id=\"同步请求与异步请求\"><a href=\"#同步请求与异步请求\" class=\"headerlink\" title=\"同步请求与异步请求\"></a>同步请求与异步请求</h5><ul>\n<li><p><strong>Retrofit 2 中的同步请求和异步请求的接口定义是一样的（没有区别），所以在使用 Retrofit 进行网络请求的时候，UI 线程（Main 线程）会阻塞。需要另开子线程进行网络请求（Retrofit 需要开发者自己实现异步）。</strong></p>\n<p>以 Call&lt;T&dt; 为接口方法的返回值，T 为根据返回数据的解析类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请求接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/tasks\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;Task&gt;&gt; getTasks();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同步请求和异步请求（相同）</span></span><br><span class=\"line\">TaskService taskService = ServiceGenerator.createService(TaskService.class);  </span><br><span class=\"line\">Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks();  </span><br><span class=\"line\">call.enqueue(<span class=\"keyword\">new</span> Callback&lt;List&lt;Task&gt;&gt;() &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;List&lt;Task&gt;&gt; call, Response&lt;List&lt;Task&gt;&gt; response)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;List&lt;Task&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Retrofit 1 中的同步请求接口方法返回值直接是经过解析后的值（对比 Retrofit 没有 Call 封装）；异步请求接口没有返回值（Void），但是在接口方法有接口回调 Callback&lt;T&dt; cb ，在 Callback 的 onResponse 和 onFailure 回调方法处理结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请求接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskService</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/tasks\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getTasks</span><span class=\"params\">(Callback&lt;List&lt;Task&gt;&gt; cb)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同步请求</span></span><br><span class=\"line\">TaskService taskService = ServiceGenerator.createService(TaskService.class);  </span><br><span class=\"line\">List&lt;Task&gt; tasks = taskService.getTasks();  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//异步请求</span></span><br><span class=\"line\">TaskService taskService = ServiceGenerator.createService(TaskService.class);  </span><br><span class=\"line\">taskService.getTasks(<span class=\"keyword\">new</span> Callback&lt;List&lt;Task&gt;&gt;() &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">success</span><span class=\"params\">(List&lt;Task&gt; tasks, Response response)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">failure</span><span class=\"params\">(RetrofitError error)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"获取原始的-Http-返回数据的方法。（Raw-Response）\"><a href=\"#获取原始的-Http-返回数据的方法。（Raw-Response）\" class=\"headerlink\" title=\"获取原始的 Http 返回数据的方法。（Raw Response）\"></a>获取原始的 Http 返回数据的方法。（Raw Response）</h5><ul>\n<li><p>上文提过，将 Call&lt;T&dt; 的返回类型设置成 ResponsBody，可以取到响应体的内容。也就是转换器的解析内容。</p>\n</li>\n<li><p>通过 response.raw() 获取原生返回数据（OKHttp 的 Response 内容）。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h5 id=\"简单介绍一下-Retrofit\"><a href=\"#简单介绍一下-Retrofit\" class=\"headerlink\" title=\"简单介绍一下 Retrofit\"></a>简单介绍一下 <a href=\"https://square.github.io/retrofit/\" target=\"_blank\" rel=\"noopener\">Retrofit</a></h5><ul>\n<li><p>Type-safe HTTP client for Android and Java by Square ，适用于 Android 和 Java 客户端进行网络请求。</p>\n</li>\n<li><p>通过注解描述 Http 请求，Url 参数和 Request 请求参数。</p>\n</li>\n<li><p>支持自定义 Header，多类型请求体，文件上传和下载，<strong>模仿服务器返回的 Response（Mocking Responses）</strong></p>\n</li>\n</ul>","more":"<h5 id=\"项目导入-Retrofit\"><a href=\"#项目导入-Retrofit\" class=\"headerlink\" title=\"项目导入 Retrofit\"></a>项目导入 Retrofit</h5><ul>\n<li><p>Gradle 文件添加依赖<strong>(Retrofit 1.9 以下版本需要自行添加 OKHttp 的依赖)</strong></p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:retrofit:2.4.0'</span> <span class=\"comment\">//Retrofit 的依赖包</span></span><br><span class=\"line\">implementation <span class=\"string\">'com.squareup.retrofit2:converter-gson:2.3.0'</span> <span class=\"comment\">// Retrofit 的 Gson 转换器依赖包</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加网络权限</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uses-permission</span> <span class=\"attr\">android:name</span>=<span class=\"string\">\"android.permission.INTERNET\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"使用-Retrofit-进行简单的网络请求（借用-Github-仓库接口）\"><a href=\"#使用-Retrofit-进行简单的网络请求（借用-Github-仓库接口）\" class=\"headerlink\" title=\"使用 Retrofit 进行简单的网络请求（借用 Github 仓库接口）\"></a>使用 Retrofit 进行简单的网络请求（借用 <a href=\"https://api.github.com/users/{user}/repos\" target=\"_blank\" rel=\"noopener\">Github 仓库接口</a>）</h5><ul>\n<li><p>定义进行网络请求的 Api 接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubClient</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//请求方法 GET，填入的是 url ，请求参数 user 对应接口方法 reposForUser 的 user 值</span></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/users/&#123;user&#125;/repos\"</span>) </span><br><span class=\"line\">    Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser(</span><br><span class=\"line\">            <span class=\"meta\">@Path</span>(<span class=\"string\">\"user\"</span>) String user</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>根据数据返回类型进行定义 Model （数据返回较多，选取部分进行解析）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GitHubRepo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GitHubRepo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进行网络请求（Request）和获取返回结果（Response）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 Retrofit 的构造器,通过构造器构造 Retrofit 实例</span></span><br><span class=\"line\">Retrofit retrofit = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">        <span class=\"comment\">//baseUrl 要与配置接口中的请求方法中的 url 拼接</span></span><br><span class=\"line\">        .baseUrl(API_BASE_URL) </span><br><span class=\"line\">        <span class=\"comment\">//转换器是 Gson 转换器，通过 GsonConverterFactory 获得</span></span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">        <span class=\"comment\">//使用 OKHttp 进行网络请求</span></span><br><span class=\"line\">        .client(NetWordStudyApplication.getHttpClient().build()) </span><br><span class=\"line\">        .build();</span><br><span class=\"line\"><span class=\"comment\">//获得对应接口的网络请求</span></span><br><span class=\"line\">GitHubClient client = retrofit.create(GitHubClient.class);</span><br><span class=\"line\"><span class=\"comment\">//进行网络请求，并且获取请求结果</span></span><br><span class=\"line\">Call&lt;List&lt;GitHubRepo&gt;&gt; call = client.reposForUser(<span class=\"string\">\"Xiao\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Callback 的泛型解释：经过 Gson 转换器通过此泛型对返回数据进行转换解析。</span></span><br><span class=\"line\">call.enqueue(<span class=\"keyword\">new</span> Callback&lt;List&lt;GitHubRepo&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;List&lt;GitHubRepo&gt;&gt; call, Response&lt;List&lt;GitHubRepo&gt;&gt; response)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//请求成功并返回结果在此进行处理，请求数据在 response.body() 里面（对应 Callback 泛型）</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;List&lt;GitHubRepo&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//请求失败，在此获取请求失败的 Throwable 原因等。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"使用-Java-注解来定义-Api-接口的内容\"><a href=\"#使用-Java-注解来定义-Api-接口的内容\" class=\"headerlink\" title=\"使用 Java 注解来定义 Api 接口的内容\"></a>使用 Java 注解来定义 Api 接口的内容</h5><p>通常，我们的 Api 接口都应该包含 3 部分：请求方法名字，返回类型，请求方法参数。</p>\n<ul>\n<li><p>请求方法：Retrofit 提供 5 种 Http 请求方法，使用注解：@GET, @POST, @PUT, @DELETE, @PATCH, @HEAD。具体功能是 <a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods\" target=\"_blank\" rel=\"noopener\">Http 协议</a>内容，在此不再累述。此外，你需要添加<strong>相对的 Api Url</strong> 作为请求方法的参数，因为 Retrofit 提供一个设置 baseUrl 的方法（优点：方便改变全局 Url ），也可以直接定义<strong>完整的 Api Url 路径</strong>，或者你不用直接定义 Url，而是通过参数传入，<strong>动态指定请求 Url</strong> 。</p>\n</li>\n<li><p>返回类型：Call<t> 中的泛型 T ，就是 Converter（Retrofit 转换器）通过解析请求 Api 接口的返回数据成的实例。假如想获得原始数据，而不是解析出来的数据，则该泛型 T 应该设置为 ResponseBody 。或者你根本不需要知道此请求的结果，也可以将泛型 T 设置为 Void 。</t></p>\n</li>\n<li><p>请求方法参数：</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">请求方法参数注解</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">@Body</td>\n<td style=\"text-align:center\">将 Java 对象进行解析作为请求体（Request Body）发送（当转换器为 GSON ，解析成 JSON）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Url</td>\n<td style=\"text-align:center\">动态传入的 Url</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Filed</td>\n<td style=\"text-align:center\">将数据作为 Form 表单发送</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@Header</td>\n<td style=\"text-align:center\">动态为请求加上头部（Request Header ）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">@HeaderMap</td>\n<td style=\"text-align:center\">动态为请求加上头部集合（Request Header ）</td>\n</tr>\n</tbody>\n</table>\n<p>  以下是对应的一些例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FutureStudioClient</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/user/info\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;UserInfo&gt; <span class=\"title\">getUserInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PUT</span>(<span class=\"string\">\"/user/info\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;UserInfo&gt; <span class=\"title\">updateUserInfo</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Body UserInfo userInfo</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@DELETE</span>(<span class=\"string\">\"/user\"</span>)</span><br><span class=\"line\">    <span class=\"function\">Call&lt;Void&gt; <span class=\"title\">deleteUser</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"https://futurestud.io/tutorials/rss/\"</span>) <span class=\"comment\">//完整的 Api Url 路径</span></span><br><span class=\"line\">    <span class=\"function\">Call&lt;FutureStudioRssFeed&gt; <span class=\"title\">getRssFeed</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GET</span></span><br><span class=\"line\">    <span class=\"function\">Call&lt;ResponseBody&gt; <span class=\"title\">getUserProfilePhoto</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        @Url String profilePhotoUrl //动态传入 Url</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    )</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Api 的请求参数：一般来说，我们的 Api 请求方法是 GET 和 POST，GET 的请求参数是直接拼接在 Url 进行请求，而 POST 的请求参数是放在 Body 里面进行请求。</p>\n<ul>\n<li><p>Api Url 为 <a href=\"https://api.github.com/users/{user}/repos\" target=\"_blank\" rel=\"noopener\">https://api.github.com/users/{user}/repos</a> （<strong>REST APIs</strong>）这种占位符形式，使用 @Path 让接口方法的参数替换在 Url 中  {user} 的值。例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">GitHubClient</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/users/&#123;user&#125;/repos\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;GitHubRepo&gt;&gt; reposForUser(</span><br><span class=\"line\">        <span class=\"meta\">@Path</span>(<span class=\"string\">\"user\"</span>) String user</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Api Url 为：<a href=\"https://futurestud.io/tutorials?page=page&amp;order=order&amp;author=author&amp;published_at=date\" target=\"_blank\" rel=\"noopener\">https://futurestud.io/tutorials?page=page&amp;order=order&amp;author=author&amp;published_at=date</a> ，其中 ?Xxx=xxx 就是以一种键值对的形式传入。此时可以使用 @Query 将接口方法参数拼接成这种形式的 Url 。例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">NewsService</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/news\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;News&gt;&gt; getNews(</span><br><span class=\"line\">            <span class=\"meta\">@Query</span>(<span class=\"string\">\"page\"</span>) <span class=\"keyword\">int</span> page,</span><br><span class=\"line\">            <span class=\"meta\">@Query</span>(<span class=\"string\">\"order\"</span>) String order,</span><br><span class=\"line\">            <span class=\"meta\">@Query</span>(<span class=\"string\">\"author\"</span>) String author,</span><br><span class=\"line\">            <span class=\"meta\">@Query</span>(<span class=\"string\">\"published_at\"</span>) Date date,</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，多个请求参数可以使用 @QueryMap，上面请求参数的表现形式等同于：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> interface <span class=\"title\">NewsService</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/news\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;News&gt;&gt; getNews(</span><br><span class=\"line\">        <span class=\"meta\">@QueryMap</span> Map&lt;String, String&gt; options</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fetchNews</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    Map&lt;String, String&gt; data = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    data.put(<span class=\"string\">\"author\"</span>, <span class=\"string\">\"Marcus\"</span>);</span><br><span class=\"line\">    data.put(<span class=\"string\">\"page\"</span>, String.valueOf(<span class=\"number\">2</span>));</span><br><span class=\"line\">    <span class=\"comment\">//.....</span></span><br><span class=\"line\">    Call&lt;List&lt;News&gt;&gt; call = newsService.getNews(data);</span><br><span class=\"line\">    call.enqueue(…);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"对-Retrofit-进行封装（ServiceGenerator）\"><a href=\"#对-Retrofit-进行封装（ServiceGenerator）\" class=\"headerlink\" title=\"对 Retrofit 进行封装（ServiceGenerator）\"></a>对 Retrofit 进行封装（ServiceGenerator）</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServiceGenerator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// App 中的 BaseUrl，若更改 Url，即可在此直接修改。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String BASE_URL = <span class=\"string\">\"https://api.github.com/\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Gson 转换器</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> GsonConverterFactory gsonFactory = GsonConverterFactory.create(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Retrofit.Builder builder = <span class=\"keyword\">new</span> Retrofit.Builder()</span><br><span class=\"line\">                    .baseUrl(BASE_URL)</span><br><span class=\"line\">                    .addConverterFactory(gsonFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Retrofit retrofit = builder.build();</span><br><span class=\"line\">    <span class=\"comment\">//自定义的登录拦截器</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> HttpLoggingInterceptor logging = <span class=\"keyword\">new</span> HttpLoggingInterceptor()</span><br><span class=\"line\">                    .setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class=\"line\">    <span class=\"comment\">//使用 OKHttp 进行网络请求</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> OkHttpClient.Builder httpClient =<span class=\"keyword\">new</span> OkHttpClient.Builder(); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Api 接口泛型封装，参数：带注解配置的 Api 请求接口，返回即可执行网络请求。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;S&gt; <span class=\"function\">S <span class=\"title\">createService</span><span class=\"params\">(Class&lt;S&gt; serviceClass)</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//在此对 OKHttp 添加登录拦截器的拦截</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (!httpClient.interceptors().contains(logging)) &#123;</span><br><span class=\"line\">            httpClient.addInterceptor(logging);</span><br><span class=\"line\">            builder.client(httpClient.build());</span><br><span class=\"line\">            retrofit = builder.build();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> retrofit.create(serviceClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>上面的成员变量和成员方法都是 static （静态）的，原因是整个 App 进行网络请求也只要有一个出口就行，不需要那么多实例（节约资源），static（静态）方法和变量是加载该类的时候就已经加载了的，类对应的实例只有一个该静态变量，所以性能上比较快。</strong></p>\n<p>在经过封装后的 Retrofit 调用就非常简单了。之前的创建 GitHubClient 实例的例子等同于下面代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GitHubClient client = ServiceGenerator.createService(GitHubClient.class);<span class=\"comment\">//带注解配置的 Api 请求接口</span></span><br></pre></td></tr></table></figure>\n<p>上面只是一个简单的封装，在 App 中的所有网络请求都会经过 ServiceGenerator 类的 createService(Class&lt;S&dt; serviceClass) 方法，还有 Retrofit 进行网络请求的是 OKHttp ，所有我们可以在此类加入 <a href=\"https://github.com/square/okhttp/wiki/Interceptors\" target=\"_blank\" rel=\"noopener\">OKHttp 的拦截器</a> 进行对网络请求的<strong>请求（Request）</strong>和<strong>返回（Response）</strong>进行一些判断处理（是否登录等）。</p>\n<h5 id=\"如何公用一个-OKHttpClient-对不同-Url-进行请求以及设置不同的拦截器。\"><a href=\"#如何公用一个-OKHttpClient-对不同-Url-进行请求以及设置不同的拦截器。\" class=\"headerlink\" title=\"如何公用一个 OKHttpClient 对不同 Url 进行请求以及设置不同的拦截器。\"></a>如何公用一个 OKHttpClient 对不同 Url 进行请求以及设置不同的拦截器。</h5><ul>\n<li><p>OKHttp 只需要一个就行,多开会导致资源浪费，影响 App 性能。共用同一个 OKHttpClient 就是共用 RequestPool ，diskcache， routing logic 等等资源。</p>\n</li>\n<li><p>不同拦截器，比如登录拦截器，资源访问拦截器，权限拦截器等，但是他们的 Url 都是以 BaseUrl 为基础，但是又不相同的。</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OkHttpClient baseOkHttpClient = <span class=\"keyword\">new</span> OkHttpClient();</span><br><span class=\"line\"></span><br><span class=\"line\">OkHttpClient okHttpClientV1 = baseOkHttpClient  </span><br><span class=\"line\">        .newBuilder()</span><br><span class=\"line\">        .followRedirects(<span class=\"keyword\">false</span>)</span><br><span class=\"line\">        .build()</span><br><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofitApiV1 = <span class=\"keyword\">new</span> Retrofit.Builder()  </span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"https://futurestud.io/v1/\"</span>)</span><br><span class=\"line\">        .client(okHttpClientV1)</span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"></span><br><span class=\"line\">OkHttpClient okHttpClientV2 = baseOkHttpClient  </span><br><span class=\"line\">        .newBuilder()</span><br><span class=\"line\">        .addInterceptor(...)</span><br><span class=\"line\">        .build()</span><br><span class=\"line\"></span><br><span class=\"line\">Retrofit retrofitApiV2 = <span class=\"keyword\">new</span> Retrofit.Builder()  </span><br><span class=\"line\">        .baseUrl(<span class=\"string\">\"https://futurestud.io/v2/\"</span>)</span><br><span class=\"line\">        .client(okHttpClientV2)</span><br><span class=\"line\">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class=\"line\">        .build();</span><br></pre></td></tr></table></figure>\n<h5 id=\"同步请求与异步请求\"><a href=\"#同步请求与异步请求\" class=\"headerlink\" title=\"同步请求与异步请求\"></a>同步请求与异步请求</h5><ul>\n<li><p><strong>Retrofit 2 中的同步请求和异步请求的接口定义是一样的（没有区别），所以在使用 Retrofit 进行网络请求的时候，UI 线程（Main 线程）会阻塞。需要另开子线程进行网络请求（Retrofit 需要开发者自己实现异步）。</strong></p>\n<p>以 Call&lt;T&dt; 为接口方法的返回值，T 为根据返回数据的解析类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请求接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/tasks\"</span>)</span><br><span class=\"line\">    Call&lt;List&lt;Task&gt;&gt; getTasks();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同步请求和异步请求（相同）</span></span><br><span class=\"line\">TaskService taskService = ServiceGenerator.createService(TaskService.class);  </span><br><span class=\"line\">Call&lt;List&lt;Task&gt;&gt; call = taskService.getTasks();  </span><br><span class=\"line\">call.enqueue(<span class=\"keyword\">new</span> Callback&lt;List&lt;Task&gt;&gt;() &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(Call&lt;List&lt;Task&gt;&gt; call, Response&lt;List&lt;Task&gt;&gt; response)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Call&lt;List&lt;Task&gt;&gt; call, Throwable t)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Retrofit 1 中的同步请求接口方法返回值直接是经过解析后的值（对比 Retrofit 没有 Call 封装）；异步请求接口没有返回值（Void），但是在接口方法有接口回调 Callback&lt;T&dt; cb ，在 Callback 的 onResponse 和 onFailure 回调方法处理结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请求接口定义</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskService</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"meta\">@GET</span>(<span class=\"string\">\"/tasks\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">getTasks</span><span class=\"params\">(Callback&lt;List&lt;Task&gt;&gt; cb)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同步请求</span></span><br><span class=\"line\">TaskService taskService = ServiceGenerator.createService(TaskService.class);  </span><br><span class=\"line\">List&lt;Task&gt; tasks = taskService.getTasks();  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//异步请求</span></span><br><span class=\"line\">TaskService taskService = ServiceGenerator.createService(TaskService.class);  </span><br><span class=\"line\">taskService.getTasks(<span class=\"keyword\">new</span> Callback&lt;List&lt;Task&gt;&gt;() &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">success</span><span class=\"params\">(List&lt;Task&gt; tasks, Response response)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">failure</span><span class=\"params\">(RetrofitError error)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"获取原始的-Http-返回数据的方法。（Raw-Response）\"><a href=\"#获取原始的-Http-返回数据的方法。（Raw-Response）\" class=\"headerlink\" title=\"获取原始的 Http 返回数据的方法。（Raw Response）\"></a>获取原始的 Http 返回数据的方法。（Raw Response）</h5><ul>\n<li><p>上文提过，将 Call&lt;T&dt; 的返回类型设置成 ResponsBody，可以取到响应体的内容。也就是转换器的解析内容。</p>\n</li>\n<li><p>通过 response.raw() 获取原生返回数据（OKHttp 的 Response 内容）。</p>\n</li>\n</ul>"},{"title":"JAVA 基础","date":"2018-11-27T06:51:37.353Z","_content":"### [JAVA 内存](https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md)\n  - 静态存储区：存放静态数据，全局 static 数据和常量，编译器已经分配内存并且在程序运行期间都存在。\n  - 栈区：存放方法内部的局部变量，在方法执行结束后局部变量的内存就被释放，效率高但是分配内存容量有限。\n  - 堆区：存放 new 出来的对象实例，这个实例不使用时就会被 GC 回收。\n  ```JAVA\n  public class Sample {\n    //s1 和 0 内存都存放在堆中\n      int s1 = 0;\n      //mSample1 和 mSample1 所指的对象内存都存放在堆中\n      Sample mSample1 = new Sample();\n\n      public void method() {\n          // s2 存在于栈中\n          int s2 = 1;\n          //引用 mSample2 存放于栈中，但 mSample2 指的对象内存存放于堆中\n          Sample mSample2 = new Sample();\n      }\n  }\n  //引用 mSample3存放于栈中，但是 mSample3 所指对象存放于堆中，包括对象内部的成员变量 s1，mSample1 都在堆中\n  Sample mSample3 = new Sample();\n  ```\n  **结论：局部变量的基本数据类型和引用存放于栈，引用所指的对象和类的成员变量存放于堆中（包括引用和引用指的对象）。**\n  - Java 的内存管理\n    1. 内存的分配由程序员来完成，即程序调用 new 方法或通过反射来分配内存。\n    2. 内存的回收是由垃圾回收器（GC）完成的，对象不再被引用，该对象的内存就被释放回收。\n  - JAVA 内存泄漏\n    1. 简单介绍：指的是在程序中，存在相对程序逻辑来说已经无用的对象，但是由于对象一直被引用者导致无法被垃圾回收器释放回收，这些对象会在程序运行期间一直占着内存。\n    2. **内存泄漏的原因**\n      - **静态集合** 引用的所有对象 Object 在程序运行期间都无法释放。\n      - 集合里面的对象属性被修改后再调用 remove() 方法无效（如 hashcode 不同无法 remove）。\n      - **监听器没有释放** ，导致该监听的实体没有被释放。\n      - **数据库连接，网络连接和 IO 连接** ，即涉及流操作都没有显式调用 close() 方法，GC 不会回收。\n      - **内部类和外部模块的引用**，非静态的内部类和匿名类会隐式地持有一个他们外部类的引用，当外部类对象已经相对程序无作用时，非静态得内部类和匿名类引用着外部类，导致外部类对象无法被回收释放。\n      - **单例模式** ， 单例模式在初始化后在程序运行期间都是存在的，如果单例模式持有外部对象得引用，则会导致外部对象无法释放回收。\n---\n### JAVA 集合\n- Map\n  主要的实现类有：HashMap， HashTable， LinkedHashMap，TreeMap。\n  1. HashMap根据 Key 的 HashCode 来存储数据，只允许一个 Key 为 Null，但允许多条记录为 Null，HashMap 线程不安全。可以使用 Collections.synchronizedMap() 方法来使HashMap 具有线程安全，或者直接使用 **ConcurrentHashMap** 代替。\n  2. HashTable 和 HashMap 的功能差不多，但是它是性能安全的。\n  3. LinkedHashMap 是 HashMap 的子类，保存插入顺序，也就是说它是有序的，可以通过 Iterator 迭代器遍历 LinkedHashMap。\n  4. TreeMap实现 SortedMap 接口，内部有序，顺序是按照 Key 的升序排序，也可以自己实现排序的比较器（Comparable 接口）。用 Iterator 遍历也是有序的。\n- [HashMap](https://tech.meituan.com/java_hashmap.html)\n  1.  HashMap 按照 **Lazy-Load** 来进行初始化，通过 resize() 来进行初始化一个 HashMap 和对 HashMap 进行扩容。\n  2. 键值对在 HashMap 内的位置 index 取决于位运算 **i = (n -1) & hash（n 为 table 长度）**;\n  3. 如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Loadfactor 的值，门限值降低，table 数组就容易扩容，但是每个数组上的链表就会相对短，查询就快；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 loadFactor 的值，（loadFactor 可以大于1，但是建议不超过 0.75，默认值 0.75 符合大多数场景）。\n  4. 而当链表长度太长（ **默认超过8** ）时，链表就转换为 **红黑树** ，利用红黑树快速增删改查的特点提高 HashMap 的性能。\n  5. **门限值（threshold） = 负载因子(loadfactor) * 容量（capacity）**，在元素个数超过门限值时（size > threshold），调整 Map 的大小，table 的长度使用的是 2 次幂扩展(指长度扩为原来 2 倍)，同理根据门限值的计算公式可以计算出门限值也是原来 2 倍。 **扩容非常耗性能，所以在使用 HashMap 时最好给一个大致的 size，避免频繁扩容**。\n  6. 扩容对应的键的 hash 计算\n    - jdk 7：重新计算 hash 值来获取索引值。\n    - jdk 8：只需要看看原来的hash值新增的那个bit是1还是0就好了，是 **0** 的话索引 **不变** ，是 **1** 的话索引变成 **“原索引+oldCap”**\n\n    ![img](https://github.com/0HongTao0/Blog/blob/master/pic/HashMap_%E4%B8%8D%E5%90%8CJDK%E6%89%A9%E5%AE%B9%E6%AF%94%E8%BE%83.png?raw=true)\n  7. 线程安全问题：\n    HashMap 是线程不安全的，为什么呢？\n    并发的多线程使用场景中使用 HashMap 可能造成死循环，因为在 resize 过程中会导致出现环形链表。\n---\n### JAVA 并发\n\n- 如何创建多线程？\n\n  主要有 2 种方法\n\n  1. 创建一个子类继承（extends） Thread 类，然后重写 run（）方法。\n  2. 创建一个子类实现（implement）Runnable 接口，然后重写 run（）方法。\n\n- 简述线程的五种状态\n\n  1. 线程的五种状态分别是：新建（New），就绪（Runnable），运行（Running），终止（Dead），阻塞（Blocked）\n\n  2. 线程没被阻塞从新建状态到终止状态的过程：从线程被 new 创建开始，线程就进入**新建**状态，当程序调用 Thread.start() 方法的时候，线程进入**就绪**状态，因为 JAVA 线程的调度是抢占式调度，所以在这个时候线程有可能正在运行也可能没有运行，当操作系统分配时间片给线程的时候，线程进入**运行**状态，当 Thread.run() 方法执行到最后一条语句并返回的时候，线程自然死亡，进入**终止**状态。\n\n  3. 线程被阻塞即从**就绪**状态转至**阻塞**状态，导致线程进入阻塞状态的原因主要有 3 个，**同步阻塞**，当线程获取一个被其他线程所持有的对象锁，线程进入阻塞状态。线程执行 **Thread.sleep()** 方法，以及 **Thread.wait()** 方法。当线程在阻塞状态被激活的时候，线程进入**就绪**状态，等待系统调度进入**运行**状态。\n\n     ![img](https://upload-images.jianshu.io/upload_images/5545289-1c4500c4a5adaafe.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/527/format/webp)\n\n- 如何中断正在执行的线程\n\n  1. 执行完 run（）方法的最后一条语句并由 return 返回时，线程终止。\n  2. 当线程run（）方法种出现了没有捕获分异常时，线程终止。\n\n  没有方法可以强制终止线程，但是可以用 Thread.interrupt() 方法来请求终止线程。线程有个中断状态的 Boolean 标志，不停地检查该标志，线程阻塞无法检查中断状态所以不能在线程阻塞的时候调用 Thread.interrupt() 方法（会抛出 InterruptedException）。\n\n- 锁的相关理解\n\n  1. 锁是防止程序代码块中受并发访问而造成不安全的干扰，即保证任何时刻只能有一个线程执行被保护的代码。\n  2. 大多数情况下是通过 synchronized 关键字来实现锁，在 JAVA 中每一个对象都存在一个锁，**synchronized 用在方法上**，是锁住当前对象的当前方法，多个线程访问这个对象的该方法会被阻塞；**synchronized(this)** 锁住的是当前对象的，多个线程访问这个对象会被阻塞；同理可得 **synchronized(object)** 锁的是 object 对象，多个线程访问该对象会被阻塞；（注意：锁的对象不能是 final 类，因为经过修改的 final 类会是一个新对象，无法获取同一个锁）\n  3. 也可以通过 JAVA 提供的 Lock 类来实现锁。\n\n---\n### JAVA 代理\n  - 静态代理：代码 **运行之前** 代理类的 Class 编译文件就已经存在。\n  实现思路：通过代理者和被代理者实现同一接口，并且代理者种存在一个被代理者的实例，即调用方通过代理者间接调用被代理者的方法。\n  - 动态代理：代码 **运行过程** 通过反射机制直接生成代理者对象。\n  实现思路：通过 java.lang.reflect 的 Proxy 实现，有 3 个参数。\n  ClassLoder: 类加载器\n  Class<?>[]: 对象组\n  InvocationHandler: **调用处理器,无论何时调用代理对象的方法调用处理器的 invoke 方法都会被调用。**\n  ```java\n    public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces, InvocationHandler h){}\n\n    public class DynamicProxy implements InvocationHandler{\n      private Object obj;//被代理的类引用\n\n      public DynamicProxy(Object obj){\n        this.obj = obj;\n      }\n\n      @Override\n      public Object invoke(Object proxy, Method method, Object[] args) throw Throwable{\n        Object result = method.invoke(obj, args);\n        return result;\n      }\n    }\n  ```\n","source":"_posts/JAVA 基础.md","raw":"title: JAVA 基础\ndate: 2018-11-30 14.00\ntags:\n\n------\n### [JAVA 内存](https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md)\n  - 静态存储区：存放静态数据，全局 static 数据和常量，编译器已经分配内存并且在程序运行期间都存在。\n  - 栈区：存放方法内部的局部变量，在方法执行结束后局部变量的内存就被释放，效率高但是分配内存容量有限。\n  - 堆区：存放 new 出来的对象实例，这个实例不使用时就会被 GC 回收。\n  ```JAVA\n  public class Sample {\n    //s1 和 0 内存都存放在堆中\n      int s1 = 0;\n      //mSample1 和 mSample1 所指的对象内存都存放在堆中\n      Sample mSample1 = new Sample();\n\n      public void method() {\n          // s2 存在于栈中\n          int s2 = 1;\n          //引用 mSample2 存放于栈中，但 mSample2 指的对象内存存放于堆中\n          Sample mSample2 = new Sample();\n      }\n  }\n  //引用 mSample3存放于栈中，但是 mSample3 所指对象存放于堆中，包括对象内部的成员变量 s1，mSample1 都在堆中\n  Sample mSample3 = new Sample();\n  ```\n  **结论：局部变量的基本数据类型和引用存放于栈，引用所指的对象和类的成员变量存放于堆中（包括引用和引用指的对象）。**\n  - Java 的内存管理\n    1. 内存的分配由程序员来完成，即程序调用 new 方法或通过反射来分配内存。\n    2. 内存的回收是由垃圾回收器（GC）完成的，对象不再被引用，该对象的内存就被释放回收。\n  - JAVA 内存泄漏\n    1. 简单介绍：指的是在程序中，存在相对程序逻辑来说已经无用的对象，但是由于对象一直被引用者导致无法被垃圾回收器释放回收，这些对象会在程序运行期间一直占着内存。\n    2. **内存泄漏的原因**\n      - **静态集合** 引用的所有对象 Object 在程序运行期间都无法释放。\n      - 集合里面的对象属性被修改后再调用 remove() 方法无效（如 hashcode 不同无法 remove）。\n      - **监听器没有释放** ，导致该监听的实体没有被释放。\n      - **数据库连接，网络连接和 IO 连接** ，即涉及流操作都没有显式调用 close() 方法，GC 不会回收。\n      - **内部类和外部模块的引用**，非静态的内部类和匿名类会隐式地持有一个他们外部类的引用，当外部类对象已经相对程序无作用时，非静态得内部类和匿名类引用着外部类，导致外部类对象无法被回收释放。\n      - **单例模式** ， 单例模式在初始化后在程序运行期间都是存在的，如果单例模式持有外部对象得引用，则会导致外部对象无法释放回收。\n---\n### JAVA 集合\n- Map\n  主要的实现类有：HashMap， HashTable， LinkedHashMap，TreeMap。\n  1. HashMap根据 Key 的 HashCode 来存储数据，只允许一个 Key 为 Null，但允许多条记录为 Null，HashMap 线程不安全。可以使用 Collections.synchronizedMap() 方法来使HashMap 具有线程安全，或者直接使用 **ConcurrentHashMap** 代替。\n  2. HashTable 和 HashMap 的功能差不多，但是它是性能安全的。\n  3. LinkedHashMap 是 HashMap 的子类，保存插入顺序，也就是说它是有序的，可以通过 Iterator 迭代器遍历 LinkedHashMap。\n  4. TreeMap实现 SortedMap 接口，内部有序，顺序是按照 Key 的升序排序，也可以自己实现排序的比较器（Comparable 接口）。用 Iterator 遍历也是有序的。\n- [HashMap](https://tech.meituan.com/java_hashmap.html)\n  1.  HashMap 按照 **Lazy-Load** 来进行初始化，通过 resize() 来进行初始化一个 HashMap 和对 HashMap 进行扩容。\n  2. 键值对在 HashMap 内的位置 index 取决于位运算 **i = (n -1) & hash（n 为 table 长度）**;\n  3. 如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Loadfactor 的值，门限值降低，table 数组就容易扩容，但是每个数组上的链表就会相对短，查询就快；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 loadFactor 的值，（loadFactor 可以大于1，但是建议不超过 0.75，默认值 0.75 符合大多数场景）。\n  4. 而当链表长度太长（ **默认超过8** ）时，链表就转换为 **红黑树** ，利用红黑树快速增删改查的特点提高 HashMap 的性能。\n  5. **门限值（threshold） = 负载因子(loadfactor) * 容量（capacity）**，在元素个数超过门限值时（size > threshold），调整 Map 的大小，table 的长度使用的是 2 次幂扩展(指长度扩为原来 2 倍)，同理根据门限值的计算公式可以计算出门限值也是原来 2 倍。 **扩容非常耗性能，所以在使用 HashMap 时最好给一个大致的 size，避免频繁扩容**。\n  6. 扩容对应的键的 hash 计算\n    - jdk 7：重新计算 hash 值来获取索引值。\n    - jdk 8：只需要看看原来的hash值新增的那个bit是1还是0就好了，是 **0** 的话索引 **不变** ，是 **1** 的话索引变成 **“原索引+oldCap”**\n\n    ![img](https://github.com/0HongTao0/Blog/blob/master/pic/HashMap_%E4%B8%8D%E5%90%8CJDK%E6%89%A9%E5%AE%B9%E6%AF%94%E8%BE%83.png?raw=true)\n  7. 线程安全问题：\n    HashMap 是线程不安全的，为什么呢？\n    并发的多线程使用场景中使用 HashMap 可能造成死循环，因为在 resize 过程中会导致出现环形链表。\n---\n### JAVA 并发\n\n- 如何创建多线程？\n\n  主要有 2 种方法\n\n  1. 创建一个子类继承（extends） Thread 类，然后重写 run（）方法。\n  2. 创建一个子类实现（implement）Runnable 接口，然后重写 run（）方法。\n\n- 简述线程的五种状态\n\n  1. 线程的五种状态分别是：新建（New），就绪（Runnable），运行（Running），终止（Dead），阻塞（Blocked）\n\n  2. 线程没被阻塞从新建状态到终止状态的过程：从线程被 new 创建开始，线程就进入**新建**状态，当程序调用 Thread.start() 方法的时候，线程进入**就绪**状态，因为 JAVA 线程的调度是抢占式调度，所以在这个时候线程有可能正在运行也可能没有运行，当操作系统分配时间片给线程的时候，线程进入**运行**状态，当 Thread.run() 方法执行到最后一条语句并返回的时候，线程自然死亡，进入**终止**状态。\n\n  3. 线程被阻塞即从**就绪**状态转至**阻塞**状态，导致线程进入阻塞状态的原因主要有 3 个，**同步阻塞**，当线程获取一个被其他线程所持有的对象锁，线程进入阻塞状态。线程执行 **Thread.sleep()** 方法，以及 **Thread.wait()** 方法。当线程在阻塞状态被激活的时候，线程进入**就绪**状态，等待系统调度进入**运行**状态。\n\n     ![img](https://upload-images.jianshu.io/upload_images/5545289-1c4500c4a5adaafe.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/527/format/webp)\n\n- 如何中断正在执行的线程\n\n  1. 执行完 run（）方法的最后一条语句并由 return 返回时，线程终止。\n  2. 当线程run（）方法种出现了没有捕获分异常时，线程终止。\n\n  没有方法可以强制终止线程，但是可以用 Thread.interrupt() 方法来请求终止线程。线程有个中断状态的 Boolean 标志，不停地检查该标志，线程阻塞无法检查中断状态所以不能在线程阻塞的时候调用 Thread.interrupt() 方法（会抛出 InterruptedException）。\n\n- 锁的相关理解\n\n  1. 锁是防止程序代码块中受并发访问而造成不安全的干扰，即保证任何时刻只能有一个线程执行被保护的代码。\n  2. 大多数情况下是通过 synchronized 关键字来实现锁，在 JAVA 中每一个对象都存在一个锁，**synchronized 用在方法上**，是锁住当前对象的当前方法，多个线程访问这个对象的该方法会被阻塞；**synchronized(this)** 锁住的是当前对象的，多个线程访问这个对象会被阻塞；同理可得 **synchronized(object)** 锁的是 object 对象，多个线程访问该对象会被阻塞；（注意：锁的对象不能是 final 类，因为经过修改的 final 类会是一个新对象，无法获取同一个锁）\n  3. 也可以通过 JAVA 提供的 Lock 类来实现锁。\n\n---\n### JAVA 代理\n  - 静态代理：代码 **运行之前** 代理类的 Class 编译文件就已经存在。\n  实现思路：通过代理者和被代理者实现同一接口，并且代理者种存在一个被代理者的实例，即调用方通过代理者间接调用被代理者的方法。\n  - 动态代理：代码 **运行过程** 通过反射机制直接生成代理者对象。\n  实现思路：通过 java.lang.reflect 的 Proxy 实现，有 3 个参数。\n  ClassLoder: 类加载器\n  Class<?>[]: 对象组\n  InvocationHandler: **调用处理器,无论何时调用代理对象的方法调用处理器的 invoke 方法都会被调用。**\n  ```java\n    public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces, InvocationHandler h){}\n\n    public class DynamicProxy implements InvocationHandler{\n      private Object obj;//被代理的类引用\n\n      public DynamicProxy(Object obj){\n        this.obj = obj;\n      }\n\n      @Override\n      public Object invoke(Object proxy, Method method, Object[] args) throw Throwable{\n        Object result = method.invoke(obj, args);\n        return result;\n      }\n    }\n  ```\n","slug":"JAVA 基础","published":1,"updated":"2018-12-07T00:28:24.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzc90005s8o5y5gp3735","content":"<h3 id=\"JAVA-内存\"><a href=\"#JAVA-内存\" class=\"headerlink\" title=\"JAVA 内存\"></a><a href=\"https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md\" target=\"_blank\" rel=\"noopener\">JAVA 内存</a></h3><ul>\n<li>静态存储区：存放静态数据，全局 static 数据和常量，编译器已经分配内存并且在程序运行期间都存在。</li>\n<li>栈区：存放方法内部的局部变量，在方法执行结束后局部变量的内存就被释放，效率高但是分配内存容量有限。</li>\n<li><p>堆区：存放 new 出来的对象实例，这个实例不使用时就会被 GC 回收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//s1 和 0 内存都存放在堆中</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> s1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//mSample1 和 mSample1 所指的对象内存都存放在堆中</span></span><br><span class=\"line\">    Sample mSample1 = <span class=\"keyword\">new</span> Sample();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// s2 存在于栈中</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> s2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//引用 mSample2 存放于栈中，但 mSample2 指的对象内存存放于堆中</span></span><br><span class=\"line\">        Sample mSample2 = <span class=\"keyword\">new</span> Sample();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//引用 mSample3存放于栈中，但是 mSample3 所指对象存放于堆中，包括对象内部的成员变量 s1，mSample1 都在堆中</span></span><br><span class=\"line\">Sample mSample3 = <span class=\"keyword\">new</span> Sample();</span><br></pre></td></tr></table></figure>\n<p><strong>结论：局部变量的基本数据类型和引用存放于栈，引用所指的对象和类的成员变量存放于堆中（包括引用和引用指的对象）。</strong></p>\n</li>\n<li>Java 的内存管理<ol>\n<li>内存的分配由程序员来完成，即程序调用 new 方法或通过反射来分配内存。</li>\n<li>内存的回收是由垃圾回收器（GC）完成的，对象不再被引用，该对象的内存就被释放回收。</li>\n</ol>\n</li>\n<li>JAVA 内存泄漏<ol>\n<li>简单介绍：指的是在程序中，存在相对程序逻辑来说已经无用的对象，但是由于对象一直被引用者导致无法被垃圾回收器释放回收，这些对象会在程序运行期间一直占着内存。</li>\n<li><strong>内存泄漏的原因</strong><ul>\n<li><strong>静态集合</strong> 引用的所有对象 Object 在程序运行期间都无法释放。</li>\n<li>集合里面的对象属性被修改后再调用 remove() 方法无效（如 hashcode 不同无法 remove）。</li>\n<li><strong>监听器没有释放</strong> ，导致该监听的实体没有被释放。</li>\n<li><strong>数据库连接，网络连接和 IO 连接</strong> ，即涉及流操作都没有显式调用 close() 方法，GC 不会回收。</li>\n<li><strong>内部类和外部模块的引用</strong>，非静态的内部类和匿名类会隐式地持有一个他们外部类的引用，当外部类对象已经相对程序无作用时，非静态得内部类和匿名类引用着外部类，导致外部类对象无法被回收释放。</li>\n<li><strong>单例模式</strong> ， 单例模式在初始化后在程序运行期间都是存在的，如果单例模式持有外部对象得引用，则会导致外部对象无法释放回收。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"JAVA-集合\"><a href=\"#JAVA-集合\" class=\"headerlink\" title=\"JAVA 集合\"></a>JAVA 集合</h3><ul>\n<li>Map<br>主要的实现类有：HashMap， HashTable， LinkedHashMap，TreeMap。<ol>\n<li>HashMap根据 Key 的 HashCode 来存储数据，只允许一个 Key 为 Null，但允许多条记录为 Null，HashMap 线程不安全。可以使用 Collections.synchronizedMap() 方法来使HashMap 具有线程安全，或者直接使用 <strong>ConcurrentHashMap</strong> 代替。</li>\n<li>HashTable 和 HashMap 的功能差不多，但是它是性能安全的。</li>\n<li>LinkedHashMap 是 HashMap 的子类，保存插入顺序，也就是说它是有序的，可以通过 Iterator 迭代器遍历 LinkedHashMap。</li>\n<li>TreeMap实现 SortedMap 接口，内部有序，顺序是按照 Key 的升序排序，也可以自己实现排序的比较器（Comparable 接口）。用 Iterator 遍历也是有序的。</li>\n</ol>\n</li>\n<li><p><a href=\"https://tech.meituan.com/java_hashmap.html\" target=\"_blank\" rel=\"noopener\">HashMap</a></p>\n<ol>\n<li>HashMap 按照 <strong>Lazy-Load</strong> 来进行初始化，通过 resize() 来进行初始化一个 HashMap 和对 HashMap 进行扩容。</li>\n<li>键值对在 HashMap 内的位置 index 取决于位运算 <strong>i = (n -1) &amp; hash（n 为 table 长度）</strong>;</li>\n<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Loadfactor 的值，门限值降低，table 数组就容易扩容，但是每个数组上的链表就会相对短，查询就快；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 loadFactor 的值，（loadFactor 可以大于1，但是建议不超过 0.75，默认值 0.75 符合大多数场景）。</li>\n<li>而当链表长度太长（ <strong>默认超过8</strong> ）时，链表就转换为 <strong>红黑树</strong> ，利用红黑树快速增删改查的特点提高 HashMap 的性能。</li>\n<li><strong>门限值（threshold） = 负载因子(loadfactor) * 容量（capacity）</strong>，在元素个数超过门限值时（size &gt; threshold），调整 Map 的大小，table 的长度使用的是 2 次幂扩展(指长度扩为原来 2 倍)，同理根据门限值的计算公式可以计算出门限值也是原来 2 倍。 <strong>扩容非常耗性能，所以在使用 HashMap 时最好给一个大致的 size，避免频繁扩容</strong>。</li>\n<li><p>扩容对应的键的 hash 计算</p>\n<ul>\n<li>jdk 7：重新计算 hash 值来获取索引值。</li>\n<li>jdk 8：只需要看看原来的hash值新增的那个bit是1还是0就好了，是 <strong>0</strong> 的话索引 <strong>不变</strong> ，是 <strong>1</strong> 的话索引变成 <strong>“原索引+oldCap”</strong></li>\n</ul>\n<p><img src=\"https://github.com/0HongTao0/Blog/blob/master/pic/HashMap_%E4%B8%8D%E5%90%8CJDK%E6%89%A9%E5%AE%B9%E6%AF%94%E8%BE%83.png?raw=true\" alt=\"img\"></p>\n</li>\n<li>线程安全问题：<br>HashMap 是线程不安全的，为什么呢？<br>并发的多线程使用场景中使用 HashMap 可能造成死循环，因为在 resize 过程中会导致出现环形链表。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"JAVA-并发\"><a href=\"#JAVA-并发\" class=\"headerlink\" title=\"JAVA 并发\"></a>JAVA 并发</h3><ul>\n<li><p>如何创建多线程？</p>\n<p>主要有 2 种方法</p>\n<ol>\n<li>创建一个子类继承（extends） Thread 类，然后重写 run（）方法。</li>\n<li>创建一个子类实现（implement）Runnable 接口，然后重写 run（）方法。</li>\n</ol>\n</li>\n<li><p>简述线程的五种状态</p>\n<ol>\n<li><p>线程的五种状态分别是：新建（New），就绪（Runnable），运行（Running），终止（Dead），阻塞（Blocked）</p>\n</li>\n<li><p>线程没被阻塞从新建状态到终止状态的过程：从线程被 new 创建开始，线程就进入<strong>新建</strong>状态，当程序调用 Thread.start() 方法的时候，线程进入<strong>就绪</strong>状态，因为 JAVA 线程的调度是抢占式调度，所以在这个时候线程有可能正在运行也可能没有运行，当操作系统分配时间片给线程的时候，线程进入<strong>运行</strong>状态，当 Thread.run() 方法执行到最后一条语句并返回的时候，线程自然死亡，进入<strong>终止</strong>状态。</p>\n</li>\n<li><p>线程被阻塞即从<strong>就绪</strong>状态转至<strong>阻塞</strong>状态，导致线程进入阻塞状态的原因主要有 3 个，<strong>同步阻塞</strong>，当线程获取一个被其他线程所持有的对象锁，线程进入阻塞状态。线程执行 <strong>Thread.sleep()</strong> 方法，以及 <strong>Thread.wait()</strong> 方法。当线程在阻塞状态被激活的时候，线程进入<strong>就绪</strong>状态，等待系统调度进入<strong>运行</strong>状态。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5545289-1c4500c4a5adaafe.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/527/format/webp\" alt=\"img\"></p>\n</li>\n</ol>\n</li>\n<li><p>如何中断正在执行的线程</p>\n<ol>\n<li>执行完 run（）方法的最后一条语句并由 return 返回时，线程终止。</li>\n<li>当线程run（）方法种出现了没有捕获分异常时，线程终止。</li>\n</ol>\n<p>没有方法可以强制终止线程，但是可以用 Thread.interrupt() 方法来请求终止线程。线程有个中断状态的 Boolean 标志，不停地检查该标志，线程阻塞无法检查中断状态所以不能在线程阻塞的时候调用 Thread.interrupt() 方法（会抛出 InterruptedException）。</p>\n</li>\n<li><p>锁的相关理解</p>\n<ol>\n<li>锁是防止程序代码块中受并发访问而造成不安全的干扰，即保证任何时刻只能有一个线程执行被保护的代码。</li>\n<li>大多数情况下是通过 synchronized 关键字来实现锁，在 JAVA 中每一个对象都存在一个锁，<strong>synchronized 用在方法上</strong>，是锁住当前对象的当前方法，多个线程访问这个对象的该方法会被阻塞；<strong>synchronized(this)</strong> 锁住的是当前对象的，多个线程访问这个对象会被阻塞；同理可得 <strong>synchronized(object)</strong> 锁的是 object 对象，多个线程访问该对象会被阻塞；（注意：锁的对象不能是 final 类，因为经过修改的 final 类会是一个新对象，无法获取同一个锁）</li>\n<li>也可以通过 JAVA 提供的 Lock 类来实现锁。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"JAVA-代理\"><a href=\"#JAVA-代理\" class=\"headerlink\" title=\"JAVA 代理\"></a>JAVA 代理</h3><ul>\n<li>静态代理：代码 <strong>运行之前</strong> 代理类的 Class 编译文件就已经存在。<br>实现思路：通过代理者和被代理者实现同一接口，并且代理者种存在一个被代理者的实例，即调用方通过代理者间接调用被代理者的方法。</li>\n<li>动态代理：代码 <strong>运行过程</strong> 通过反射机制直接生成代理者对象。<br>实现思路：通过 java.lang.reflect 的 Proxy 实现，有 3 个参数。<br>ClassLoder: 类加载器<br>Class&lt;?&gt;[]: 对象组<br>InvocationHandler: <strong>调用处理器,无论何时调用代理对象的方法调用处理器的 invoke 方法都会被调用。</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Object obj;<span class=\"comment\">//被代理的类引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DynamicProxy</span><span class=\"params\">(Object obj)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> throw Throwable</span>&#123;</span><br><span class=\"line\">    Object result = method.invoke(obj, args);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JAVA-内存\"><a href=\"#JAVA-内存\" class=\"headerlink\" title=\"JAVA 内存\"></a><a href=\"https://github.com/francistao/LearningNotes/blob/master/Part1/Android/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93.md\" target=\"_blank\" rel=\"noopener\">JAVA 内存</a></h3><ul>\n<li>静态存储区：存放静态数据，全局 static 数据和常量，编译器已经分配内存并且在程序运行期间都存在。</li>\n<li>栈区：存放方法内部的局部变量，在方法执行结束后局部变量的内存就被释放，效率高但是分配内存容量有限。</li>\n<li><p>堆区：存放 new 出来的对象实例，这个实例不使用时就会被 GC 回收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sample</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//s1 和 0 内存都存放在堆中</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> s1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//mSample1 和 mSample1 所指的对象内存都存放在堆中</span></span><br><span class=\"line\">    Sample mSample1 = <span class=\"keyword\">new</span> Sample();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// s2 存在于栈中</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> s2 = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//引用 mSample2 存放于栈中，但 mSample2 指的对象内存存放于堆中</span></span><br><span class=\"line\">        Sample mSample2 = <span class=\"keyword\">new</span> Sample();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//引用 mSample3存放于栈中，但是 mSample3 所指对象存放于堆中，包括对象内部的成员变量 s1，mSample1 都在堆中</span></span><br><span class=\"line\">Sample mSample3 = <span class=\"keyword\">new</span> Sample();</span><br></pre></td></tr></table></figure>\n<p><strong>结论：局部变量的基本数据类型和引用存放于栈，引用所指的对象和类的成员变量存放于堆中（包括引用和引用指的对象）。</strong></p>\n</li>\n<li>Java 的内存管理<ol>\n<li>内存的分配由程序员来完成，即程序调用 new 方法或通过反射来分配内存。</li>\n<li>内存的回收是由垃圾回收器（GC）完成的，对象不再被引用，该对象的内存就被释放回收。</li>\n</ol>\n</li>\n<li>JAVA 内存泄漏<ol>\n<li>简单介绍：指的是在程序中，存在相对程序逻辑来说已经无用的对象，但是由于对象一直被引用者导致无法被垃圾回收器释放回收，这些对象会在程序运行期间一直占着内存。</li>\n<li><strong>内存泄漏的原因</strong><ul>\n<li><strong>静态集合</strong> 引用的所有对象 Object 在程序运行期间都无法释放。</li>\n<li>集合里面的对象属性被修改后再调用 remove() 方法无效（如 hashcode 不同无法 remove）。</li>\n<li><strong>监听器没有释放</strong> ，导致该监听的实体没有被释放。</li>\n<li><strong>数据库连接，网络连接和 IO 连接</strong> ，即涉及流操作都没有显式调用 close() 方法，GC 不会回收。</li>\n<li><strong>内部类和外部模块的引用</strong>，非静态的内部类和匿名类会隐式地持有一个他们外部类的引用，当外部类对象已经相对程序无作用时，非静态得内部类和匿名类引用着外部类，导致外部类对象无法被回收释放。</li>\n<li><strong>单例模式</strong> ， 单例模式在初始化后在程序运行期间都是存在的，如果单例模式持有外部对象得引用，则会导致外部对象无法释放回收。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"JAVA-集合\"><a href=\"#JAVA-集合\" class=\"headerlink\" title=\"JAVA 集合\"></a>JAVA 集合</h3><ul>\n<li>Map<br>主要的实现类有：HashMap， HashTable， LinkedHashMap，TreeMap。<ol>\n<li>HashMap根据 Key 的 HashCode 来存储数据，只允许一个 Key 为 Null，但允许多条记录为 Null，HashMap 线程不安全。可以使用 Collections.synchronizedMap() 方法来使HashMap 具有线程安全，或者直接使用 <strong>ConcurrentHashMap</strong> 代替。</li>\n<li>HashTable 和 HashMap 的功能差不多，但是它是性能安全的。</li>\n<li>LinkedHashMap 是 HashMap 的子类，保存插入顺序，也就是说它是有序的，可以通过 Iterator 迭代器遍历 LinkedHashMap。</li>\n<li>TreeMap实现 SortedMap 接口，内部有序，顺序是按照 Key 的升序排序，也可以自己实现排序的比较器（Comparable 接口）。用 Iterator 遍历也是有序的。</li>\n</ol>\n</li>\n<li><p><a href=\"https://tech.meituan.com/java_hashmap.html\" target=\"_blank\" rel=\"noopener\">HashMap</a></p>\n<ol>\n<li>HashMap 按照 <strong>Lazy-Load</strong> 来进行初始化，通过 resize() 来进行初始化一个 HashMap 和对 HashMap 进行扩容。</li>\n<li>键值对在 HashMap 内的位置 index 取决于位运算 <strong>i = (n -1) &amp; hash（n 为 table 长度）</strong>;</li>\n<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子 Loadfactor 的值，门限值降低，table 数组就容易扩容，但是每个数组上的链表就会相对短，查询就快；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子 loadFactor 的值，（loadFactor 可以大于1，但是建议不超过 0.75，默认值 0.75 符合大多数场景）。</li>\n<li>而当链表长度太长（ <strong>默认超过8</strong> ）时，链表就转换为 <strong>红黑树</strong> ，利用红黑树快速增删改查的特点提高 HashMap 的性能。</li>\n<li><strong>门限值（threshold） = 负载因子(loadfactor) * 容量（capacity）</strong>，在元素个数超过门限值时（size &gt; threshold），调整 Map 的大小，table 的长度使用的是 2 次幂扩展(指长度扩为原来 2 倍)，同理根据门限值的计算公式可以计算出门限值也是原来 2 倍。 <strong>扩容非常耗性能，所以在使用 HashMap 时最好给一个大致的 size，避免频繁扩容</strong>。</li>\n<li><p>扩容对应的键的 hash 计算</p>\n<ul>\n<li>jdk 7：重新计算 hash 值来获取索引值。</li>\n<li>jdk 8：只需要看看原来的hash值新增的那个bit是1还是0就好了，是 <strong>0</strong> 的话索引 <strong>不变</strong> ，是 <strong>1</strong> 的话索引变成 <strong>“原索引+oldCap”</strong></li>\n</ul>\n<p><img src=\"https://github.com/0HongTao0/Blog/blob/master/pic/HashMap_%E4%B8%8D%E5%90%8CJDK%E6%89%A9%E5%AE%B9%E6%AF%94%E8%BE%83.png?raw=true\" alt=\"img\"></p>\n</li>\n<li>线程安全问题：<br>HashMap 是线程不安全的，为什么呢？<br>并发的多线程使用场景中使用 HashMap 可能造成死循环，因为在 resize 过程中会导致出现环形链表。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"JAVA-并发\"><a href=\"#JAVA-并发\" class=\"headerlink\" title=\"JAVA 并发\"></a>JAVA 并发</h3><ul>\n<li><p>如何创建多线程？</p>\n<p>主要有 2 种方法</p>\n<ol>\n<li>创建一个子类继承（extends） Thread 类，然后重写 run（）方法。</li>\n<li>创建一个子类实现（implement）Runnable 接口，然后重写 run（）方法。</li>\n</ol>\n</li>\n<li><p>简述线程的五种状态</p>\n<ol>\n<li><p>线程的五种状态分别是：新建（New），就绪（Runnable），运行（Running），终止（Dead），阻塞（Blocked）</p>\n</li>\n<li><p>线程没被阻塞从新建状态到终止状态的过程：从线程被 new 创建开始，线程就进入<strong>新建</strong>状态，当程序调用 Thread.start() 方法的时候，线程进入<strong>就绪</strong>状态，因为 JAVA 线程的调度是抢占式调度，所以在这个时候线程有可能正在运行也可能没有运行，当操作系统分配时间片给线程的时候，线程进入<strong>运行</strong>状态，当 Thread.run() 方法执行到最后一条语句并返回的时候，线程自然死亡，进入<strong>终止</strong>状态。</p>\n</li>\n<li><p>线程被阻塞即从<strong>就绪</strong>状态转至<strong>阻塞</strong>状态，导致线程进入阻塞状态的原因主要有 3 个，<strong>同步阻塞</strong>，当线程获取一个被其他线程所持有的对象锁，线程进入阻塞状态。线程执行 <strong>Thread.sleep()</strong> 方法，以及 <strong>Thread.wait()</strong> 方法。当线程在阻塞状态被激活的时候，线程进入<strong>就绪</strong>状态，等待系统调度进入<strong>运行</strong>状态。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/5545289-1c4500c4a5adaafe.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/527/format/webp\" alt=\"img\"></p>\n</li>\n</ol>\n</li>\n<li><p>如何中断正在执行的线程</p>\n<ol>\n<li>执行完 run（）方法的最后一条语句并由 return 返回时，线程终止。</li>\n<li>当线程run（）方法种出现了没有捕获分异常时，线程终止。</li>\n</ol>\n<p>没有方法可以强制终止线程，但是可以用 Thread.interrupt() 方法来请求终止线程。线程有个中断状态的 Boolean 标志，不停地检查该标志，线程阻塞无法检查中断状态所以不能在线程阻塞的时候调用 Thread.interrupt() 方法（会抛出 InterruptedException）。</p>\n</li>\n<li><p>锁的相关理解</p>\n<ol>\n<li>锁是防止程序代码块中受并发访问而造成不安全的干扰，即保证任何时刻只能有一个线程执行被保护的代码。</li>\n<li>大多数情况下是通过 synchronized 关键字来实现锁，在 JAVA 中每一个对象都存在一个锁，<strong>synchronized 用在方法上</strong>，是锁住当前对象的当前方法，多个线程访问这个对象的该方法会被阻塞；<strong>synchronized(this)</strong> 锁住的是当前对象的，多个线程访问这个对象会被阻塞；同理可得 <strong>synchronized(object)</strong> 锁的是 object 对象，多个线程访问该对象会被阻塞；（注意：锁的对象不能是 final 类，因为经过修改的 final 类会是一个新对象，无法获取同一个锁）</li>\n<li>也可以通过 JAVA 提供的 Lock 类来实现锁。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h3 id=\"JAVA-代理\"><a href=\"#JAVA-代理\" class=\"headerlink\" title=\"JAVA 代理\"></a>JAVA 代理</h3><ul>\n<li>静态代理：代码 <strong>运行之前</strong> 代理类的 Class 编译文件就已经存在。<br>实现思路：通过代理者和被代理者实现同一接口，并且代理者种存在一个被代理者的实例，即调用方通过代理者间接调用被代理者的方法。</li>\n<li>动态代理：代码 <strong>运行过程</strong> 通过反射机制直接生成代理者对象。<br>实现思路：通过 java.lang.reflect 的 Proxy 实现，有 3 个参数。<br>ClassLoder: 类加载器<br>Class&lt;?&gt;[]: 对象组<br>InvocationHandler: <strong>调用处理器,无论何时调用代理对象的方法调用处理器的 invoke 方法都会被调用。</strong><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">newProxyInstance</span><span class=\"params\">(ClassLoader loader,Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Object obj;<span class=\"comment\">//被代理的类引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DynamicProxy</span><span class=\"params\">(Object obj)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.obj = obj;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> throw Throwable</span>&#123;</span><br><span class=\"line\">    Object result = method.invoke(obj, args);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"Android Volley","date":"2018-07-19T01:27:42.000Z","_content":"\n##### 简单介绍一下 Volley\n\n- Volley 是一个 Http 协议的 Android 网络框架，它可以自动调度 App 的网络请求，可以并发执行网络请求，具有自己的一套网络请求的响应缓存（和 HTTP 的缓存不一样）。Volley 还支持设置优先级的网络请求，中断正在执行的网络请求。**Volley 支持开发者自定义网络请求返回的类型。**总的来说 Volley 就是一个异步网络请求的框架。\n\n<!--more-->\n\n##### 如何在 Android 项目中引入 Volley\n\n**框架比较老，并且没有更新了，所以强烈建议使用方法二。jar 包可以搜索一下就能找到**\n\n- 方法一：\n\n  直接在 Android 的依赖 Gradle 文件中添加依赖（但是不知道为什么总是下载不下来）\n\n  ```groovy\n  dependencies {\n      implementation 'com.android.volley:volley:1.1.1'\n  }\n  ```\n\n- 方法二：\n\n  下载 Volley jar 包，添加到项目的 libs 目录下，并添加 Jar dependency \n\n  ```groovy\n  dependencies {\n      implementation files('libs/volley.jar')\n  }\n  ```\n\n- 方法三：\n\n  去 Volley 的 Github 仓库 clone 源码，并在 Android 的项目中进行 import module \n\n  ```\n  git clone https://github.com/google/volley\n  ```\n\n##### 使用 Volley 实现一个简单的网络请求\n\n```java\nprivate static final String TAG = MainActivity.class.getSimpleName();\n/**\n * 网络请求的队列(通常在 Application 类中初始化，并全局唯一一个 RequestQueue)\n */\nprivate RequestQueue mRequestQueue;\nprivate static final String URL = \"http://www.awqingnian.xyz/2018/07/18/Android%20View/\"\n\n//初始化 RequestQueue\nmRequestQueue = Volley.newRequestQueue(this);\n//执行一个返回 String 的网络请求\nStringRequest request = new StringRequest(Request.Method.GET, URL,\n        new Response.Listener<String>() {\n            @Override\n            public void onResponse(String response) {\n                Log.d(TAG, \"onResponse: \" + response);\n            }\n        }, new Response.ErrorListener() {\n    @Override\n    public void onErrorResponse(VolleyError error) {\n        Log.d(TAG, \"onErrorResponse: 网络请求错误   \" + error);\n    }\n});\n\n// 将网络请求添加到请求队列中（队列自动执行网络请求）\nmRequestQueue.add(request);\n```\n\n当然上面举的例子是简单的例子，Volley 的网络请求不仅仅只有返回 String 类型的，还有其他很多类型。\n\n| Request           | 返回类型                            |\n|:-----------------:|:-------------------------------:|\n| ImageRequest      | 请求指定 image 的 Url 返回一个解码的 Bitmap |\n| ClearCacheRequest | 用于清除 Volley 网络请求缓存              |\n| StringRequest     | 请求指定 Url 返回 String 类型的值         |\n| JsonRequest       | 请求指定 Url 返回 JSON 值              |\n| JsonObjectRequest | 请求指定 Url 返回 JsonObject          |\n| JsonArrayRequest  | 请求指定 Url 返回 JsonArray           |\n\n##### 自定义 Request （高级用法）\n\n- 主要是通过请求 Url 返回的 json，经过 Gson 解析，以及 java 泛型的传入的 Class<T>，返回 T 类所对应的对象。当然开发者可以自定义很多类型的返回类型，怎么自定义，参考 Request 源码的写法加上自己的思考就能实现。下面介绍自定义 Request ，返回 List 集合：\n\n  ```java\n  /**\n   * 继承 Request ，并将泛型 <T> 传入\n   */\n  public class DiyGSONRequest<T> extends Request<T> {\n      private final Response.Listener<List<T>> mListener;\n      private Class<T> mClass;\n      //5 参数构造方法\n      private DiyGSONRequest(int method, String url, Class<T> clazz, Response.Listener<List<T>> listener, Response.ErrorListener errorListener) {\n          super(method, url, errorListener);\n          mClass = clazz;\n          mListener = listener;\n      }\n      //4 参数构造方法    （默认请求类型 GET）\n      public DiyGSONRequest(String url, Class<T> clazz, Response.Listener<List<T>> listener, Response.ErrorListener errorListener) {\n          this(Method.GET, url, clazz, listener, errorListener);\n      }\n      //请求成功后，对 networkResponse 进行解析成泛型 T 的对象\n      @Override\n      protected Response<T> parseNetworkResponse(NetworkResponse networkResponse) {\n          String jsonData;\n  \n          try {\n              jsonData = new String(networkResponse.data, HttpHeaderParser.parseCharset(networkResponse.headers));\n              List<T> list = new ArrayList<>();\n              JsonArray array = new JsonParser().parse(jsonData).getAsJsonArray();\n              for (JsonElement element : array) {\n                  // Gson 解析\n                  list.add(new Gson().fromJson(element, mClass));\n              }\n              return (Response<T>) Response.success(list, HttpHeaderParser.parseCacheHeaders(networkResponse));\n          } catch (UnsupportedEncodingException e) {\n              return Response.error(new ParseError(e));\n          }\n      }\n  \n      @Override\n      protected void deliverResponse(T t) {\n          mListener.onResponse((List<T>) t);\n      }\n  }\n  ```\n\n  ```\n  //数据类型可以使用这组数据测试\n  [{\"id\":1,\"name\":\"北京\"},{\"id\":2,\"name\":\"上海\"},{\"id\":3,\"name\":\"天津\"},{\"id\":4,\"name\":\"重庆\"}]\n  ```\n\n##### 简单介绍 Volley 的几个重要的类\n\n- Request （网络请求的基类）\n\n  构造方法如下：\n\n  ```java\n  public Request(String url, Response.ErrorListener listener) {\n          this(Method.DEPRECATED_GET_OR_POST, url, listener);\n  }\n  \n  /**\n   *  method: 请求类型（GET : 0, POST : 1, PUT : 2, DELETE : 3）\n   *  url: 请求地址的 Url\n   *  Response.ErrorListener : 请求错误的回调接口\n   */\n  public Request(int method, String url, Response.ErrorListener listener) {\n\t  mMethod = method;\n\t  mUrl = url;\n\t  mErrorListener = listener;\n\t  setRetryPolicy(new DefaultRetryPolicy());\n\n\t  mDefaultTrafficStatsTag = TextUtils.isEmpty(url) ? 0: Uri.parse(url).getHost().hashCode();\n  }\n  \n  /**\n   * Request 子类必须实现的抽象方法，当执行该网络请求成功后，将网络请求回调到此接口方法\n   */\n  abstract protected void deliverResponse(T response);\n  ```\n\n- Volley（用来实例化 RequestQueue 实例）\n\n  获取 RequestQueue 实例的方法在 Volley 类中统一管理。\n\n  ```java\n  public static RequestQueue newRequestQueue(Context context, HttpStack stack) {\n    // 配置缓存的路径文件（Volley 的缓存模块）\n    File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n  \n    String userAgent = \"volley/0\";\n    try {\n      String packageName = context.getPackageName();\n      PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n      userAgent = packageName + \"/\" + info.versionCode;\n    } catch (NameNotFoundException e) {\n    }\n  \n    if (stack == null) {\n      if (Build.VERSION.SDK_INT >= 9) {\n        //现在手机 SDK 基本都在 19 以上，所以只要关注这块就行了。\n        //HurlStack 就是一个底层封装了 HttpURLConnection 的类，主要用来执行网络请求。\n        stack = new HurlStack();\n      } else {\n        stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n      }\n    }\n      // BasicNetwork 是一个获取 HurlStack 执行完网络请求获取 Response 的类\n    Network network = new BasicNetwork(stack);\n      // RequestQueue 默认有缓存，在此初始化 RequestQueue\n    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);\n    //在此处开始对 RequestQueue 的 CacheDispatcher（执行缓存线程） 和 NetworkDispatcher（执行网络请求线程） 进行初始化并且开启线程，不断地从 RequestQueue 中取出 request 执行。\n    queue.start();\n  \n    return queue;\n  }\n  ```\n\n- Cache （进行对网络请求缓存的操作类）\n\n  Cache 接口的具体实现类：DiskBasedCache\n\n| 重要方法或变量                      | 含义                                 |\n|:----------------------------:|:----------------------------------:|\n| mTotalSize                   | 已经使用的缓存空间                          |\n| mRootDirectory               | 缓存所在的根目录（默认：\"volley\"）              |\n| mMaxCacheSizeInBytes         | 最大缓存空间大小（默认：5 \\* 1024 \\* 1024（5M）） |\n| clear()                      | 清除缓存                               |\n| get(String key)              | 获取缓存实例（E）                          |\n| initialize()                 | 初始化缓存，并将读取所有缓存存在集合中（mEntries）      |\n| put(String key, Entry entry) | 存入缓存                               |\n| remove(String key)           | 删除指定 key 值的缓存                      |\n\n其中 Entry 是缓存操作的类。\n\n- RequestQueue（网络请求的队列）\n\n  主要方法如下\n\n  ```java\n  public RequestQueue(Cache cache, Network network, int threadPoolSize,ResponseDelivery delivery) {\n\t// 之前传入的 DiskBasedCache 实例，用于缓存\n\tmCache = cache;\n\t// 用于使用 HttpUrlConnection 执行网络请求并且得到 Response\n\tmNetwork = network;\n\t// 执行网络请求的线程数量（默认 4 个）\n\tmDispatchers = new NetworkDispatcher[threadPoolSize];\n\tmDelivery = delivery;\n  }\n\n  public RequestQueue(Cache cache, Network network, int threadPoolSize) {\n\t// 注意注意注意： 此处的 ExecutorDelivery 是通过主线程的 Looper 创建的，也就是说此 ExecutorDelivery 执行在主线程中（异步请求的重点）\n\tthis(cache, network, threadPoolSize,new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n  }\n\n  public Request add(Request request) {\n\n\t//······省略一些代码······\n\n\t// 不需要缓存，直接加入队列中\n\tif (!request.shouldCache()) {\n\t  mNetworkQueue.add(request);\n\t  return request;\n\t}\n\n\tsynchronized (mWaitingRequests) {\n\t  String cacheKey = request.getCacheKey();\n\t  if (mWaitingRequests.containsKey(cacheKey)) {\n\t\t//等待队列存在此网络请求\n\t\tQueue<Request> stagedRequests = mWaitingRequests.get(cacheKey);\n\t\tif (stagedRequests == null) {\n\t\t  stagedRequests = new LinkedList<Request>();\n\t\t}\n\t\tstagedRequests.add(request);\n\t\tmWaitingRequests.put(cacheKey, stagedRequests);\n\t\tif (VolleyLog.DEBUG) {\n\t\t  VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n\t\t}\n\t  } else {\n\t\t//等待队列不存在此网络请求，加入等待队列中\n\t\tmWaitingRequests.put(cacheKey, null);\n\t  }\n\t  return request;\n  }\n```\n\n\t\n- NetworkDispatcher（extends Thread）\n\n  run 方法执行网络请求并异步回调结果的代码如下\n\n  ```java\n  public void run() {\n    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n    Request request;\n    while (true) {\n\n      //······省略一些代码······\n\n      try {\n        request.addMarker(\"network-queue-take\");\n        if (request.isCanceled()) {\n          request.finish(\"network-discard-cancelled\");\n          continue;\n        }\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n          TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());\n        }\n        //在此处通过 NetWork 进行网络请求并且的搭配返回的 NetworkResponse\n        NetworkResponse networkResponse = mNetwork.performRequest(request);\n        request.addMarker(\"network-http-complete\");\n\n        //······省略一些代码······\n\n        //在此进行对网络请求进行缓存\n        if (request.shouldCache() && response.cacheEntry != null) {\n          mCache.put(request.getCacheKey(), response.cacheEntry);\n          request.addMarker(\"network-cache-written\");\n        }\n        request.markDelivered();\n        // 注意注意注意：在此通过 ExecutorDelivery（执行在主线程中）将 response 异步回调到主线程的 request 回调函数中处理结果\n        mDelivery.postResponse(request, response);\n      } catch (VolleyError volleyError) {\n        parseAndDeliverNetworkError(request, volleyError);\n      } catch (Exception e) {\n        VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n        mDelivery.postError(request, new VolleyError(e));\n      }\n    }\n  }\n```\n\n- ResponseDelivery  (对在 NetworkDispatcher 网络请求返回的 Response 进行通过 Request 的deliverResponse(T response) )ResponseDelivery 接口的实现类：ExecutorDelivery\n","source":"_posts/Android Volley.md","raw":"---\n\ntitle: Android Volley\n\ndate: 2018-07-19 09:27:42\n\ntags:\n\n---\n\n##### 简单介绍一下 Volley\n\n- Volley 是一个 Http 协议的 Android 网络框架，它可以自动调度 App 的网络请求，可以并发执行网络请求，具有自己的一套网络请求的响应缓存（和 HTTP 的缓存不一样）。Volley 还支持设置优先级的网络请求，中断正在执行的网络请求。**Volley 支持开发者自定义网络请求返回的类型。**总的来说 Volley 就是一个异步网络请求的框架。\n\n<!--more-->\n\n##### 如何在 Android 项目中引入 Volley\n\n**框架比较老，并且没有更新了，所以强烈建议使用方法二。jar 包可以搜索一下就能找到**\n\n- 方法一：\n\n  直接在 Android 的依赖 Gradle 文件中添加依赖（但是不知道为什么总是下载不下来）\n\n  ```groovy\n  dependencies {\n      implementation 'com.android.volley:volley:1.1.1'\n  }\n  ```\n\n- 方法二：\n\n  下载 Volley jar 包，添加到项目的 libs 目录下，并添加 Jar dependency \n\n  ```groovy\n  dependencies {\n      implementation files('libs/volley.jar')\n  }\n  ```\n\n- 方法三：\n\n  去 Volley 的 Github 仓库 clone 源码，并在 Android 的项目中进行 import module \n\n  ```\n  git clone https://github.com/google/volley\n  ```\n\n##### 使用 Volley 实现一个简单的网络请求\n\n```java\nprivate static final String TAG = MainActivity.class.getSimpleName();\n/**\n * 网络请求的队列(通常在 Application 类中初始化，并全局唯一一个 RequestQueue)\n */\nprivate RequestQueue mRequestQueue;\nprivate static final String URL = \"http://www.awqingnian.xyz/2018/07/18/Android%20View/\"\n\n//初始化 RequestQueue\nmRequestQueue = Volley.newRequestQueue(this);\n//执行一个返回 String 的网络请求\nStringRequest request = new StringRequest(Request.Method.GET, URL,\n        new Response.Listener<String>() {\n            @Override\n            public void onResponse(String response) {\n                Log.d(TAG, \"onResponse: \" + response);\n            }\n        }, new Response.ErrorListener() {\n    @Override\n    public void onErrorResponse(VolleyError error) {\n        Log.d(TAG, \"onErrorResponse: 网络请求错误   \" + error);\n    }\n});\n\n// 将网络请求添加到请求队列中（队列自动执行网络请求）\nmRequestQueue.add(request);\n```\n\n当然上面举的例子是简单的例子，Volley 的网络请求不仅仅只有返回 String 类型的，还有其他很多类型。\n\n| Request           | 返回类型                            |\n|:-----------------:|:-------------------------------:|\n| ImageRequest      | 请求指定 image 的 Url 返回一个解码的 Bitmap |\n| ClearCacheRequest | 用于清除 Volley 网络请求缓存              |\n| StringRequest     | 请求指定 Url 返回 String 类型的值         |\n| JsonRequest       | 请求指定 Url 返回 JSON 值              |\n| JsonObjectRequest | 请求指定 Url 返回 JsonObject          |\n| JsonArrayRequest  | 请求指定 Url 返回 JsonArray           |\n\n##### 自定义 Request （高级用法）\n\n- 主要是通过请求 Url 返回的 json，经过 Gson 解析，以及 java 泛型的传入的 Class<T>，返回 T 类所对应的对象。当然开发者可以自定义很多类型的返回类型，怎么自定义，参考 Request 源码的写法加上自己的思考就能实现。下面介绍自定义 Request ，返回 List 集合：\n\n  ```java\n  /**\n   * 继承 Request ，并将泛型 <T> 传入\n   */\n  public class DiyGSONRequest<T> extends Request<T> {\n      private final Response.Listener<List<T>> mListener;\n      private Class<T> mClass;\n      //5 参数构造方法\n      private DiyGSONRequest(int method, String url, Class<T> clazz, Response.Listener<List<T>> listener, Response.ErrorListener errorListener) {\n          super(method, url, errorListener);\n          mClass = clazz;\n          mListener = listener;\n      }\n      //4 参数构造方法    （默认请求类型 GET）\n      public DiyGSONRequest(String url, Class<T> clazz, Response.Listener<List<T>> listener, Response.ErrorListener errorListener) {\n          this(Method.GET, url, clazz, listener, errorListener);\n      }\n      //请求成功后，对 networkResponse 进行解析成泛型 T 的对象\n      @Override\n      protected Response<T> parseNetworkResponse(NetworkResponse networkResponse) {\n          String jsonData;\n  \n          try {\n              jsonData = new String(networkResponse.data, HttpHeaderParser.parseCharset(networkResponse.headers));\n              List<T> list = new ArrayList<>();\n              JsonArray array = new JsonParser().parse(jsonData).getAsJsonArray();\n              for (JsonElement element : array) {\n                  // Gson 解析\n                  list.add(new Gson().fromJson(element, mClass));\n              }\n              return (Response<T>) Response.success(list, HttpHeaderParser.parseCacheHeaders(networkResponse));\n          } catch (UnsupportedEncodingException e) {\n              return Response.error(new ParseError(e));\n          }\n      }\n  \n      @Override\n      protected void deliverResponse(T t) {\n          mListener.onResponse((List<T>) t);\n      }\n  }\n  ```\n\n  ```\n  //数据类型可以使用这组数据测试\n  [{\"id\":1,\"name\":\"北京\"},{\"id\":2,\"name\":\"上海\"},{\"id\":3,\"name\":\"天津\"},{\"id\":4,\"name\":\"重庆\"}]\n  ```\n\n##### 简单介绍 Volley 的几个重要的类\n\n- Request （网络请求的基类）\n\n  构造方法如下：\n\n  ```java\n  public Request(String url, Response.ErrorListener listener) {\n          this(Method.DEPRECATED_GET_OR_POST, url, listener);\n  }\n  \n  /**\n   *  method: 请求类型（GET : 0, POST : 1, PUT : 2, DELETE : 3）\n   *  url: 请求地址的 Url\n   *  Response.ErrorListener : 请求错误的回调接口\n   */\n  public Request(int method, String url, Response.ErrorListener listener) {\n\t  mMethod = method;\n\t  mUrl = url;\n\t  mErrorListener = listener;\n\t  setRetryPolicy(new DefaultRetryPolicy());\n\n\t  mDefaultTrafficStatsTag = TextUtils.isEmpty(url) ? 0: Uri.parse(url).getHost().hashCode();\n  }\n  \n  /**\n   * Request 子类必须实现的抽象方法，当执行该网络请求成功后，将网络请求回调到此接口方法\n   */\n  abstract protected void deliverResponse(T response);\n  ```\n\n- Volley（用来实例化 RequestQueue 实例）\n\n  获取 RequestQueue 实例的方法在 Volley 类中统一管理。\n\n  ```java\n  public static RequestQueue newRequestQueue(Context context, HttpStack stack) {\n    // 配置缓存的路径文件（Volley 的缓存模块）\n    File cacheDir = new File(context.getCacheDir(), DEFAULT_CACHE_DIR);\n  \n    String userAgent = \"volley/0\";\n    try {\n      String packageName = context.getPackageName();\n      PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);\n      userAgent = packageName + \"/\" + info.versionCode;\n    } catch (NameNotFoundException e) {\n    }\n  \n    if (stack == null) {\n      if (Build.VERSION.SDK_INT >= 9) {\n        //现在手机 SDK 基本都在 19 以上，所以只要关注这块就行了。\n        //HurlStack 就是一个底层封装了 HttpURLConnection 的类，主要用来执行网络请求。\n        stack = new HurlStack();\n      } else {\n        stack = new HttpClientStack(AndroidHttpClient.newInstance(userAgent));\n      }\n    }\n      // BasicNetwork 是一个获取 HurlStack 执行完网络请求获取 Response 的类\n    Network network = new BasicNetwork(stack);\n      // RequestQueue 默认有缓存，在此初始化 RequestQueue\n    RequestQueue queue = new RequestQueue(new DiskBasedCache(cacheDir), network);\n    //在此处开始对 RequestQueue 的 CacheDispatcher（执行缓存线程） 和 NetworkDispatcher（执行网络请求线程） 进行初始化并且开启线程，不断地从 RequestQueue 中取出 request 执行。\n    queue.start();\n  \n    return queue;\n  }\n  ```\n\n- Cache （进行对网络请求缓存的操作类）\n\n  Cache 接口的具体实现类：DiskBasedCache\n\n| 重要方法或变量                      | 含义                                 |\n|:----------------------------:|:----------------------------------:|\n| mTotalSize                   | 已经使用的缓存空间                          |\n| mRootDirectory               | 缓存所在的根目录（默认：\"volley\"）              |\n| mMaxCacheSizeInBytes         | 最大缓存空间大小（默认：5 \\* 1024 \\* 1024（5M）） |\n| clear()                      | 清除缓存                               |\n| get(String key)              | 获取缓存实例（E）                          |\n| initialize()                 | 初始化缓存，并将读取所有缓存存在集合中（mEntries）      |\n| put(String key, Entry entry) | 存入缓存                               |\n| remove(String key)           | 删除指定 key 值的缓存                      |\n\n其中 Entry 是缓存操作的类。\n\n- RequestQueue（网络请求的队列）\n\n  主要方法如下\n\n  ```java\n  public RequestQueue(Cache cache, Network network, int threadPoolSize,ResponseDelivery delivery) {\n\t// 之前传入的 DiskBasedCache 实例，用于缓存\n\tmCache = cache;\n\t// 用于使用 HttpUrlConnection 执行网络请求并且得到 Response\n\tmNetwork = network;\n\t// 执行网络请求的线程数量（默认 4 个）\n\tmDispatchers = new NetworkDispatcher[threadPoolSize];\n\tmDelivery = delivery;\n  }\n\n  public RequestQueue(Cache cache, Network network, int threadPoolSize) {\n\t// 注意注意注意： 此处的 ExecutorDelivery 是通过主线程的 Looper 创建的，也就是说此 ExecutorDelivery 执行在主线程中（异步请求的重点）\n\tthis(cache, network, threadPoolSize,new ExecutorDelivery(new Handler(Looper.getMainLooper())));\n  }\n\n  public Request add(Request request) {\n\n\t//······省略一些代码······\n\n\t// 不需要缓存，直接加入队列中\n\tif (!request.shouldCache()) {\n\t  mNetworkQueue.add(request);\n\t  return request;\n\t}\n\n\tsynchronized (mWaitingRequests) {\n\t  String cacheKey = request.getCacheKey();\n\t  if (mWaitingRequests.containsKey(cacheKey)) {\n\t\t//等待队列存在此网络请求\n\t\tQueue<Request> stagedRequests = mWaitingRequests.get(cacheKey);\n\t\tif (stagedRequests == null) {\n\t\t  stagedRequests = new LinkedList<Request>();\n\t\t}\n\t\tstagedRequests.add(request);\n\t\tmWaitingRequests.put(cacheKey, stagedRequests);\n\t\tif (VolleyLog.DEBUG) {\n\t\t  VolleyLog.v(\"Request for cacheKey=%s is in flight, putting on hold.\", cacheKey);\n\t\t}\n\t  } else {\n\t\t//等待队列不存在此网络请求，加入等待队列中\n\t\tmWaitingRequests.put(cacheKey, null);\n\t  }\n\t  return request;\n  }\n```\n\n\t\n- NetworkDispatcher（extends Thread）\n\n  run 方法执行网络请求并异步回调结果的代码如下\n\n  ```java\n  public void run() {\n    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n    Request request;\n    while (true) {\n\n      //······省略一些代码······\n\n      try {\n        request.addMarker(\"network-queue-take\");\n        if (request.isCanceled()) {\n          request.finish(\"network-discard-cancelled\");\n          continue;\n        }\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {\n          TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());\n        }\n        //在此处通过 NetWork 进行网络请求并且的搭配返回的 NetworkResponse\n        NetworkResponse networkResponse = mNetwork.performRequest(request);\n        request.addMarker(\"network-http-complete\");\n\n        //······省略一些代码······\n\n        //在此进行对网络请求进行缓存\n        if (request.shouldCache() && response.cacheEntry != null) {\n          mCache.put(request.getCacheKey(), response.cacheEntry);\n          request.addMarker(\"network-cache-written\");\n        }\n        request.markDelivered();\n        // 注意注意注意：在此通过 ExecutorDelivery（执行在主线程中）将 response 异步回调到主线程的 request 回调函数中处理结果\n        mDelivery.postResponse(request, response);\n      } catch (VolleyError volleyError) {\n        parseAndDeliverNetworkError(request, volleyError);\n      } catch (Exception e) {\n        VolleyLog.e(e, \"Unhandled exception %s\", e.toString());\n        mDelivery.postError(request, new VolleyError(e));\n      }\n    }\n  }\n```\n\n- ResponseDelivery  (对在 NetworkDispatcher 网络请求返回的 Response 进行通过 Request 的deliverResponse(T response) )ResponseDelivery 接口的实现类：ExecutorDelivery\n","slug":"Android Volley","published":1,"updated":"2018-07-22T02:57:44.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzcc0006s8o5dd3hp2hn","content":"<h5 id=\"简单介绍一下-Volley\"><a href=\"#简单介绍一下-Volley\" class=\"headerlink\" title=\"简单介绍一下 Volley\"></a>简单介绍一下 Volley</h5><ul>\n<li>Volley 是一个 Http 协议的 Android 网络框架，它可以自动调度 App 的网络请求，可以并发执行网络请求，具有自己的一套网络请求的响应缓存（和 HTTP 的缓存不一样）。Volley 还支持设置优先级的网络请求，中断正在执行的网络请求。<strong>Volley 支持开发者自定义网络请求返回的类型。</strong>总的来说 Volley 就是一个异步网络请求的框架。</li>\n</ul>\n<a id=\"more\"></a>\n<h5 id=\"如何在-Android-项目中引入-Volley\"><a href=\"#如何在-Android-项目中引入-Volley\" class=\"headerlink\" title=\"如何在 Android 项目中引入 Volley\"></a>如何在 Android 项目中引入 Volley</h5><p><strong>框架比较老，并且没有更新了，所以强烈建议使用方法二。jar 包可以搜索一下就能找到</strong></p>\n<ul>\n<li><p>方法一：</p>\n<p>直接在 Android 的依赖 Gradle 文件中添加依赖（但是不知道为什么总是下载不下来）</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.volley:volley:1.1.1'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法二：</p>\n<p>下载 Volley jar 包，添加到项目的 libs 目录下，并添加 Jar dependency </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation files(<span class=\"string\">'libs/volley.jar'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三：</p>\n<p>去 Volley 的 Github 仓库 clone 源码，并在 Android 的项目中进行 import module </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/google/volley</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"使用-Volley-实现一个简单的网络请求\"><a href=\"#使用-Volley-实现一个简单的网络请求\" class=\"headerlink\" title=\"使用 Volley 实现一个简单的网络请求\"></a>使用 Volley 实现一个简单的网络请求</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = MainActivity.class.getSimpleName();</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 网络请求的队列(通常在 Application 类中初始化，并全局唯一一个 RequestQueue)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RequestQueue mRequestQueue;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String URL = <span class=\"string\">\"http://www.awqingnian.xyz/2018/07/18/Android%20View/\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化 RequestQueue</span></span><br><span class=\"line\">mRequestQueue = Volley.newRequestQueue(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"comment\">//执行一个返回 String 的网络请求</span></span><br><span class=\"line\">StringRequest request = <span class=\"keyword\">new</span> StringRequest(Request.Method.GET, URL,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(String response)</span> </span>&#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">\"onResponse: \"</span> + response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"keyword\">new</span> Response.ErrorListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> </span>&#123;</span><br><span class=\"line\">        Log.d(TAG, <span class=\"string\">\"onErrorResponse: 网络请求错误   \"</span> + error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将网络请求添加到请求队列中（队列自动执行网络请求）</span></span><br><span class=\"line\">mRequestQueue.add(request);</span><br></pre></td></tr></table></figure>\n<p>当然上面举的例子是简单的例子，Volley 的网络请求不仅仅只有返回 String 类型的，还有其他很多类型。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Request</th>\n<th style=\"text-align:center\">返回类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ImageRequest</td>\n<td style=\"text-align:center\">请求指定 image 的 Url 返回一个解码的 Bitmap</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ClearCacheRequest</td>\n<td style=\"text-align:center\">用于清除 Volley 网络请求缓存</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">StringRequest</td>\n<td style=\"text-align:center\">请求指定 Url 返回 String 类型的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">JsonRequest</td>\n<td style=\"text-align:center\">请求指定 Url 返回 JSON 值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">JsonObjectRequest</td>\n<td style=\"text-align:center\">请求指定 Url 返回 JsonObject</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">JsonArrayRequest</td>\n<td style=\"text-align:center\">请求指定 Url 返回 JsonArray</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"自定义-Request-（高级用法）\"><a href=\"#自定义-Request-（高级用法）\" class=\"headerlink\" title=\"自定义 Request （高级用法）\"></a>自定义 Request （高级用法）</h5><ul>\n<li><p>主要是通过请求 Url 返回的 json，经过 Gson 解析，以及 java 泛型的传入的 Class<t>，返回 T 类所对应的对象。当然开发者可以自定义很多类型的返回类型，怎么自定义，参考 Request 源码的写法加上自己的思考就能实现。下面介绍自定义 Request ，返回 List 集合：</t></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 继承 Request ，并将泛型 &lt;T&gt; 传入</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiyGSONRequest</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Request</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Response.Listener&lt;List&lt;T&gt;&gt; mListener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;T&gt; mClass;</span><br><span class=\"line\">    <span class=\"comment\">//5 参数构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DiyGSONRequest</span><span class=\"params\">(<span class=\"keyword\">int</span> method, String url, Class&lt;T&gt; clazz, Response.Listener&lt;List&lt;T&gt;&gt; listener, Response.ErrorListener errorListener)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(method, url, errorListener);</span><br><span class=\"line\">        mClass = clazz;</span><br><span class=\"line\">        mListener = listener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//4 参数构造方法    （默认请求类型 GET）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiyGSONRequest</span><span class=\"params\">(String url, Class&lt;T&gt; clazz, Response.Listener&lt;List&lt;T&gt;&gt; listener, Response.ErrorListener errorListener)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(Method.GET, url, clazz, listener, errorListener);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//请求成功后，对 networkResponse 进行解析成泛型 T 的对象</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Response&lt;T&gt; <span class=\"title\">parseNetworkResponse</span><span class=\"params\">(NetworkResponse networkResponse)</span> </span>&#123;</span><br><span class=\"line\">        String jsonData;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            jsonData = <span class=\"keyword\">new</span> String(networkResponse.data, HttpHeaderParser.parseCharset(networkResponse.headers));</span><br><span class=\"line\">            List&lt;T&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            JsonArray array = <span class=\"keyword\">new</span> JsonParser().parse(jsonData).getAsJsonArray();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (JsonElement element : array) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Gson 解析</span></span><br><span class=\"line\">                list.add(<span class=\"keyword\">new</span> Gson().fromJson(element, mClass));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Response&lt;T&gt;) Response.success(list, HttpHeaderParser.parseCacheHeaders(networkResponse));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Response.error(<span class=\"keyword\">new</span> ParseError(e));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverResponse</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        mListener.onResponse((List&lt;T&gt;) t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据类型可以使用这组数据测试</span><br><span class=\"line\">[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;北京&quot;&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;上海&quot;&#125;,&#123;&quot;id&quot;:3,&quot;name&quot;:&quot;天津&quot;&#125;,&#123;&quot;id&quot;:4,&quot;name&quot;:&quot;重庆&quot;&#125;]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"简单介绍-Volley-的几个重要的类\"><a href=\"#简单介绍-Volley-的几个重要的类\" class=\"headerlink\" title=\"简单介绍 Volley 的几个重要的类\"></a>简单介绍 Volley 的几个重要的类</h5><ul>\n<li><p>Request （网络请求的基类）</p>\n<p>构造方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Request</span><span class=\"params\">(String url, Response.ErrorListener listener)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(Method.DEPRECATED_GET_OR_POST, url, listener);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  method: 请求类型（GET : 0, POST : 1, PUT : 2, DELETE : 3）</span></span><br><span class=\"line\"><span class=\"comment\"> *  url: 请求地址的 Url</span></span><br><span class=\"line\"><span class=\"comment\"> *  Response.ErrorListener : 请求错误的回调接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Request</span><span class=\"params\">(<span class=\"keyword\">int</span> method, String url, Response.ErrorListener listener)</span> </span>&#123;</span><br><span class=\"line\"> mMethod = method;</span><br><span class=\"line\"> mUrl = url;</span><br><span class=\"line\"> mErrorListener = listener;</span><br><span class=\"line\"> setRetryPolicy(<span class=\"keyword\">new</span> DefaultRetryPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\"> mDefaultTrafficStatsTag = TextUtils.isEmpty(url) ? <span class=\"number\">0</span>: Uri.parse(url).getHost().hashCode();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Request 子类必须实现的抽象方法，当执行该网络请求成功后，将网络请求回调到此接口方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverResponse</span><span class=\"params\">(T response)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Volley（用来实例化 RequestQueue 实例）</p>\n<p>获取 RequestQueue 实例的方法在 Volley 类中统一管理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestQueue <span class=\"title\">newRequestQueue</span><span class=\"params\">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 配置缓存的路径文件（Volley 的缓存模块）</span></span><br><span class=\"line\">  File cacheDir = <span class=\"keyword\">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class=\"line\"></span><br><span class=\"line\">  String userAgent = <span class=\"string\">\"volley/0\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    String packageName = context.getPackageName();</span><br><span class=\"line\">    PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class=\"number\">0</span>);</span><br><span class=\"line\">    userAgent = packageName + <span class=\"string\">\"/\"</span> + info.versionCode;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (NameNotFoundException e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//现在手机 SDK 基本都在 19 以上，所以只要关注这块就行了。</span></span><br><span class=\"line\">      <span class=\"comment\">//HurlStack 就是一个底层封装了 HttpURLConnection 的类，主要用来执行网络请求。</span></span><br><span class=\"line\">      stack = <span class=\"keyword\">new</span> HurlStack();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      stack = <span class=\"keyword\">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    <span class=\"comment\">// BasicNetwork 是一个获取 HurlStack 执行完网络请求获取 Response 的类</span></span><br><span class=\"line\">  Network network = <span class=\"keyword\">new</span> BasicNetwork(stack);</span><br><span class=\"line\">    <span class=\"comment\">// RequestQueue 默认有缓存，在此初始化 RequestQueue</span></span><br><span class=\"line\">  RequestQueue queue = <span class=\"keyword\">new</span> RequestQueue(<span class=\"keyword\">new</span> DiskBasedCache(cacheDir), network);</span><br><span class=\"line\">  <span class=\"comment\">//在此处开始对 RequestQueue 的 CacheDispatcher（执行缓存线程） 和 NetworkDispatcher（执行网络请求线程） 进行初始化并且开启线程，不断地从 RequestQueue 中取出 request 执行。</span></span><br><span class=\"line\">  queue.start();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Cache （进行对网络请求缓存的操作类）</p>\n<p>Cache 接口的具体实现类：DiskBasedCache</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">重要方法或变量</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">mTotalSize</td>\n<td style=\"text-align:center\">已经使用的缓存空间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mRootDirectory</td>\n<td style=\"text-align:center\">缓存所在的根目录（默认：”volley”）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mMaxCacheSizeInBytes</td>\n<td style=\"text-align:center\">最大缓存空间大小（默认：5 * 1024 * 1024（5M））</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">clear()</td>\n<td style=\"text-align:center\">清除缓存</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">get(String key)</td>\n<td style=\"text-align:center\">获取缓存实例（E）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">initialize()</td>\n<td style=\"text-align:center\">初始化缓存，并将读取所有缓存存在集合中（mEntries）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">put(String key, Entry entry)</td>\n<td style=\"text-align:center\">存入缓存</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">remove(String key)</td>\n<td style=\"text-align:center\">删除指定 key 值的缓存</td>\n</tr>\n</tbody>\n</table>\n<p>其中 Entry 是缓存操作的类。</p>\n<ul>\n<li><p>RequestQueue（网络请求的队列）</p>\n<p>主要方法如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize,ResponseDelivery delivery)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 之前传入的 DiskBasedCache 实例，用于缓存</span></span><br><span class=\"line\">mCache = cache;</span><br><span class=\"line\"><span class=\"comment\">// 用于使用 HttpUrlConnection 执行网络请求并且得到 Response</span></span><br><span class=\"line\">mNetwork = network;</span><br><span class=\"line\"><span class=\"comment\">// 执行网络请求的线程数量（默认 4 个）</span></span><br><span class=\"line\">mDispatchers = <span class=\"keyword\">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class=\"line\">mDelivery = delivery;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 注意注意注意： 此处的 ExecutorDelivery 是通过主线程的 Looper 创建的，也就是说此 ExecutorDelivery 执行在主线程中（异步请求的重点）</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>(cache, network, threadPoolSize,<span class=\"keyword\">new</span> ExecutorDelivery(<span class=\"keyword\">new</span> Handler(Looper.getMainLooper())));</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Request <span class=\"title\">add</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//······省略一些代码······</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不需要缓存，直接加入队列中</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!request.shouldCache()) &#123;</span><br><span class=\"line\">  mNetworkQueue.add(request);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> request;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (mWaitingRequests) &#123;</span><br><span class=\"line\">  String cacheKey = request.getCacheKey();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//等待队列存在此网络请求</span></span><br><span class=\"line\">\tQueue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stagedRequests == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t  stagedRequests = <span class=\"keyword\">new</span> LinkedList&lt;Request&gt;();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstagedRequests.add(request);</span><br><span class=\"line\">\tmWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class=\"line\">\t  VolleyLog.v(<span class=\"string\">\"Request for cacheKey=%s is in flight, putting on hold.\"</span>, cacheKey);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//等待队列不存在此网络请求，加入等待队列中</span></span><br><span class=\"line\">\tmWaitingRequests.put(cacheKey, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> request;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>NetworkDispatcher（extends Thread）</p>\n<p>run 方法执行网络请求并异步回调结果的代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">  Request request;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//······省略一些代码······</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      request.addMarker(<span class=\"string\">\"network-queue-take\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (request.isCanceled()) &#123;</span><br><span class=\"line\">        request.finish(<span class=\"string\">\"network-discard-cancelled\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class=\"line\">        TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//在此处通过 NetWork 进行网络请求并且的搭配返回的 NetworkResponse</span></span><br><span class=\"line\">      NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class=\"line\">      request.addMarker(<span class=\"string\">\"network-http-complete\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//······省略一些代码······</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//在此进行对网络请求进行缓存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class=\"line\">        request.addMarker(<span class=\"string\">\"network-cache-written\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      request.markDelivered();</span><br><span class=\"line\">      <span class=\"comment\">// 注意注意注意：在此通过 ExecutorDelivery（执行在主线程中）将 response 异步回调到主线程的 request 回调函数中处理结果</span></span><br><span class=\"line\">      mDelivery.postResponse(request, response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (VolleyError volleyError) &#123;</span><br><span class=\"line\">      parseAndDeliverNetworkError(request, volleyError);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      VolleyLog.e(e, <span class=\"string\">\"Unhandled exception %s\"</span>, e.toString());</span><br><span class=\"line\">      mDelivery.postError(request, <span class=\"keyword\">new</span> VolleyError(e));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ResponseDelivery  (对在 NetworkDispatcher 网络请求返回的 Response 进行通过 Request 的deliverResponse(T response) )ResponseDelivery 接口的实现类：ExecutorDelivery</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h5 id=\"简单介绍一下-Volley\"><a href=\"#简单介绍一下-Volley\" class=\"headerlink\" title=\"简单介绍一下 Volley\"></a>简单介绍一下 Volley</h5><ul>\n<li>Volley 是一个 Http 协议的 Android 网络框架，它可以自动调度 App 的网络请求，可以并发执行网络请求，具有自己的一套网络请求的响应缓存（和 HTTP 的缓存不一样）。Volley 还支持设置优先级的网络请求，中断正在执行的网络请求。<strong>Volley 支持开发者自定义网络请求返回的类型。</strong>总的来说 Volley 就是一个异步网络请求的框架。</li>\n</ul>","more":"<h5 id=\"如何在-Android-项目中引入-Volley\"><a href=\"#如何在-Android-项目中引入-Volley\" class=\"headerlink\" title=\"如何在 Android 项目中引入 Volley\"></a>如何在 Android 项目中引入 Volley</h5><p><strong>框架比较老，并且没有更新了，所以强烈建议使用方法二。jar 包可以搜索一下就能找到</strong></p>\n<ul>\n<li><p>方法一：</p>\n<p>直接在 Android 的依赖 Gradle 文件中添加依赖（但是不知道为什么总是下载不下来）</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation <span class=\"string\">'com.android.volley:volley:1.1.1'</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法二：</p>\n<p>下载 Volley jar 包，添加到项目的 libs 目录下，并添加 Jar dependency </p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies &#123;</span><br><span class=\"line\">    implementation files(<span class=\"string\">'libs/volley.jar'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三：</p>\n<p>去 Volley 的 Github 仓库 clone 源码，并在 Android 的项目中进行 import module </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/google/volley</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"使用-Volley-实现一个简单的网络请求\"><a href=\"#使用-Volley-实现一个简单的网络请求\" class=\"headerlink\" title=\"使用 Volley 实现一个简单的网络请求\"></a>使用 Volley 实现一个简单的网络请求</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = MainActivity.class.getSimpleName();</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 网络请求的队列(通常在 Application 类中初始化，并全局唯一一个 RequestQueue)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> RequestQueue mRequestQueue;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String URL = <span class=\"string\">\"http://www.awqingnian.xyz/2018/07/18/Android%20View/\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化 RequestQueue</span></span><br><span class=\"line\">mRequestQueue = Volley.newRequestQueue(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"comment\">//执行一个返回 String 的网络请求</span></span><br><span class=\"line\">StringRequest request = <span class=\"keyword\">new</span> StringRequest(Request.Method.GET, URL,</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onResponse</span><span class=\"params\">(String response)</span> </span>&#123;</span><br><span class=\"line\">                Log.d(TAG, <span class=\"string\">\"onResponse: \"</span> + response);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, <span class=\"keyword\">new</span> Response.ErrorListener() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onErrorResponse</span><span class=\"params\">(VolleyError error)</span> </span>&#123;</span><br><span class=\"line\">        Log.d(TAG, <span class=\"string\">\"onErrorResponse: 网络请求错误   \"</span> + error);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将网络请求添加到请求队列中（队列自动执行网络请求）</span></span><br><span class=\"line\">mRequestQueue.add(request);</span><br></pre></td></tr></table></figure>\n<p>当然上面举的例子是简单的例子，Volley 的网络请求不仅仅只有返回 String 类型的，还有其他很多类型。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Request</th>\n<th style=\"text-align:center\">返回类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ImageRequest</td>\n<td style=\"text-align:center\">请求指定 image 的 Url 返回一个解码的 Bitmap</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ClearCacheRequest</td>\n<td style=\"text-align:center\">用于清除 Volley 网络请求缓存</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">StringRequest</td>\n<td style=\"text-align:center\">请求指定 Url 返回 String 类型的值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">JsonRequest</td>\n<td style=\"text-align:center\">请求指定 Url 返回 JSON 值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">JsonObjectRequest</td>\n<td style=\"text-align:center\">请求指定 Url 返回 JsonObject</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">JsonArrayRequest</td>\n<td style=\"text-align:center\">请求指定 Url 返回 JsonArray</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"自定义-Request-（高级用法）\"><a href=\"#自定义-Request-（高级用法）\" class=\"headerlink\" title=\"自定义 Request （高级用法）\"></a>自定义 Request （高级用法）</h5><ul>\n<li><p>主要是通过请求 Url 返回的 json，经过 Gson 解析，以及 java 泛型的传入的 Class<t>，返回 T 类所对应的对象。当然开发者可以自定义很多类型的返回类型，怎么自定义，参考 Request 源码的写法加上自己的思考就能实现。下面介绍自定义 Request ，返回 List 集合：</t></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 继承 Request ，并将泛型 &lt;T&gt; 传入</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiyGSONRequest</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Request</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Response.Listener&lt;List&lt;T&gt;&gt; mListener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;T&gt; mClass;</span><br><span class=\"line\">    <span class=\"comment\">//5 参数构造方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">DiyGSONRequest</span><span class=\"params\">(<span class=\"keyword\">int</span> method, String url, Class&lt;T&gt; clazz, Response.Listener&lt;List&lt;T&gt;&gt; listener, Response.ErrorListener errorListener)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(method, url, errorListener);</span><br><span class=\"line\">        mClass = clazz;</span><br><span class=\"line\">        mListener = listener;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//4 参数构造方法    （默认请求类型 GET）</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DiyGSONRequest</span><span class=\"params\">(String url, Class&lt;T&gt; clazz, Response.Listener&lt;List&lt;T&gt;&gt; listener, Response.ErrorListener errorListener)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(Method.GET, url, clazz, listener, errorListener);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//请求成功后，对 networkResponse 进行解析成泛型 T 的对象</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Response&lt;T&gt; <span class=\"title\">parseNetworkResponse</span><span class=\"params\">(NetworkResponse networkResponse)</span> </span>&#123;</span><br><span class=\"line\">        String jsonData;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            jsonData = <span class=\"keyword\">new</span> String(networkResponse.data, HttpHeaderParser.parseCharset(networkResponse.headers));</span><br><span class=\"line\">            List&lt;T&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">            JsonArray array = <span class=\"keyword\">new</span> JsonParser().parse(jsonData).getAsJsonArray();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (JsonElement element : array) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Gson 解析</span></span><br><span class=\"line\">                list.add(<span class=\"keyword\">new</span> Gson().fromJson(element, mClass));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (Response&lt;T&gt;) Response.success(list, HttpHeaderParser.parseCacheHeaders(networkResponse));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Response.error(<span class=\"keyword\">new</span> ParseError(e));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverResponse</span><span class=\"params\">(T t)</span> </span>&#123;</span><br><span class=\"line\">        mListener.onResponse((List&lt;T&gt;) t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据类型可以使用这组数据测试</span><br><span class=\"line\">[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;北京&quot;&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;上海&quot;&#125;,&#123;&quot;id&quot;:3,&quot;name&quot;:&quot;天津&quot;&#125;,&#123;&quot;id&quot;:4,&quot;name&quot;:&quot;重庆&quot;&#125;]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"简单介绍-Volley-的几个重要的类\"><a href=\"#简单介绍-Volley-的几个重要的类\" class=\"headerlink\" title=\"简单介绍 Volley 的几个重要的类\"></a>简单介绍 Volley 的几个重要的类</h5><ul>\n<li><p>Request （网络请求的基类）</p>\n<p>构造方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Request</span><span class=\"params\">(String url, Response.ErrorListener listener)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(Method.DEPRECATED_GET_OR_POST, url, listener);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  method: 请求类型（GET : 0, POST : 1, PUT : 2, DELETE : 3）</span></span><br><span class=\"line\"><span class=\"comment\"> *  url: 请求地址的 Url</span></span><br><span class=\"line\"><span class=\"comment\"> *  Response.ErrorListener : 请求错误的回调接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Request</span><span class=\"params\">(<span class=\"keyword\">int</span> method, String url, Response.ErrorListener listener)</span> </span>&#123;</span><br><span class=\"line\"> mMethod = method;</span><br><span class=\"line\"> mUrl = url;</span><br><span class=\"line\"> mErrorListener = listener;</span><br><span class=\"line\"> setRetryPolicy(<span class=\"keyword\">new</span> DefaultRetryPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\"> mDefaultTrafficStatsTag = TextUtils.isEmpty(url) ? <span class=\"number\">0</span>: Uri.parse(url).getHost().hashCode();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Request 子类必须实现的抽象方法，当执行该网络请求成功后，将网络请求回调到此接口方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">deliverResponse</span><span class=\"params\">(T response)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Volley（用来实例化 RequestQueue 实例）</p>\n<p>获取 RequestQueue 实例的方法在 Volley 类中统一管理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> RequestQueue <span class=\"title\">newRequestQueue</span><span class=\"params\">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 配置缓存的路径文件（Volley 的缓存模块）</span></span><br><span class=\"line\">  File cacheDir = <span class=\"keyword\">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class=\"line\"></span><br><span class=\"line\">  String userAgent = <span class=\"string\">\"volley/0\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    String packageName = context.getPackageName();</span><br><span class=\"line\">    PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class=\"number\">0</span>);</span><br><span class=\"line\">    userAgent = packageName + <span class=\"string\">\"/\"</span> + info.versionCode;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (NameNotFoundException e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stack == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= <span class=\"number\">9</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//现在手机 SDK 基本都在 19 以上，所以只要关注这块就行了。</span></span><br><span class=\"line\">      <span class=\"comment\">//HurlStack 就是一个底层封装了 HttpURLConnection 的类，主要用来执行网络请求。</span></span><br><span class=\"line\">      stack = <span class=\"keyword\">new</span> HurlStack();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      stack = <span class=\"keyword\">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    <span class=\"comment\">// BasicNetwork 是一个获取 HurlStack 执行完网络请求获取 Response 的类</span></span><br><span class=\"line\">  Network network = <span class=\"keyword\">new</span> BasicNetwork(stack);</span><br><span class=\"line\">    <span class=\"comment\">// RequestQueue 默认有缓存，在此初始化 RequestQueue</span></span><br><span class=\"line\">  RequestQueue queue = <span class=\"keyword\">new</span> RequestQueue(<span class=\"keyword\">new</span> DiskBasedCache(cacheDir), network);</span><br><span class=\"line\">  <span class=\"comment\">//在此处开始对 RequestQueue 的 CacheDispatcher（执行缓存线程） 和 NetworkDispatcher（执行网络请求线程） 进行初始化并且开启线程，不断地从 RequestQueue 中取出 request 执行。</span></span><br><span class=\"line\">  queue.start();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Cache （进行对网络请求缓存的操作类）</p>\n<p>Cache 接口的具体实现类：DiskBasedCache</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">重要方法或变量</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">mTotalSize</td>\n<td style=\"text-align:center\">已经使用的缓存空间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mRootDirectory</td>\n<td style=\"text-align:center\">缓存所在的根目录（默认：”volley”）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">mMaxCacheSizeInBytes</td>\n<td style=\"text-align:center\">最大缓存空间大小（默认：5 * 1024 * 1024（5M））</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">clear()</td>\n<td style=\"text-align:center\">清除缓存</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">get(String key)</td>\n<td style=\"text-align:center\">获取缓存实例（E）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">initialize()</td>\n<td style=\"text-align:center\">初始化缓存，并将读取所有缓存存在集合中（mEntries）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">put(String key, Entry entry)</td>\n<td style=\"text-align:center\">存入缓存</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">remove(String key)</td>\n<td style=\"text-align:center\">删除指定 key 值的缓存</td>\n</tr>\n</tbody>\n</table>\n<p>其中 Entry 是缓存操作的类。</p>\n<ul>\n<li><p>RequestQueue（网络请求的队列）</p>\n<p>主要方法如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize,ResponseDelivery delivery)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 之前传入的 DiskBasedCache 实例，用于缓存</span></span><br><span class=\"line\">mCache = cache;</span><br><span class=\"line\"><span class=\"comment\">// 用于使用 HttpUrlConnection 执行网络请求并且得到 Response</span></span><br><span class=\"line\">mNetwork = network;</span><br><span class=\"line\"><span class=\"comment\">// 执行网络请求的线程数量（默认 4 个）</span></span><br><span class=\"line\">mDispatchers = <span class=\"keyword\">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class=\"line\">mDelivery = delivery;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RequestQueue</span><span class=\"params\">(Cache cache, Network network, <span class=\"keyword\">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 注意注意注意： 此处的 ExecutorDelivery 是通过主线程的 Looper 创建的，也就是说此 ExecutorDelivery 执行在主线程中（异步请求的重点）</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>(cache, network, threadPoolSize,<span class=\"keyword\">new</span> ExecutorDelivery(<span class=\"keyword\">new</span> Handler(Looper.getMainLooper())));</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Request <span class=\"title\">add</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//······省略一些代码······</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不需要缓存，直接加入队列中</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!request.shouldCache()) &#123;</span><br><span class=\"line\">  mNetworkQueue.add(request);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> request;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> (mWaitingRequests) &#123;</span><br><span class=\"line\">  String cacheKey = request.getCacheKey();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//等待队列存在此网络请求</span></span><br><span class=\"line\">\tQueue&lt;Request&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (stagedRequests == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t  stagedRequests = <span class=\"keyword\">new</span> LinkedList&lt;Request&gt;();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstagedRequests.add(request);</span><br><span class=\"line\">\tmWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class=\"line\">\t  VolleyLog.v(<span class=\"string\">\"Request for cacheKey=%s is in flight, putting on hold.\"</span>, cacheKey);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//等待队列不存在此网络请求，加入等待队列中</span></span><br><span class=\"line\">\tmWaitingRequests.put(cacheKey, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> request;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>NetworkDispatcher（extends Thread）</p>\n<p>run 方法执行网络请求并异步回调结果的代码如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class=\"line\">  Request request;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//······省略一些代码······</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      request.addMarker(<span class=\"string\">\"network-queue-take\"</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (request.isCanceled()) &#123;</span><br><span class=\"line\">        request.finish(<span class=\"string\">\"network-discard-cancelled\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class=\"line\">        TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//在此处通过 NetWork 进行网络请求并且的搭配返回的 NetworkResponse</span></span><br><span class=\"line\">      NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class=\"line\">      request.addMarker(<span class=\"string\">\"network-http-complete\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//······省略一些代码······</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//在此进行对网络请求进行缓存</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class=\"line\">        request.addMarker(<span class=\"string\">\"network-cache-written\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      request.markDelivered();</span><br><span class=\"line\">      <span class=\"comment\">// 注意注意注意：在此通过 ExecutorDelivery（执行在主线程中）将 response 异步回调到主线程的 request 回调函数中处理结果</span></span><br><span class=\"line\">      mDelivery.postResponse(request, response);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (VolleyError volleyError) &#123;</span><br><span class=\"line\">      parseAndDeliverNetworkError(request, volleyError);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      VolleyLog.e(e, <span class=\"string\">\"Unhandled exception %s\"</span>, e.toString());</span><br><span class=\"line\">      mDelivery.postError(request, <span class=\"keyword\">new</span> VolleyError(e));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ResponseDelivery  (对在 NetworkDispatcher 网络请求返回的 Response 进行通过 Request 的deliverResponse(T response) )ResponseDelivery 接口的实现类：ExecutorDelivery</p>\n</li>\n</ul>"},{"title":"Android 绘制过程","date":"2018-08-02T02:01:25.000Z","_content":"\n##### Android 的 setContentView 流程\n\n- （1）Activity 是 Android 中最直接的，也是最主要的显示界面，在 Activity 中，要通过 setContentView() 来设置当前 Activity 中的布局 Layout。\n\n- （2）setContentView() 是干嘛的？翻译过来，就是设置内容的 View 。如何设置？通过 Window 类来进行设置。通过源码发现，Activity 的 setContentView 方法实际上是调用 Window 的 setContentView 方法。\n\n  ```java\n  public void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n  }\n  ```\n\n- （3）但是呢，Window 是一个抽象类，具体需要去找出它的实现类。Window 是什么？官方一点来讲就是处理顶级窗口外观和行为策略的抽象基类。通俗来理解就是 Activity 通过 Window 来对 View 进行一系列的处理。并且通过源码的解释可以知道该抽象类的唯一实现类是 PhoneWindow.java 。\n\n  ```java\n  /**\n   * Abstract base class for a top-level window look and behavior policy.  An\n   * instance of this class should be used as the top-level view added to the\n   * window manager. It provides standard UI policies such as a background, title\n   * area, default key processing, etc.\n   *\n   * <p>The only existing implementation of this abstract class is\n   * android.view.PhoneWindow, which you should instantiate when needing a\n   * Window.\n   */\n  ```\n\n- （4）通过 Window 的注释，我们知道该类的唯一实现类就是 PhoneWindow ，并且 Activity 的 setContentView 方法实际是调用 Window 的 setContentView 方法，所以要去找 Window 的实现类 PhoneWindow 的 setContentView 方法。发现 PhoneWindow 中的 setContentView 中有 3 个重载方法，不过根据入参，需要找的是具有一个 int 参数的 setContentView 方法。\n\n  ```java\n  @Override\n  public void setContentView(int layoutResID) {\n    if (mContentParent == null) {\n      installDecor(); //注意此方法，下面会提到。\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n      mContentParent.removeAllViews(); // 删除所有子 View\n    }\n\n    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n      final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                                                     getContext());\n      transitionTo(newScene);\n    } else {\n      mLayoutInflater.inflate(layoutResID, mContentParent);//布局 layout 在方法中的使用\n    }\n    mContentParent.requestApplyInsets();\n    final Callback cb = getCallback();\n    if (cb != null && !isDestroyed()) {\n      cb.onContentChanged();\n    }\n    mContentParentExplicitlySet = true;\n  }\n  ```\n\n  由 View inflate(@LayoutRes int resource, @Nullable ViewGroup root) 方法可以大概知道，是将对应 layoutResID 的布局加载到 mContentParent 中去。\n\n- （5）installDecor 方法其实在 PhoneWindow 的 setContentView 方法中首先调用，由方法名翻译出来是：设置装饰，设置布局好一点（根据代码意思）。首先调用 installDecor 方法，说明先初始化 mDecor 的布局，所以要先理解一下 mDecor 是什么，才能知道 mContentParent 是对应哪个 View，以及它的层次结构。\n\n  ```java\n  private void installDecor() {\n   mForceDecorInstall = false;\n   if (mDecor == null) {\n     mDecor = generateDecor(-1); // mDecor 的初始化,在此会 new 出一个 Decor 对象返回\n     mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n     mDecor.setIsRootNamespace(true);\n     if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {\n       mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n     }\n   } else {\n     mDecor.setWindow(this);\n   }\n   if (mContentParent == null) {\n     mContentParent = generateLayout(mDecor); // mContentParent 的初始化\n\n     mDecor.makeOptionalFitsSystemWindows();\n\n     final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(\n       R.id.decor_content_parent);\n     //...省略下面源码\n  }\n  ```\n\n  初始化 mDecor，Decor 根据成员属性的解释知道是 window 的最顶层的 view（top-level）。由 mContentParent = generateLayout(mDecor); 代码自然地知道 mContentParent 的构造依赖于 Decor，并且 Decor 是最顶层的 View，所以自然推出 mContentParent 是 Decor 的子 View。\n\n  ```java\n  // This is the top-level view of the window, containing the window decor.、\n  private DecorView mDecor;\n\n  protected DecorView generateDecor(int featureId) {\n   Context context;\n   if (mUseDecorContext) {\n     Context applicationContext = getContext().getApplicationContext();\n     if (applicationContext == null) {\n       context = getContext();\n     } else {\n       context = new DecorContext(applicationContext, getContext().getResources());\n       if (mTheme != -1) {\n         context.setTheme(mTheme);\n       }\n     }\n   } else {\n     context = getContext();\n   }\n   // new 出一个 DecorView 对象，构造方法中调用 super.(context)。则会对 Decor 进行测量布局绘制等过程。\n   return new DecorView(context, featureId, this, getAttributes());\n  }\n  ```\n\n  初始化 mContentParent 的代码其实就是加载好 Decor 后在 Decor 中利用 findViewById 寻找到 mContentParent 的值并返回。不过要经历一大堆的处理，比如系统版本，App Theme 的配置等（具体不再深入）。\n\n  ```java\n  protected ViewGroup generateLayout(DecorView decor) {\n    // 省略的代码大概就是读取 window 的 theme 属性参数进行配置设置\n    //... 源码有点长 ，省略一点\n    // 并且在 window 中把 decor 加载进来\n\n    // Inflate the window decor.\n    int layoutResource;\n    int features = getLocalFeatures();\n    // 根据 features 的值进行逻辑判断，加载特定的 layoutResource （Decor 的标题 Layout 布局文件 Id）\n    mDecor.startChanging();\n    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);// 加载 Decor 的布局文件\n\n    // 这就是我们 setContentView 的布局文件加载到的父 ViewGroup 中（内容栏）\n    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n    if (contentParent == null) {\n      throw new RuntimeException(\"Window couldn't find content container view\");\n    }\n\n    if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {\n      ProgressBar progress = getCircularProgressBar(false);\n      if (progress != null) {\n        progress.setIndeterminate(true);\n      }\n    }\n    //... 源码有点长 ，省略一点\n  }\n  ```\n\n- 通过上面代码的追溯，可以找到 mContentParent 的父 View 是 Decor，以及 mContentParent 是在哪赋值的。现在再回到第（4）步中就非常清晰了，再 nstallDecor 方法调用后，mContentParent 就已经被赋值，并且 Decor（Window 根 Vew）已经被加载到 Window 中。再通过 LayoutInflater 将我们在 Activity 中设置的布局加载到 mContentParent 中。关于 Decor 的布局根据系统版本的不同而不同。\n\n##### 简单介绍一下 Measure 的重要参数值代表的意思。\n\n- MeasureSpec ：翻译过来就是测量规格，一个 View 的 MeasureSpec 计算数据由父 View 传下来的 MeasureSpec 和自己本身的 LayoutParams（xml 文件配置的 layout 属性的标签，如：layout_width 和 layout_height） 决定。MeasureSpec 是一个 32 位的 int 值，存储方式是以**二进制存储**，高 2 位代表 SpecMode（测量模式），低 30 位代表是 SpecSize（规格大小）。\n\n- SpecMode 对 View 测量规格的影响如下。父 View 的测量过程会先测量子 View，是一个树形的的递归测量实现，所以先测量完子 View，等到没有子 View 的时候在测量父 View 本身。\n\n\n\n  |                     父 View 的 SpecMode                      |               子 View 的 LayoutParams               |                 子 View 的 Size 和 Mode 情况                 |\n  | :----------------------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------------: |\n  | <br />EXACTLY<br />父 View 已经检测到子 View 的大小，最终大小就是 SpecSize | 1. 确切值<br />2. match_parent<br />3. wrap_content | 1. size = 计算出来的值，mode = EXACTLY<br />2. size =  父 View size ，mode = EXACTLY<br />3. size =  父 View size ，mode = AT_MOST |\n  |      <br />AT_MOST<br />父容器指定子 View Size 的最大值      | 1. 确切值<br />2. match_parent<br />3. wrap_content | 1. size = 计算出来的值，mode = EXACTLY<br />2. size =  父 View size ，mode = AT_MOST<br />3. size =  父 View size ，mode = AT_MOST |\n  |     <br />UNSPECIFIED<br />父容器对子 View 的大小没限制      | 1. 确切值<br />2. match_parent<br />3. wrap_content | 1. size = 计算出来的值，mode = EXACTLY<br />2. size =  0 ，mode = UNSPECIFIED<br />3. size =  0，mode = UNSPECIFIED |\n\n  总结一下：\n\n  - 子 View 的 LayoutParams 是确切的，那么无论父 View 是 specMode 是怎样的，子 View 的 size 都是开发设置的确切值，子 View 的 size 被确定，所以子 View 的 specMode = EXACTLY；\n  - 子 View 的 LayoutParams = match_parent（充满父 View）。当父 View 的 specMode 是 EXACTLY ，父 View 的 size 已经是确定的，那么子 View 的 size = 父 View 的 size，子 View 的 size 被确定，所以子 View 的 specMode = EXACTLY。当父 View 的 specMode 是 AT_MOST，也就是说父 View 的 size 是不确切的，但是父 View 有个最大 size 值，具体 size 需要根据子 View 的 size 确定，子 View 要充满父 View，应该子 View 的 size = 父 View 的 size，父 View 的大小不确定，子 View 要充满父 View，所以子 View 的 size 不确定，specMode 也应该是 AT_MOST。当父 View 的 specMode = UNSPECIFIED ，没有限制，不可能把子 View 的 size 设置成无限大，所以暂时设置成 0 ，specMode = UNSPECIFIED，父 View 无限制，父 View 的 size 无确切值和最大值，子 View 充满父 View，子 View 的 specMode 也应该是 UNSPECIFIED。\n  - 子 View 的LayoutParams = wrap_content（包含内容的大小）。当父 View 的 specMode = EXACTLY 或 AT_MOST 时，不管父 View 的大小是否确定，在这 2 种 specMode 中，都有一个确切值或者最大值，子 View 的大小要根据内容决定，子 View 的 size 大小又不能超过父 View，所以子 View 的 size 肯定是一个不确定的值，specMode 应该是 AT_MOST，size 应该是父 View 的确切值或者是最大值。当父 View 的 specMode = UNSPECIFIED，没有限制，不可能把子 View 的 size 设置成无限大，所以暂时设置成 0 ，父 View 无限制，父 View 的 size 无确切值和最大值，子 View 的 size 是由子 View 的内容决定，子 View 的 specMode 也应该是 UNSPECIFIED。\n\n  计算 MeasureSpec 的源代码实现如下：\n\n  ```java\n  public static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n      int specMode = MeasureSpec.getMode(spec);\n      int specSize = MeasureSpec.getSize(spec);\n      int size = Math.max(0, specSize - padding);\n      int resultSize = 0;\n      int resultMode = 0;\n      switch (specMode) {\n          case MeasureSpec.EXACTLY:\n              if (childDimension >= 0) {\n                  resultSize = childDimension;\n                  resultMode = MeasureSpec.EXACTLY;\n              } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                  resultSize = size;\n                  resultMode = MeasureSpec.EXACTLY;\n              } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                  resultSize = size;\n                  resultMode = MeasureSpec.AT_MOST;\n              }\n              break;\n          case MeasureSpec.AT_MOST:\n              if (childDimension >= 0) {\n                  resultSize = childDimension;\n                  resultMode = MeasureSpec.EXACTLY;\n              } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                  resultSize = size;\n                  resultMode = MeasureSpec.AT_MOST;\n              } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                  resultSize = size;\n                  resultMode = MeasureSpec.AT_MOST;\n              }\n              break;\n          case MeasureSpec.UNSPECIFIED:\n              if (childDimension >= 0) {\n                  resultSize = childDimension;\n                  resultMode = MeasureSpec.EXACTLY;\n              } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                  resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                  resultMode = MeasureSpec.UNSPECIFIED;\n              } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                  resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                  resultMode = MeasureSpec.UNSPECIFIED;\n              }\n              break;\n      }\n      return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n  }\n  ```\n\n##### 从 DecorView 到其子 View 的 Measure 过程\n\n- 由上面分析知道，一个 Activity 的最顶级的 View 就是 DecorView，那么测量过程就应该从 DecorView 以树形结构往 DecorView 的子 View 开始递归实现。对于 DecorView ，它的 MeasureSpec 不同普通 View 那样决定，它的决定是由窗口的尺寸和自身的 LayoutParams 来决定（普通 View 的 MeasureSpec 的决定由父 View 的 MeasureSpec 和自身的 LayoutParams）。那么 DecorView 什么时候开始测量？上面提到，在 PhoneWindow 中的 setContentView 方法中调用 installDecor 方法，在 installDecor 方法里面会初始化一个 DecorView，初始化一个 View ，自然要对 View 进行测量。\n\n- View 的测量是由 measure 方法工作的，measure 方法是 final ，说明此方法不能重写，而在 measure 方法中最终会调用 onMeasure 方法，所以要看 onMeasure 方法。\n\n  ```java\n  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n      setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                           getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n  }\n  ```\n\n  setMeasuredDimension 会设置 View 的宽/高的测量值。在 View 的子类中，要计算出 widthMeasureSpec 和 heightMeasureSpec 的实际值，再调用 super.measure 方法或者直接调用 setMeasuredDimension 方法设定 View 的宽/高测量值。\n\n  getDefaultSize 方法是干嘛的呢？返回 View 测量后的大小。\n\n  ```java\n  public static int getDefaultSize(int size, int measureSpec) {\n      // View 的默认大小。\n      //View 无背景：由 android_minXXX 决定，View 有背景：android_minXXX 和 背景的宽/高取最大值\n      int result = size;\n      int specMode = MeasureSpec.getMode(measureSpec);// 测量得出的 View 的 mode\n      int specSize = MeasureSpec.getSize(measureSpec);// 测量得出的 View 的 size\n      switch (specMode) {\n          case MeasureSpec.UNSPECIFIED:\n              result = size;\n              break;\n          case MeasureSpec.AT_MOST:\n          case MeasureSpec.EXACTLY:\n              result = specSize;\n              break;\n      }\n      return result;\n  }\n  ```\n\n  **在自定义 View 中，要注意重写 onMeasure 方法，并设置 wrap_content 时的自身大小。**\n\n  当 View 的 Layout_Params = wrap_content 时，由上面的表格知道，View 的 specMode 是 AT_MOST，由 getDefaultSize 方法逻辑知道，计算的最终大小是 specSize，而这个 specSize 就是父 View 的可使用的的大小，子 View 的 specSize = 父 View 的 specSize，就如同 match_parent 的效果。\n\n  避免上面问题，重写 onMeasure 方法如下：\n\n  ````java\n  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){\n      super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n      int width; \t// view 的默认宽度\n      int height; // view 的默认高度\n\n      int widthSpecMode = mewsureSpec.getMode(widthMeasureSpec);// 父 View 的宽度 specMode\n      int widthSpecSize = mewsureSpec.getSzie(widthMeasureSpec);// 父 View 的宽度 specSize\n      int heightSpecMode = mewsureSpec.getMode(heightMeasureSpec);// 父 View 的高度 specMode\n      int heightSpecSize = mewsureSpec.getSzie(heightMeasureSpec);// 父 View 的高度 specSize\n      if (widthSpecMode == MeasureSpec.AT_MOST && heightSpecMode == MeasureSpec.AT_MOST){\n          setMeasuredDimension(width, height);\n      } else if (widthSpecMode == MeasureSpec.AT_MOST){\n          setMeasuredDimension(width, heightSpecSize);\n      } else if (heightSpecMode == MeasureSpec.AT_MOST){\n          setMeasuredDimension(widthSpecSize, height);\n      }\n  }\n  ````\n\n- ViewGroup 的测量除了要测量自己，还要遍历它所有子 View 的 measure 过程，最后完成测量过程。具体遍历子 View 的过程是由 measureChildren 方法实现，调用子 View 的测量方法是 measureChild 方法实现。\n\n  ```java\n  protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {\n      final int size = mChildrenCount;\n      final View[] children = mChildren;\n      for (int i = 0; i < size; ++i) {// 遍历子 View\n          final View child = children[i];\n          if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {\n              measureChild(child, widthMeasureSpec, heightMeasureSpec);\n          }\n      }\n  }\n  protected void measureChild(View child, int parentWidthMeasureSpec,\n              int parentHeightMeasureSpec) {\n      final LayoutParams lp = child.getLayoutParams();\n      final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                  mPaddingLeft + mPaddingRight, lp.width);\n      final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                  mPaddingTop + mPaddingBottom, lp.height);\n      child.measure(childWidthMeasureSpec, childHeightMeasureSpec); // 调用子 View 的测量方法\n  }\n  ```\n\n\n\n- 当调用完 setMeasuredDimension ，将测量的值传入，测量的过程就完成了。\n","source":"_posts/Android 绘制过程.md","raw":"\ntitle: Android 绘制过程\ndate: 2018-08-02 10:01:25\ntags:\n\n---\n\n##### Android 的 setContentView 流程\n\n- （1）Activity 是 Android 中最直接的，也是最主要的显示界面，在 Activity 中，要通过 setContentView() 来设置当前 Activity 中的布局 Layout。\n\n- （2）setContentView() 是干嘛的？翻译过来，就是设置内容的 View 。如何设置？通过 Window 类来进行设置。通过源码发现，Activity 的 setContentView 方法实际上是调用 Window 的 setContentView 方法。\n\n  ```java\n  public void setContentView(@LayoutRes int layoutResID) {\n    getWindow().setContentView(layoutResID);\n    initWindowDecorActionBar();\n  }\n  ```\n\n- （3）但是呢，Window 是一个抽象类，具体需要去找出它的实现类。Window 是什么？官方一点来讲就是处理顶级窗口外观和行为策略的抽象基类。通俗来理解就是 Activity 通过 Window 来对 View 进行一系列的处理。并且通过源码的解释可以知道该抽象类的唯一实现类是 PhoneWindow.java 。\n\n  ```java\n  /**\n   * Abstract base class for a top-level window look and behavior policy.  An\n   * instance of this class should be used as the top-level view added to the\n   * window manager. It provides standard UI policies such as a background, title\n   * area, default key processing, etc.\n   *\n   * <p>The only existing implementation of this abstract class is\n   * android.view.PhoneWindow, which you should instantiate when needing a\n   * Window.\n   */\n  ```\n\n- （4）通过 Window 的注释，我们知道该类的唯一实现类就是 PhoneWindow ，并且 Activity 的 setContentView 方法实际是调用 Window 的 setContentView 方法，所以要去找 Window 的实现类 PhoneWindow 的 setContentView 方法。发现 PhoneWindow 中的 setContentView 中有 3 个重载方法，不过根据入参，需要找的是具有一个 int 参数的 setContentView 方法。\n\n  ```java\n  @Override\n  public void setContentView(int layoutResID) {\n    if (mContentParent == null) {\n      installDecor(); //注意此方法，下面会提到。\n    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n      mContentParent.removeAllViews(); // 删除所有子 View\n    }\n\n    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {\n      final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,\n                                                     getContext());\n      transitionTo(newScene);\n    } else {\n      mLayoutInflater.inflate(layoutResID, mContentParent);//布局 layout 在方法中的使用\n    }\n    mContentParent.requestApplyInsets();\n    final Callback cb = getCallback();\n    if (cb != null && !isDestroyed()) {\n      cb.onContentChanged();\n    }\n    mContentParentExplicitlySet = true;\n  }\n  ```\n\n  由 View inflate(@LayoutRes int resource, @Nullable ViewGroup root) 方法可以大概知道，是将对应 layoutResID 的布局加载到 mContentParent 中去。\n\n- （5）installDecor 方法其实在 PhoneWindow 的 setContentView 方法中首先调用，由方法名翻译出来是：设置装饰，设置布局好一点（根据代码意思）。首先调用 installDecor 方法，说明先初始化 mDecor 的布局，所以要先理解一下 mDecor 是什么，才能知道 mContentParent 是对应哪个 View，以及它的层次结构。\n\n  ```java\n  private void installDecor() {\n   mForceDecorInstall = false;\n   if (mDecor == null) {\n     mDecor = generateDecor(-1); // mDecor 的初始化,在此会 new 出一个 Decor 对象返回\n     mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);\n     mDecor.setIsRootNamespace(true);\n     if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {\n       mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);\n     }\n   } else {\n     mDecor.setWindow(this);\n   }\n   if (mContentParent == null) {\n     mContentParent = generateLayout(mDecor); // mContentParent 的初始化\n\n     mDecor.makeOptionalFitsSystemWindows();\n\n     final DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(\n       R.id.decor_content_parent);\n     //...省略下面源码\n  }\n  ```\n\n  初始化 mDecor，Decor 根据成员属性的解释知道是 window 的最顶层的 view（top-level）。由 mContentParent = generateLayout(mDecor); 代码自然地知道 mContentParent 的构造依赖于 Decor，并且 Decor 是最顶层的 View，所以自然推出 mContentParent 是 Decor 的子 View。\n\n  ```java\n  // This is the top-level view of the window, containing the window decor.、\n  private DecorView mDecor;\n\n  protected DecorView generateDecor(int featureId) {\n   Context context;\n   if (mUseDecorContext) {\n     Context applicationContext = getContext().getApplicationContext();\n     if (applicationContext == null) {\n       context = getContext();\n     } else {\n       context = new DecorContext(applicationContext, getContext().getResources());\n       if (mTheme != -1) {\n         context.setTheme(mTheme);\n       }\n     }\n   } else {\n     context = getContext();\n   }\n   // new 出一个 DecorView 对象，构造方法中调用 super.(context)。则会对 Decor 进行测量布局绘制等过程。\n   return new DecorView(context, featureId, this, getAttributes());\n  }\n  ```\n\n  初始化 mContentParent 的代码其实就是加载好 Decor 后在 Decor 中利用 findViewById 寻找到 mContentParent 的值并返回。不过要经历一大堆的处理，比如系统版本，App Theme 的配置等（具体不再深入）。\n\n  ```java\n  protected ViewGroup generateLayout(DecorView decor) {\n    // 省略的代码大概就是读取 window 的 theme 属性参数进行配置设置\n    //... 源码有点长 ，省略一点\n    // 并且在 window 中把 decor 加载进来\n\n    // Inflate the window decor.\n    int layoutResource;\n    int features = getLocalFeatures();\n    // 根据 features 的值进行逻辑判断，加载特定的 layoutResource （Decor 的标题 Layout 布局文件 Id）\n    mDecor.startChanging();\n    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);// 加载 Decor 的布局文件\n\n    // 这就是我们 setContentView 的布局文件加载到的父 ViewGroup 中（内容栏）\n    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);\n    if (contentParent == null) {\n      throw new RuntimeException(\"Window couldn't find content container view\");\n    }\n\n    if ((features & (1 << FEATURE_INDETERMINATE_PROGRESS)) != 0) {\n      ProgressBar progress = getCircularProgressBar(false);\n      if (progress != null) {\n        progress.setIndeterminate(true);\n      }\n    }\n    //... 源码有点长 ，省略一点\n  }\n  ```\n\n- 通过上面代码的追溯，可以找到 mContentParent 的父 View 是 Decor，以及 mContentParent 是在哪赋值的。现在再回到第（4）步中就非常清晰了，再 nstallDecor 方法调用后，mContentParent 就已经被赋值，并且 Decor（Window 根 Vew）已经被加载到 Window 中。再通过 LayoutInflater 将我们在 Activity 中设置的布局加载到 mContentParent 中。关于 Decor 的布局根据系统版本的不同而不同。\n\n##### 简单介绍一下 Measure 的重要参数值代表的意思。\n\n- MeasureSpec ：翻译过来就是测量规格，一个 View 的 MeasureSpec 计算数据由父 View 传下来的 MeasureSpec 和自己本身的 LayoutParams（xml 文件配置的 layout 属性的标签，如：layout_width 和 layout_height） 决定。MeasureSpec 是一个 32 位的 int 值，存储方式是以**二进制存储**，高 2 位代表 SpecMode（测量模式），低 30 位代表是 SpecSize（规格大小）。\n\n- SpecMode 对 View 测量规格的影响如下。父 View 的测量过程会先测量子 View，是一个树形的的递归测量实现，所以先测量完子 View，等到没有子 View 的时候在测量父 View 本身。\n\n\n\n  |                     父 View 的 SpecMode                      |               子 View 的 LayoutParams               |                 子 View 的 Size 和 Mode 情况                 |\n  | :----------------------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------------: |\n  | <br />EXACTLY<br />父 View 已经检测到子 View 的大小，最终大小就是 SpecSize | 1. 确切值<br />2. match_parent<br />3. wrap_content | 1. size = 计算出来的值，mode = EXACTLY<br />2. size =  父 View size ，mode = EXACTLY<br />3. size =  父 View size ，mode = AT_MOST |\n  |      <br />AT_MOST<br />父容器指定子 View Size 的最大值      | 1. 确切值<br />2. match_parent<br />3. wrap_content | 1. size = 计算出来的值，mode = EXACTLY<br />2. size =  父 View size ，mode = AT_MOST<br />3. size =  父 View size ，mode = AT_MOST |\n  |     <br />UNSPECIFIED<br />父容器对子 View 的大小没限制      | 1. 确切值<br />2. match_parent<br />3. wrap_content | 1. size = 计算出来的值，mode = EXACTLY<br />2. size =  0 ，mode = UNSPECIFIED<br />3. size =  0，mode = UNSPECIFIED |\n\n  总结一下：\n\n  - 子 View 的 LayoutParams 是确切的，那么无论父 View 是 specMode 是怎样的，子 View 的 size 都是开发设置的确切值，子 View 的 size 被确定，所以子 View 的 specMode = EXACTLY；\n  - 子 View 的 LayoutParams = match_parent（充满父 View）。当父 View 的 specMode 是 EXACTLY ，父 View 的 size 已经是确定的，那么子 View 的 size = 父 View 的 size，子 View 的 size 被确定，所以子 View 的 specMode = EXACTLY。当父 View 的 specMode 是 AT_MOST，也就是说父 View 的 size 是不确切的，但是父 View 有个最大 size 值，具体 size 需要根据子 View 的 size 确定，子 View 要充满父 View，应该子 View 的 size = 父 View 的 size，父 View 的大小不确定，子 View 要充满父 View，所以子 View 的 size 不确定，specMode 也应该是 AT_MOST。当父 View 的 specMode = UNSPECIFIED ，没有限制，不可能把子 View 的 size 设置成无限大，所以暂时设置成 0 ，specMode = UNSPECIFIED，父 View 无限制，父 View 的 size 无确切值和最大值，子 View 充满父 View，子 View 的 specMode 也应该是 UNSPECIFIED。\n  - 子 View 的LayoutParams = wrap_content（包含内容的大小）。当父 View 的 specMode = EXACTLY 或 AT_MOST 时，不管父 View 的大小是否确定，在这 2 种 specMode 中，都有一个确切值或者最大值，子 View 的大小要根据内容决定，子 View 的 size 大小又不能超过父 View，所以子 View 的 size 肯定是一个不确定的值，specMode 应该是 AT_MOST，size 应该是父 View 的确切值或者是最大值。当父 View 的 specMode = UNSPECIFIED，没有限制，不可能把子 View 的 size 设置成无限大，所以暂时设置成 0 ，父 View 无限制，父 View 的 size 无确切值和最大值，子 View 的 size 是由子 View 的内容决定，子 View 的 specMode 也应该是 UNSPECIFIED。\n\n  计算 MeasureSpec 的源代码实现如下：\n\n  ```java\n  public static int getChildMeasureSpec(int spec, int padding, int childDimension) {\n      int specMode = MeasureSpec.getMode(spec);\n      int specSize = MeasureSpec.getSize(spec);\n      int size = Math.max(0, specSize - padding);\n      int resultSize = 0;\n      int resultMode = 0;\n      switch (specMode) {\n          case MeasureSpec.EXACTLY:\n              if (childDimension >= 0) {\n                  resultSize = childDimension;\n                  resultMode = MeasureSpec.EXACTLY;\n              } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                  resultSize = size;\n                  resultMode = MeasureSpec.EXACTLY;\n              } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                  resultSize = size;\n                  resultMode = MeasureSpec.AT_MOST;\n              }\n              break;\n          case MeasureSpec.AT_MOST:\n              if (childDimension >= 0) {\n                  resultSize = childDimension;\n                  resultMode = MeasureSpec.EXACTLY;\n              } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                  resultSize = size;\n                  resultMode = MeasureSpec.AT_MOST;\n              } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                  resultSize = size;\n                  resultMode = MeasureSpec.AT_MOST;\n              }\n              break;\n          case MeasureSpec.UNSPECIFIED:\n              if (childDimension >= 0) {\n                  resultSize = childDimension;\n                  resultMode = MeasureSpec.EXACTLY;\n              } else if (childDimension == LayoutParams.MATCH_PARENT) {\n                  resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                  resultMode = MeasureSpec.UNSPECIFIED;\n              } else if (childDimension == LayoutParams.WRAP_CONTENT) {\n                  resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;\n                  resultMode = MeasureSpec.UNSPECIFIED;\n              }\n              break;\n      }\n      return MeasureSpec.makeMeasureSpec(resultSize, resultMode);\n  }\n  ```\n\n##### 从 DecorView 到其子 View 的 Measure 过程\n\n- 由上面分析知道，一个 Activity 的最顶级的 View 就是 DecorView，那么测量过程就应该从 DecorView 以树形结构往 DecorView 的子 View 开始递归实现。对于 DecorView ，它的 MeasureSpec 不同普通 View 那样决定，它的决定是由窗口的尺寸和自身的 LayoutParams 来决定（普通 View 的 MeasureSpec 的决定由父 View 的 MeasureSpec 和自身的 LayoutParams）。那么 DecorView 什么时候开始测量？上面提到，在 PhoneWindow 中的 setContentView 方法中调用 installDecor 方法，在 installDecor 方法里面会初始化一个 DecorView，初始化一个 View ，自然要对 View 进行测量。\n\n- View 的测量是由 measure 方法工作的，measure 方法是 final ，说明此方法不能重写，而在 measure 方法中最终会调用 onMeasure 方法，所以要看 onMeasure 方法。\n\n  ```java\n  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n      setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),\n                           getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));\n  }\n  ```\n\n  setMeasuredDimension 会设置 View 的宽/高的测量值。在 View 的子类中，要计算出 widthMeasureSpec 和 heightMeasureSpec 的实际值，再调用 super.measure 方法或者直接调用 setMeasuredDimension 方法设定 View 的宽/高测量值。\n\n  getDefaultSize 方法是干嘛的呢？返回 View 测量后的大小。\n\n  ```java\n  public static int getDefaultSize(int size, int measureSpec) {\n      // View 的默认大小。\n      //View 无背景：由 android_minXXX 决定，View 有背景：android_minXXX 和 背景的宽/高取最大值\n      int result = size;\n      int specMode = MeasureSpec.getMode(measureSpec);// 测量得出的 View 的 mode\n      int specSize = MeasureSpec.getSize(measureSpec);// 测量得出的 View 的 size\n      switch (specMode) {\n          case MeasureSpec.UNSPECIFIED:\n              result = size;\n              break;\n          case MeasureSpec.AT_MOST:\n          case MeasureSpec.EXACTLY:\n              result = specSize;\n              break;\n      }\n      return result;\n  }\n  ```\n\n  **在自定义 View 中，要注意重写 onMeasure 方法，并设置 wrap_content 时的自身大小。**\n\n  当 View 的 Layout_Params = wrap_content 时，由上面的表格知道，View 的 specMode 是 AT_MOST，由 getDefaultSize 方法逻辑知道，计算的最终大小是 specSize，而这个 specSize 就是父 View 的可使用的的大小，子 View 的 specSize = 父 View 的 specSize，就如同 match_parent 的效果。\n\n  避免上面问题，重写 onMeasure 方法如下：\n\n  ````java\n  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){\n      super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n      int width; \t// view 的默认宽度\n      int height; // view 的默认高度\n\n      int widthSpecMode = mewsureSpec.getMode(widthMeasureSpec);// 父 View 的宽度 specMode\n      int widthSpecSize = mewsureSpec.getSzie(widthMeasureSpec);// 父 View 的宽度 specSize\n      int heightSpecMode = mewsureSpec.getMode(heightMeasureSpec);// 父 View 的高度 specMode\n      int heightSpecSize = mewsureSpec.getSzie(heightMeasureSpec);// 父 View 的高度 specSize\n      if (widthSpecMode == MeasureSpec.AT_MOST && heightSpecMode == MeasureSpec.AT_MOST){\n          setMeasuredDimension(width, height);\n      } else if (widthSpecMode == MeasureSpec.AT_MOST){\n          setMeasuredDimension(width, heightSpecSize);\n      } else if (heightSpecMode == MeasureSpec.AT_MOST){\n          setMeasuredDimension(widthSpecSize, height);\n      }\n  }\n  ````\n\n- ViewGroup 的测量除了要测量自己，还要遍历它所有子 View 的 measure 过程，最后完成测量过程。具体遍历子 View 的过程是由 measureChildren 方法实现，调用子 View 的测量方法是 measureChild 方法实现。\n\n  ```java\n  protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {\n      final int size = mChildrenCount;\n      final View[] children = mChildren;\n      for (int i = 0; i < size; ++i) {// 遍历子 View\n          final View child = children[i];\n          if ((child.mViewFlags & VISIBILITY_MASK) != GONE) {\n              measureChild(child, widthMeasureSpec, heightMeasureSpec);\n          }\n      }\n  }\n  protected void measureChild(View child, int parentWidthMeasureSpec,\n              int parentHeightMeasureSpec) {\n      final LayoutParams lp = child.getLayoutParams();\n      final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,\n                  mPaddingLeft + mPaddingRight, lp.width);\n      final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,\n                  mPaddingTop + mPaddingBottom, lp.height);\n      child.measure(childWidthMeasureSpec, childHeightMeasureSpec); // 调用子 View 的测量方法\n  }\n  ```\n\n\n\n- 当调用完 setMeasuredDimension ，将测量的值传入，测量的过程就完成了。\n","slug":"Android 绘制过程","published":1,"updated":"2018-12-05T03:44:04.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzcg0007s8o5svtqvsio","content":"<h5 id=\"Android-的-setContentView-流程\"><a href=\"#Android-的-setContentView-流程\" class=\"headerlink\" title=\"Android 的 setContentView 流程\"></a>Android 的 setContentView 流程</h5><ul>\n<li><p>（1）Activity 是 Android 中最直接的，也是最主要的显示界面，在 Activity 中，要通过 setContentView() 来设置当前 Activity 中的布局 Layout。</p>\n</li>\n<li><p>（2）setContentView() 是干嘛的？翻译过来，就是设置内容的 View 。如何设置？通过 Window 类来进行设置。通过源码发现，Activity 的 setContentView 方法实际上是调用 Window 的 setContentView 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">  getWindow().setContentView(layoutResID);</span><br><span class=\"line\">  initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（3）但是呢，Window 是一个抽象类，具体需要去找出它的实现类。Window 是什么？官方一点来讲就是处理顶级窗口外观和行为策略的抽象基类。通俗来理解就是 Activity 通过 Window 来对 View 进行一系列的处理。并且通过源码的解释可以知道该抽象类的唯一实现类是 PhoneWindow.java 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Abstract base class for a top-level window look and behavior policy.  An</span></span><br><span class=\"line\"><span class=\"comment\"> * instance of this class should be used as the top-level view added to the</span></span><br><span class=\"line\"><span class=\"comment\"> * window manager. It provides standard UI policies such as a background, title</span></span><br><span class=\"line\"><span class=\"comment\"> * area, default key processing, etc.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;The only existing implementation of this abstract class is</span></span><br><span class=\"line\"><span class=\"comment\"> * android.view.PhoneWindow, which you should instantiate when needing a</span></span><br><span class=\"line\"><span class=\"comment\"> * Window.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（4）通过 Window 的注释，我们知道该类的唯一实现类就是 PhoneWindow ，并且 Activity 的 setContentView 方法实际是调用 Window 的 setContentView 方法，所以要去找 Window 的实现类 PhoneWindow 的 setContentView 方法。发现 PhoneWindow 中的 setContentView 中有 3 个重载方法，不过根据入参，需要找的是具有一个 int 参数的 setContentView 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    installDecor(); <span class=\"comment\">//注意此方法，下面会提到。</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">    mContentParent.removeAllViews(); <span class=\"comment\">// 删除所有子 View</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class=\"line\">                                                   getContext());</span><br><span class=\"line\">    transitionTo(newScene);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    mLayoutInflater.inflate(layoutResID, mContentParent);<span class=\"comment\">//布局 layout 在方法中的使用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mContentParent.requestApplyInsets();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Callback cb = getCallback();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class=\"line\">    cb.onContentChanged();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mContentParentExplicitlySet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由 View inflate(@LayoutRes int resource, @Nullable ViewGroup root) 方法可以大概知道，是将对应 layoutResID 的布局加载到 mContentParent 中去。</p>\n</li>\n<li><p>（5）installDecor 方法其实在 PhoneWindow 的 setContentView 方法中首先调用，由方法名翻译出来是：设置装饰，设置布局好一点（根据代码意思）。首先调用 installDecor 方法，说明先初始化 mDecor 的布局，所以要先理解一下 mDecor 是什么，才能知道 mContentParent 是对应哪个 View，以及它的层次结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> mForceDecorInstall = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   mDecor = generateDecor(-<span class=\"number\">1</span>); <span class=\"comment\">// mDecor 的初始化,在此会 new 出一个 Decor 对象返回</span></span><br><span class=\"line\">   mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class=\"line\">   mDecor.setIsRootNamespace(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">     mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">   mDecor.setWindow(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   mContentParent = generateLayout(mDecor); <span class=\"comment\">// mContentParent 的初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\">   mDecor.makeOptionalFitsSystemWindows();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class=\"line\">     R.id.decor_content_parent);</span><br><span class=\"line\">   <span class=\"comment\">//...省略下面源码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化 mDecor，Decor 根据成员属性的解释知道是 window 的最顶层的 view（top-level）。由 mContentParent = generateLayout(mDecor); 代码自然地知道 mContentParent 的构造依赖于 Decor，并且 Decor 是最顶层的 View，所以自然推出 mContentParent 是 Decor 的子 View。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This is the top-level view of the window, containing the window decor.、</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> DecorView mDecor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> DecorView <span class=\"title\">generateDecor</span><span class=\"params\">(<span class=\"keyword\">int</span> featureId)</span> </span>&#123;</span><br><span class=\"line\"> Context context;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (mUseDecorContext) &#123;</span><br><span class=\"line\">   Context applicationContext = getContext().getApplicationContext();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (applicationContext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">     context = getContext();</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     context = <span class=\"keyword\">new</span> DecorContext(applicationContext, getContext().getResources());</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mTheme != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">       context.setTheme(mTheme);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">   context = getContext();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">// new 出一个 DecorView 对象，构造方法中调用 super.(context)。则会对 Decor 进行测量布局绘制等过程。</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DecorView(context, featureId, <span class=\"keyword\">this</span>, getAttributes());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化 mContentParent 的代码其实就是加载好 Decor 后在 Decor 中利用 findViewById 寻找到 mContentParent 的值并返回。不过要经历一大堆的处理，比如系统版本，App Theme 的配置等（具体不再深入）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ViewGroup <span class=\"title\">generateLayout</span><span class=\"params\">(DecorView decor)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 省略的代码大概就是读取 window 的 theme 属性参数进行配置设置</span></span><br><span class=\"line\">  <span class=\"comment\">//... 源码有点长 ，省略一点</span></span><br><span class=\"line\">  <span class=\"comment\">// 并且在 window 中把 decor 加载进来</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Inflate the window decor.</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> layoutResource;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> features = getLocalFeatures();</span><br><span class=\"line\">  <span class=\"comment\">// 根据 features 的值进行逻辑判断，加载特定的 layoutResource （Decor 的标题 Layout 布局文件 Id）</span></span><br><span class=\"line\">  mDecor.startChanging();</span><br><span class=\"line\">  mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);<span class=\"comment\">// 加载 Decor 的布局文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这就是我们 setContentView 的布局文件加载到的父 ViewGroup 中（内容栏）</span></span><br><span class=\"line\">  ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (contentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Window couldn't find content container view\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    ProgressBar progress = getCircularProgressBar(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (progress != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      progress.setIndeterminate(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//... 源码有点长 ，省略一点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过上面代码的追溯，可以找到 mContentParent 的父 View 是 Decor，以及 mContentParent 是在哪赋值的。现在再回到第（4）步中就非常清晰了，再 nstallDecor 方法调用后，mContentParent 就已经被赋值，并且 Decor（Window 根 Vew）已经被加载到 Window 中。再通过 LayoutInflater 将我们在 Activity 中设置的布局加载到 mContentParent 中。关于 Decor 的布局根据系统版本的不同而不同。</p>\n</li>\n</ul>\n<h5 id=\"简单介绍一下-Measure-的重要参数值代表的意思。\"><a href=\"#简单介绍一下-Measure-的重要参数值代表的意思。\" class=\"headerlink\" title=\"简单介绍一下 Measure 的重要参数值代表的意思。\"></a>简单介绍一下 Measure 的重要参数值代表的意思。</h5><ul>\n<li><p>MeasureSpec ：翻译过来就是测量规格，一个 View 的 MeasureSpec 计算数据由父 View 传下来的 MeasureSpec 和自己本身的 LayoutParams（xml 文件配置的 layout 属性的标签，如：layout_width 和 layout_height） 决定。MeasureSpec 是一个 32 位的 int 值，存储方式是以<strong>二进制存储</strong>，高 2 位代表 SpecMode（测量模式），低 30 位代表是 SpecSize（规格大小）。</p>\n</li>\n<li><p>SpecMode 对 View 测量规格的影响如下。父 View 的测量过程会先测量子 View，是一个树形的的递归测量实现，所以先测量完子 View，等到没有子 View 的时候在测量父 View 本身。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">父 View 的 SpecMode</th>\n<th style=\"text-align:center\">子 View 的 LayoutParams</th>\n<th style=\"text-align:center\">子 View 的 Size 和 Mode 情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><br>EXACTLY<br>父 View 已经检测到子 View 的大小，最终大小就是 SpecSize</td>\n<td style=\"text-align:center\">1. 确切值<br>2. match_parent<br>3. wrap_content</td>\n<td style=\"text-align:center\">1. size = 计算出来的值，mode = EXACTLY<br>2. size =  父 View size ，mode = EXACTLY<br>3. size =  父 View size ，mode = AT_MOST</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><br>AT_MOST<br>父容器指定子 View Size 的最大值</td>\n<td style=\"text-align:center\">1. 确切值<br>2. match_parent<br>3. wrap_content</td>\n<td style=\"text-align:center\">1. size = 计算出来的值，mode = EXACTLY<br>2. size =  父 View size ，mode = AT_MOST<br>3. size =  父 View size ，mode = AT_MOST</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><br>UNSPECIFIED<br>父容器对子 View 的大小没限制</td>\n<td style=\"text-align:center\">1. 确切值<br>2. match_parent<br>3. wrap_content</td>\n<td style=\"text-align:center\">1. size = 计算出来的值，mode = EXACTLY<br>2. size =  0 ，mode = UNSPECIFIED<br>3. size =  0，mode = UNSPECIFIED</td>\n</tr>\n</tbody>\n</table>\n<p>  总结一下：</p>\n<ul>\n<li>子 View 的 LayoutParams 是确切的，那么无论父 View 是 specMode 是怎样的，子 View 的 size 都是开发设置的确切值，子 View 的 size 被确定，所以子 View 的 specMode = EXACTLY；</li>\n<li>子 View 的 LayoutParams = match_parent（充满父 View）。当父 View 的 specMode 是 EXACTLY ，父 View 的 size 已经是确定的，那么子 View 的 size = 父 View 的 size，子 View 的 size 被确定，所以子 View 的 specMode = EXACTLY。当父 View 的 specMode 是 AT_MOST，也就是说父 View 的 size 是不确切的，但是父 View 有个最大 size 值，具体 size 需要根据子 View 的 size 确定，子 View 要充满父 View，应该子 View 的 size = 父 View 的 size，父 View 的大小不确定，子 View 要充满父 View，所以子 View 的 size 不确定，specMode 也应该是 AT_MOST。当父 View 的 specMode = UNSPECIFIED ，没有限制，不可能把子 View 的 size 设置成无限大，所以暂时设置成 0 ，specMode = UNSPECIFIED，父 View 无限制，父 View 的 size 无确切值和最大值，子 View 充满父 View，子 View 的 specMode 也应该是 UNSPECIFIED。</li>\n<li><p>子 View 的LayoutParams = wrap_content（包含内容的大小）。当父 View 的 specMode = EXACTLY 或 AT_MOST 时，不管父 View 的大小是否确定，在这 2 种 specMode 中，都有一个确切值或者最大值，子 View 的大小要根据内容决定，子 View 的 size 大小又不能超过父 View，所以子 View 的 size 肯定是一个不确定的值，specMode 应该是 AT_MOST，size 应该是父 View 的确切值或者是最大值。当父 View 的 specMode = UNSPECIFIED，没有限制，不可能把子 View 的 size 设置成无限大，所以暂时设置成 0 ，父 View 无限制，父 View 的 size 无确切值和最大值，子 View 的 size 是由子 View 的内容决定，子 View 的 specMode 也应该是 UNSPECIFIED。</p>\n<p>计算 MeasureSpec 的源代码实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getChildMeasureSpec</span><span class=\"params\">(<span class=\"keyword\">int</span> spec, <span class=\"keyword\">int</span> padding, <span class=\"keyword\">int</span> childDimension)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = Math.max(<span class=\"number\">0</span>, specSize - padding);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> resultSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> resultMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (specMode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.EXACTLY:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childDimension &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.AT_MOST:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childDimension &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childDimension &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class=\"number\">0</span> : size;</span><br><span class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class=\"number\">0</span> : size;</span><br><span class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"从-DecorView-到其子-View-的-Measure-过程\"><a href=\"#从-DecorView-到其子-View-的-Measure-过程\" class=\"headerlink\" title=\"从 DecorView 到其子 View 的 Measure 过程\"></a>从 DecorView 到其子 View 的 Measure 过程</h5><ul>\n<li><p>由上面分析知道，一个 Activity 的最顶级的 View 就是 DecorView，那么测量过程就应该从 DecorView 以树形结构往 DecorView 的子 View 开始递归实现。对于 DecorView ，它的 MeasureSpec 不同普通 View 那样决定，它的决定是由窗口的尺寸和自身的 LayoutParams 来决定（普通 View 的 MeasureSpec 的决定由父 View 的 MeasureSpec 和自身的 LayoutParams）。那么 DecorView 什么时候开始测量？上面提到，在 PhoneWindow 中的 setContentView 方法中调用 installDecor 方法，在 installDecor 方法里面会初始化一个 DecorView，初始化一个 View ，自然要对 View 进行测量。</p>\n</li>\n<li><p>View 的测量是由 measure 方法工作的，measure 方法是 final ，说明此方法不能重写，而在 measure 方法中最终会调用 onMeasure 方法，所以要看 onMeasure 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class=\"line\">                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>setMeasuredDimension 会设置 View 的宽/高的测量值。在 View 的子类中，要计算出 widthMeasureSpec 和 heightMeasureSpec 的实际值，再调用 super.measure 方法或者直接调用 setMeasuredDimension 方法设定 View 的宽/高测量值。</p>\n<p>getDefaultSize 方法是干嘛的呢？返回 View 测量后的大小。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultSize</span><span class=\"params\">(<span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> measureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// View 的默认大小。</span></span><br><span class=\"line\">    <span class=\"comment\">//View 无背景：由 android_minXXX 决定，View 有背景：android_minXXX 和 背景的宽/高取最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> specMode = MeasureSpec.getMode(measureSpec);<span class=\"comment\">// 测量得出的 View 的 mode</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> specSize = MeasureSpec.getSize(measureSpec);<span class=\"comment\">// 测量得出的 View 的 size</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (specMode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class=\"line\">            result = size;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.AT_MOST:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.EXACTLY:</span><br><span class=\"line\">            result = specSize;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在自定义 View 中，要注意重写 onMeasure 方法，并设置 wrap_content 时的自身大小。</strong></p>\n<p>当 View 的 Layout_Params = wrap_content 时，由上面的表格知道，View 的 specMode 是 AT_MOST，由 getDefaultSize 方法逻辑知道，计算的最终大小是 specSize，而这个 specSize 就是父 View 的可使用的的大小，子 View 的 specSize = 父 View 的 specSize，就如同 match_parent 的效果。</p>\n<p>避免上面问题，重写 onMeasure 方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width; \t<span class=\"comment\">// view 的默认宽度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> height; <span class=\"comment\">// view 的默认高度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthSpecMode = mewsureSpec.getMode(widthMeasureSpec);<span class=\"comment\">// 父 View 的宽度 specMode</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthSpecSize = mewsureSpec.getSzie(widthMeasureSpec);<span class=\"comment\">// 父 View 的宽度 specSize</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSpecMode = mewsureSpec.getMode(heightMeasureSpec);<span class=\"comment\">// 父 View 的高度 specMode</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSpecSize = mewsureSpec.getSzie(heightMeasureSpec);<span class=\"comment\">// 父 View 的高度 specSize</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">        setMeasuredDimension(width, height);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (widthSpecMode == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">        setMeasuredDimension(width, heightSpecSize);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (heightSpecMode == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">        setMeasuredDimension(widthSpecSize, height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ViewGroup 的测量除了要测量自己，还要遍历它所有子 View 的 measure 过程，最后完成测量过程。具体遍历子 View 的过程是由 measureChildren 方法实现，调用子 View 的测量方法是 measureChild 方法实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChildren</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = mChildrenCount;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> View[] children = mChildren;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;<span class=\"comment\">// 遍历子 View</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = children[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class=\"line\">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChild</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> parentWidthMeasureSpec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class=\"line\">                mPaddingLeft + mPaddingRight, lp.width);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class=\"line\">                mPaddingTop + mPaddingBottom, lp.height);</span><br><span class=\"line\">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec); <span class=\"comment\">// 调用子 View 的测量方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当调用完 setMeasuredDimension ，将测量的值传入，测量的过程就完成了。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"Android-的-setContentView-流程\"><a href=\"#Android-的-setContentView-流程\" class=\"headerlink\" title=\"Android 的 setContentView 流程\"></a>Android 的 setContentView 流程</h5><ul>\n<li><p>（1）Activity 是 Android 中最直接的，也是最主要的显示界面，在 Activity 中，要通过 setContentView() 来设置当前 Activity 中的布局 Layout。</p>\n</li>\n<li><p>（2）setContentView() 是干嘛的？翻译过来，就是设置内容的 View 。如何设置？通过 Window 类来进行设置。通过源码发现，Activity 的 setContentView 方法实际上是调用 Window 的 setContentView 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(@LayoutRes <span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">  getWindow().setContentView(layoutResID);</span><br><span class=\"line\">  initWindowDecorActionBar();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（3）但是呢，Window 是一个抽象类，具体需要去找出它的实现类。Window 是什么？官方一点来讲就是处理顶级窗口外观和行为策略的抽象基类。通俗来理解就是 Activity 通过 Window 来对 View 进行一系列的处理。并且通过源码的解释可以知道该抽象类的唯一实现类是 PhoneWindow.java 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Abstract base class for a top-level window look and behavior policy.  An</span></span><br><span class=\"line\"><span class=\"comment\"> * instance of this class should be used as the top-level view added to the</span></span><br><span class=\"line\"><span class=\"comment\"> * window manager. It provides standard UI policies such as a background, title</span></span><br><span class=\"line\"><span class=\"comment\"> * area, default key processing, etc.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;The only existing implementation of this abstract class is</span></span><br><span class=\"line\"><span class=\"comment\"> * android.view.PhoneWindow, which you should instantiate when needing a</span></span><br><span class=\"line\"><span class=\"comment\"> * Window.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>（4）通过 Window 的注释，我们知道该类的唯一实现类就是 PhoneWindow ，并且 Activity 的 setContentView 方法实际是调用 Window 的 setContentView 方法，所以要去找 Window 的实现类 PhoneWindow 的 setContentView 方法。发现 PhoneWindow 中的 setContentView 中有 3 个重载方法，不过根据入参，需要找的是具有一个 int 参数的 setContentView 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setContentView</span><span class=\"params\">(<span class=\"keyword\">int</span> layoutResID)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    installDecor(); <span class=\"comment\">//注意此方法，下面会提到。</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">    mContentParent.removeAllViews(); <span class=\"comment\">// 删除所有子 View</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class=\"line\">                                                   getContext());</span><br><span class=\"line\">    transitionTo(newScene);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    mLayoutInflater.inflate(layoutResID, mContentParent);<span class=\"comment\">//布局 layout 在方法中的使用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mContentParent.requestApplyInsets();</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Callback cb = getCallback();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cb != <span class=\"keyword\">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class=\"line\">    cb.onContentChanged();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  mContentParentExplicitlySet = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由 View inflate(@LayoutRes int resource, @Nullable ViewGroup root) 方法可以大概知道，是将对应 layoutResID 的布局加载到 mContentParent 中去。</p>\n</li>\n<li><p>（5）installDecor 方法其实在 PhoneWindow 的 setContentView 方法中首先调用，由方法名翻译出来是：设置装饰，设置布局好一点（根据代码意思）。首先调用 installDecor 方法，说明先初始化 mDecor 的布局，所以要先理解一下 mDecor 是什么，才能知道 mContentParent 是对应哪个 View，以及它的层次结构。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">installDecor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> mForceDecorInstall = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (mDecor == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   mDecor = generateDecor(-<span class=\"number\">1</span>); <span class=\"comment\">// mDecor 的初始化,在此会 new 出一个 Decor 对象返回</span></span><br><span class=\"line\">   mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class=\"line\">   mDecor.setIsRootNamespace(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">     mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">   mDecor.setWindow(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (mContentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">   mContentParent = generateLayout(mDecor); <span class=\"comment\">// mContentParent 的初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\">   mDecor.makeOptionalFitsSystemWindows();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class=\"line\">     R.id.decor_content_parent);</span><br><span class=\"line\">   <span class=\"comment\">//...省略下面源码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化 mDecor，Decor 根据成员属性的解释知道是 window 的最顶层的 view（top-level）。由 mContentParent = generateLayout(mDecor); 代码自然地知道 mContentParent 的构造依赖于 Decor，并且 Decor 是最顶层的 View，所以自然推出 mContentParent 是 Decor 的子 View。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// This is the top-level view of the window, containing the window decor.、</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> DecorView mDecor;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> DecorView <span class=\"title\">generateDecor</span><span class=\"params\">(<span class=\"keyword\">int</span> featureId)</span> </span>&#123;</span><br><span class=\"line\"> Context context;</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (mUseDecorContext) &#123;</span><br><span class=\"line\">   Context applicationContext = getContext().getApplicationContext();</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (applicationContext == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">     context = getContext();</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     context = <span class=\"keyword\">new</span> DecorContext(applicationContext, getContext().getResources());</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (mTheme != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">       context.setTheme(mTheme);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">   context = getContext();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">// new 出一个 DecorView 对象，构造方法中调用 super.(context)。则会对 Decor 进行测量布局绘制等过程。</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DecorView(context, featureId, <span class=\"keyword\">this</span>, getAttributes());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化 mContentParent 的代码其实就是加载好 Decor 后在 Decor 中利用 findViewById 寻找到 mContentParent 的值并返回。不过要经历一大堆的处理，比如系统版本，App Theme 的配置等（具体不再深入）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ViewGroup <span class=\"title\">generateLayout</span><span class=\"params\">(DecorView decor)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 省略的代码大概就是读取 window 的 theme 属性参数进行配置设置</span></span><br><span class=\"line\">  <span class=\"comment\">//... 源码有点长 ，省略一点</span></span><br><span class=\"line\">  <span class=\"comment\">// 并且在 window 中把 decor 加载进来</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Inflate the window decor.</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> layoutResource;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> features = getLocalFeatures();</span><br><span class=\"line\">  <span class=\"comment\">// 根据 features 的值进行逻辑判断，加载特定的 layoutResource （Decor 的标题 Layout 布局文件 Id）</span></span><br><span class=\"line\">  mDecor.startChanging();</span><br><span class=\"line\">  mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);<span class=\"comment\">// 加载 Decor 的布局文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 这就是我们 setContentView 的布局文件加载到的父 ViewGroup 中（内容栏）</span></span><br><span class=\"line\">  ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (contentParent == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"Window couldn't find content container view\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((features &amp; (<span class=\"number\">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    ProgressBar progress = getCircularProgressBar(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (progress != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      progress.setIndeterminate(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//... 源码有点长 ，省略一点</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过上面代码的追溯，可以找到 mContentParent 的父 View 是 Decor，以及 mContentParent 是在哪赋值的。现在再回到第（4）步中就非常清晰了，再 nstallDecor 方法调用后，mContentParent 就已经被赋值，并且 Decor（Window 根 Vew）已经被加载到 Window 中。再通过 LayoutInflater 将我们在 Activity 中设置的布局加载到 mContentParent 中。关于 Decor 的布局根据系统版本的不同而不同。</p>\n</li>\n</ul>\n<h5 id=\"简单介绍一下-Measure-的重要参数值代表的意思。\"><a href=\"#简单介绍一下-Measure-的重要参数值代表的意思。\" class=\"headerlink\" title=\"简单介绍一下 Measure 的重要参数值代表的意思。\"></a>简单介绍一下 Measure 的重要参数值代表的意思。</h5><ul>\n<li><p>MeasureSpec ：翻译过来就是测量规格，一个 View 的 MeasureSpec 计算数据由父 View 传下来的 MeasureSpec 和自己本身的 LayoutParams（xml 文件配置的 layout 属性的标签，如：layout_width 和 layout_height） 决定。MeasureSpec 是一个 32 位的 int 值，存储方式是以<strong>二进制存储</strong>，高 2 位代表 SpecMode（测量模式），低 30 位代表是 SpecSize（规格大小）。</p>\n</li>\n<li><p>SpecMode 对 View 测量规格的影响如下。父 View 的测量过程会先测量子 View，是一个树形的的递归测量实现，所以先测量完子 View，等到没有子 View 的时候在测量父 View 本身。</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">父 View 的 SpecMode</th>\n<th style=\"text-align:center\">子 View 的 LayoutParams</th>\n<th style=\"text-align:center\">子 View 的 Size 和 Mode 情况</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><br>EXACTLY<br>父 View 已经检测到子 View 的大小，最终大小就是 SpecSize</td>\n<td style=\"text-align:center\">1. 确切值<br>2. match_parent<br>3. wrap_content</td>\n<td style=\"text-align:center\">1. size = 计算出来的值，mode = EXACTLY<br>2. size =  父 View size ，mode = EXACTLY<br>3. size =  父 View size ，mode = AT_MOST</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><br>AT_MOST<br>父容器指定子 View Size 的最大值</td>\n<td style=\"text-align:center\">1. 确切值<br>2. match_parent<br>3. wrap_content</td>\n<td style=\"text-align:center\">1. size = 计算出来的值，mode = EXACTLY<br>2. size =  父 View size ，mode = AT_MOST<br>3. size =  父 View size ，mode = AT_MOST</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><br>UNSPECIFIED<br>父容器对子 View 的大小没限制</td>\n<td style=\"text-align:center\">1. 确切值<br>2. match_parent<br>3. wrap_content</td>\n<td style=\"text-align:center\">1. size = 计算出来的值，mode = EXACTLY<br>2. size =  0 ，mode = UNSPECIFIED<br>3. size =  0，mode = UNSPECIFIED</td>\n</tr>\n</tbody>\n</table>\n<p>  总结一下：</p>\n<ul>\n<li>子 View 的 LayoutParams 是确切的，那么无论父 View 是 specMode 是怎样的，子 View 的 size 都是开发设置的确切值，子 View 的 size 被确定，所以子 View 的 specMode = EXACTLY；</li>\n<li>子 View 的 LayoutParams = match_parent（充满父 View）。当父 View 的 specMode 是 EXACTLY ，父 View 的 size 已经是确定的，那么子 View 的 size = 父 View 的 size，子 View 的 size 被确定，所以子 View 的 specMode = EXACTLY。当父 View 的 specMode 是 AT_MOST，也就是说父 View 的 size 是不确切的，但是父 View 有个最大 size 值，具体 size 需要根据子 View 的 size 确定，子 View 要充满父 View，应该子 View 的 size = 父 View 的 size，父 View 的大小不确定，子 View 要充满父 View，所以子 View 的 size 不确定，specMode 也应该是 AT_MOST。当父 View 的 specMode = UNSPECIFIED ，没有限制，不可能把子 View 的 size 设置成无限大，所以暂时设置成 0 ，specMode = UNSPECIFIED，父 View 无限制，父 View 的 size 无确切值和最大值，子 View 充满父 View，子 View 的 specMode 也应该是 UNSPECIFIED。</li>\n<li><p>子 View 的LayoutParams = wrap_content（包含内容的大小）。当父 View 的 specMode = EXACTLY 或 AT_MOST 时，不管父 View 的大小是否确定，在这 2 种 specMode 中，都有一个确切值或者最大值，子 View 的大小要根据内容决定，子 View 的 size 大小又不能超过父 View，所以子 View 的 size 肯定是一个不确定的值，specMode 应该是 AT_MOST，size 应该是父 View 的确切值或者是最大值。当父 View 的 specMode = UNSPECIFIED，没有限制，不可能把子 View 的 size 设置成无限大，所以暂时设置成 0 ，父 View 无限制，父 View 的 size 无确切值和最大值，子 View 的 size 是由子 View 的内容决定，子 View 的 specMode 也应该是 UNSPECIFIED。</p>\n<p>计算 MeasureSpec 的源代码实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getChildMeasureSpec</span><span class=\"params\">(<span class=\"keyword\">int</span> spec, <span class=\"keyword\">int</span> padding, <span class=\"keyword\">int</span> childDimension)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = Math.max(<span class=\"number\">0</span>, specSize - padding);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> resultSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> resultMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (specMode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.EXACTLY:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childDimension &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.AT_MOST:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childDimension &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                resultSize = size;</span><br><span class=\"line\">                resultMode = MeasureSpec.AT_MOST;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (childDimension &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                resultSize = childDimension;</span><br><span class=\"line\">                resultMode = MeasureSpec.EXACTLY;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class=\"line\">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class=\"number\">0</span> : size;</span><br><span class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class=\"line\">                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class=\"number\">0</span> : size;</span><br><span class=\"line\">                resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"从-DecorView-到其子-View-的-Measure-过程\"><a href=\"#从-DecorView-到其子-View-的-Measure-过程\" class=\"headerlink\" title=\"从 DecorView 到其子 View 的 Measure 过程\"></a>从 DecorView 到其子 View 的 Measure 过程</h5><ul>\n<li><p>由上面分析知道，一个 Activity 的最顶级的 View 就是 DecorView，那么测量过程就应该从 DecorView 以树形结构往 DecorView 的子 View 开始递归实现。对于 DecorView ，它的 MeasureSpec 不同普通 View 那样决定，它的决定是由窗口的尺寸和自身的 LayoutParams 来决定（普通 View 的 MeasureSpec 的决定由父 View 的 MeasureSpec 和自身的 LayoutParams）。那么 DecorView 什么时候开始测量？上面提到，在 PhoneWindow 中的 setContentView 方法中调用 installDecor 方法，在 installDecor 方法里面会初始化一个 DecorView，初始化一个 View ，自然要对 View 进行测量。</p>\n</li>\n<li><p>View 的测量是由 measure 方法工作的，measure 方法是 final ，说明此方法不能重写，而在 measure 方法中最终会调用 onMeasure 方法，所以要看 onMeasure 方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class=\"line\">                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>setMeasuredDimension 会设置 View 的宽/高的测量值。在 View 的子类中，要计算出 widthMeasureSpec 和 heightMeasureSpec 的实际值，再调用 super.measure 方法或者直接调用 setMeasuredDimension 方法设定 View 的宽/高测量值。</p>\n<p>getDefaultSize 方法是干嘛的呢？返回 View 测量后的大小。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getDefaultSize</span><span class=\"params\">(<span class=\"keyword\">int</span> size, <span class=\"keyword\">int</span> measureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// View 的默认大小。</span></span><br><span class=\"line\">    <span class=\"comment\">//View 无背景：由 android_minXXX 决定，View 有背景：android_minXXX 和 背景的宽/高取最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = size;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> specMode = MeasureSpec.getMode(measureSpec);<span class=\"comment\">// 测量得出的 View 的 mode</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> specSize = MeasureSpec.getSize(measureSpec);<span class=\"comment\">// 测量得出的 View 的 size</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (specMode) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class=\"line\">            result = size;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.AT_MOST:</span><br><span class=\"line\">        <span class=\"keyword\">case</span> MeasureSpec.EXACTLY:</span><br><span class=\"line\">            result = specSize;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>在自定义 View 中，要注意重写 onMeasure 方法，并设置 wrap_content 时的自身大小。</strong></p>\n<p>当 View 的 Layout_Params = wrap_content 时，由上面的表格知道，View 的 specMode 是 AT_MOST，由 getDefaultSize 方法逻辑知道，计算的最终大小是 specSize，而这个 specSize 就是父 View 的可使用的的大小，子 View 的 specSize = 父 View 的 specSize，就如同 match_parent 的效果。</p>\n<p>避免上面问题，重写 onMeasure 方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onMeasure</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width; \t<span class=\"comment\">// view 的默认宽度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> height; <span class=\"comment\">// view 的默认高度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthSpecMode = mewsureSpec.getMode(widthMeasureSpec);<span class=\"comment\">// 父 View 的宽度 specMode</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> widthSpecSize = mewsureSpec.getSzie(widthMeasureSpec);<span class=\"comment\">// 父 View 的宽度 specSize</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSpecMode = mewsureSpec.getMode(heightMeasureSpec);<span class=\"comment\">// 父 View 的高度 specMode</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> heightSpecSize = mewsureSpec.getSzie(heightMeasureSpec);<span class=\"comment\">// 父 View 的高度 specSize</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">        setMeasuredDimension(width, height);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (widthSpecMode == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">        setMeasuredDimension(width, heightSpecSize);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (heightSpecMode == MeasureSpec.AT_MOST)&#123;</span><br><span class=\"line\">        setMeasuredDimension(widthSpecSize, height);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ViewGroup 的测量除了要测量自己，还要遍历它所有子 View 的 measure 过程，最后完成测量过程。具体遍历子 View 的过程是由 measureChildren 方法实现，调用子 View 的测量方法是 measureChild 方法实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChildren</span><span class=\"params\">(<span class=\"keyword\">int</span> widthMeasureSpec, <span class=\"keyword\">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> size = mChildrenCount;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> View[] children = mChildren;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;<span class=\"comment\">// 遍历子 View</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> View child = children[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class=\"line\">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">measureChild</span><span class=\"params\">(View child, <span class=\"keyword\">int</span> parentWidthMeasureSpec,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class=\"line\">                mPaddingLeft + mPaddingRight, lp.width);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class=\"line\">                mPaddingTop + mPaddingBottom, lp.height);</span><br><span class=\"line\">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec); <span class=\"comment\">// 调用子 View 的测量方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>当调用完 setMeasuredDimension ，将测量的值传入，测量的过程就完成了。</p>\n</li>\n</ul>\n"},{"title":"Android 进程","date":"2018-07-06T04:44:05.000Z","_content":"\n- 进程的理解\n\n  - 通常情况下，Android 的四大组件都在同一进程中运行，但是也可以指定组件在特定的进程中进行，通过配置 Mainfest.xml 文件下，四大组件标签内配置 android：process 属性，则可以指定该组件在哪个进程中运行。\n\n- 如何达到进程保活？\n\n  - 避免被杀死，先提高进程的优先级（priority），进程优先级越低越易被杀死。查看进程优先级：\n\t\t```\n\t\tadb shell ps | grep  packageName\n\t\t```\n  - 在进程被杀死情况下，通过某些方法重新启动进程\n\n<!--more-->\n\n- 为什么 Android 系统会杀死进程？\n\n  ![杀死进程原因](https://segmentfault.com/img/remote/1460000006252378)\n\n- 进程等级（优先级由低到高）\n\n  - 前台进程\n\n    - 正在交互的 Activity \n\n    - 绑定正在交互 Activity 的 Service \n\n    - 前台 Service （Service.startForeground( )）\n\n    - 正执行 onCreat(),  onStart(), onDestroy() 的 Service \n\n    - 正执行 onReceive() 的 BoradcastReceiver \n\n  - 可见进程\n\n    - 不在前台，但可见的 Activity（onPause()） ，如开启一个 D\n\n    - 绑定到可见（或前台）Activity 的 Service \n\n  - 后台进程\n\n    - 主要是不可见的 Activity 的进程。这些进程的关闭对用户没有多大影响，Android 系统内存不足可以直接关闭。\n\n  - 空进程\n\n    - 不包含任何应用组件的进程，唯一作用：缓存，缩短下次运行组件所需的启动时间。\n\n- 杀进程回收内存的机制（Low Memory Killer）\n\n|adj级别|值|解释|\n| :----: | :----: | :----: |\n|UNKNOWN_ADJ|16|预留的最低级别，一般对于缓存的进程才有可能设置成这个级别|\n|CACHED_APP_MAX_ADJ|15|缓存进程，空进程，在内存不足的情况下就会优先被kill|\n|CACHED_APP_MIN_ADJ|9|缓存进程，也就是空进程|\n|SERVICE_B_ADJ|8|不活跃的进程|\n|PREVIOUS_APP_ADJ|7|切换进程|\n|HOME_APP_ADJ|6|与Home交互的进程|\n|SERVICE_ADJ|5|有Service的进程|\n|HEAVY_WEIGHT_APP_ADJ|4|高权重进程|\n|BACKUP_APP_ADJ|3|正在备份的进程|\n|PERCEPTIBLE_APP_ADJ|2|可感知的进程，比如那种播放音乐|\n|VISIBLE_APP_ADJ|1|可见进程，如当前的Activity|\n|FOREGROUND_APP_ADJ|0|前台进程|\n|PERSISTENT_SERVICE_ADJ|-11|重要进程|\n|PERSISTENT_PROC_ADJ|-12|核心进程|\n|SYSTEM_ADJ|-16|系统进程|\n|NATIVE_ADJ|-17|系统起的Native进程|\n\t\noom_adj 取值越高越易被杀死，oom_adj 与进程优先级成反比，oom_adj 越高进程优先级越低。\n- 如何达到进程保活？（让 APP 不被 Android 系统杀死）\n\n\t##### 提高进程优先级（在进程被杀死之前）\n\n\t- 方法一：若用户使用电源键息屏，监听息屏和解锁的广播，息屏时候启动一个只有一个像素的 Activity（息屏时候应用优先级很高），不易被杀死也不易被用户发现。（提高进程优先级）\n\n\t```java\n\tpublic class KeepLiveActivity extends Activity {\n\t  \n\t\t//在监听息屏的广播中启动这个 Activity\n\t\tpublic static void startAvtivity(Context context){\n\t\t\tIntent intent = new Intent(context, KeepLiveActivity.class);\n\t\t\tcontext.startActivity(intent);\n\t  }\n\t  \n\t  private static final String TAG = \"KeepLiveActivity\";\n\t  @Override\n\t  protected void onCreate(Bundle savedInstanceState) {\n\t\t   super.onCreate(savedInstanceState);\n\t\t   Log.e(TAG,\"start Keep app activity\");\n\t\t   Window window = getWindow();\n\t\t   //设置 Activity 窗口位置在 START TOP 位置（也就是左上角）\n\t\t   window.setGravity(Gravity.START | Gravity.TOP);\n\t\t   //设置宽高都为 1\n\t\t   WindowManager.LayoutParams attributes = window.getAttributes();\n\t\t   attributes.width = 1;\n\t\t   attributes.height = 1;\n\t\t   attributes.x = 0;\n\t\t   attributes.y = 0;\n\t\t   window.setAttributes(attributes);\n\t   }\n\n\t   @Override\n\t   protected void onDestroy() {\n\t\t   super.onDestroy();\n\t\t   Log.e(TAG,\"stop keep app activity\");\n\t   }\n\t}\n\t```\n\n\t此外，还要设置 Activity 无背景且透明。KeepLiveActivity 的 taskAffinity 应与应用默认taskAffinity 不同。\n\n\t```xml\n\t<activity\n\t   android:taskAffinity=\"com.awqingnian.demo.keep.live\"\n\t   android:theme=\"@style/KeepLiveTheme\" />\n\n\t<style name=\"KeepLiveTheme\">\n\t   <item name=\"android:windowBackground\">@null</item>\n\t   <item name=\"android:windowIsTranslucent\">true</item>\n\t</style>\n\t```\n\n\t剩下就是添加息屏广播监听，在广播监听 onReceive() 中启动 KeepLiveActivity.\n\n\t- 方法二：开启一个通过调用 startForeground() 方法来绑定一个前台通知的 Service。（提高进程优先级）\n\n\t  此方法用户会看到通知栏中存在一个通知。\n\n\t  ```java\n\t  @Override\n\t  public int onStartCommand(Intent intent, int flags, int startId) {\n\t\t Intent intent = new Intent(this, MainActivity.class);\n\t\t PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);\n\t\t NotificationCompat.Builder builder = new NotificationCompat.Builder(this)\n\t\t   .setSmallIcon(R.mipmap.ic_launcher);\n\t\t   .setContentTitle(\"Foreground\");\n\t\t   .setContentText(\"I am a foreground service\");\n\t\t   .setContentInfo(\"Content Info\");\n\t\t   .setWhen(System.currentTimeMillis());\n\t\t builder.setContentIntent(pi);\n\t\t Notification notification = builder.build();\n\t\t startForeground(FOREGROUND_ID, notification);\n\t\t return super.onStartCommand(intent, flags, startId);\n\t  }\n\t  ```\n\n\t- 方法三：在方法二基础上隐藏通知。能否实现隐藏与版本有关，SDK >= 19 可以实现。（提高进程优先级）\n\n\t  先修改绑定前台通知 Service 的 onStartCommand() 里面部分部分逻辑\n\n\t  ```java\n\t  @Override\n\t  public int onStartCommand(Intent intent, int flags, int startId) {\n\t\t try {\n\t\t\t Notification notification = new Notification();\n\t\t\t if (Build.VERSION.SDK_INT < 18) {\n\t\t\t\t startForeground(NOTIFICATION_ID, notification);\n\t\t\t } else {\n\t\t\t\t startForeground(NOTIFICATION_ID, notification);\n\t\t\t\t // start InnerService\n\t\t\t\t startService(new Intent(this, InnerService.class));\n\t\t\t }\n\t\t } catch (Throwable e) {\n\t\t\t e.printStackTrace();\n\t\t }\n\t  \n\t\t return super.onStartCommand(intent, flags, startId);\n\t  }\n\t  ```\n\n\t  然后再 InnerService 中关闭之前打开的 Notification （通知）\n\n\t  ```\n\t  @Override\n\t  public void onCreate() {\n\t\t super.onCreate();\n\t\t try {\n\t\t\t startForeground(NOTIFICATION_ID, new Notification());\n\t\t } catch (Throwable throwable) {\n\t\t\t throwable.printStackTrace();\n\t\t }\n\t\t stopSelf();\n\t  ```\n\n\t##### 拉活进程（在进程被杀死之后）\n\n\t- 方法一：广播拉活\n\n\t- 方法二：系统Service机制拉活\n\n\t- 方法三：使用账户同步拉活\n\n\t- 方法四：使用JobSchedule拉活\n\n\t- 方法五：双进程守护","source":"_posts/Android 进程保活.md","raw":"---\ntitle: Android 进程\ndate: 2018-07-06 12:44:05\ntags:\n---\n\n- 进程的理解\n\n  - 通常情况下，Android 的四大组件都在同一进程中运行，但是也可以指定组件在特定的进程中进行，通过配置 Mainfest.xml 文件下，四大组件标签内配置 android：process 属性，则可以指定该组件在哪个进程中运行。\n\n- 如何达到进程保活？\n\n  - 避免被杀死，先提高进程的优先级（priority），进程优先级越低越易被杀死。查看进程优先级：\n\t\t```\n\t\tadb shell ps | grep  packageName\n\t\t```\n  - 在进程被杀死情况下，通过某些方法重新启动进程\n\n<!--more-->\n\n- 为什么 Android 系统会杀死进程？\n\n  ![杀死进程原因](https://segmentfault.com/img/remote/1460000006252378)\n\n- 进程等级（优先级由低到高）\n\n  - 前台进程\n\n    - 正在交互的 Activity \n\n    - 绑定正在交互 Activity 的 Service \n\n    - 前台 Service （Service.startForeground( )）\n\n    - 正执行 onCreat(),  onStart(), onDestroy() 的 Service \n\n    - 正执行 onReceive() 的 BoradcastReceiver \n\n  - 可见进程\n\n    - 不在前台，但可见的 Activity（onPause()） ，如开启一个 D\n\n    - 绑定到可见（或前台）Activity 的 Service \n\n  - 后台进程\n\n    - 主要是不可见的 Activity 的进程。这些进程的关闭对用户没有多大影响，Android 系统内存不足可以直接关闭。\n\n  - 空进程\n\n    - 不包含任何应用组件的进程，唯一作用：缓存，缩短下次运行组件所需的启动时间。\n\n- 杀进程回收内存的机制（Low Memory Killer）\n\n|adj级别|值|解释|\n| :----: | :----: | :----: |\n|UNKNOWN_ADJ|16|预留的最低级别，一般对于缓存的进程才有可能设置成这个级别|\n|CACHED_APP_MAX_ADJ|15|缓存进程，空进程，在内存不足的情况下就会优先被kill|\n|CACHED_APP_MIN_ADJ|9|缓存进程，也就是空进程|\n|SERVICE_B_ADJ|8|不活跃的进程|\n|PREVIOUS_APP_ADJ|7|切换进程|\n|HOME_APP_ADJ|6|与Home交互的进程|\n|SERVICE_ADJ|5|有Service的进程|\n|HEAVY_WEIGHT_APP_ADJ|4|高权重进程|\n|BACKUP_APP_ADJ|3|正在备份的进程|\n|PERCEPTIBLE_APP_ADJ|2|可感知的进程，比如那种播放音乐|\n|VISIBLE_APP_ADJ|1|可见进程，如当前的Activity|\n|FOREGROUND_APP_ADJ|0|前台进程|\n|PERSISTENT_SERVICE_ADJ|-11|重要进程|\n|PERSISTENT_PROC_ADJ|-12|核心进程|\n|SYSTEM_ADJ|-16|系统进程|\n|NATIVE_ADJ|-17|系统起的Native进程|\n\t\noom_adj 取值越高越易被杀死，oom_adj 与进程优先级成反比，oom_adj 越高进程优先级越低。\n- 如何达到进程保活？（让 APP 不被 Android 系统杀死）\n\n\t##### 提高进程优先级（在进程被杀死之前）\n\n\t- 方法一：若用户使用电源键息屏，监听息屏和解锁的广播，息屏时候启动一个只有一个像素的 Activity（息屏时候应用优先级很高），不易被杀死也不易被用户发现。（提高进程优先级）\n\n\t```java\n\tpublic class KeepLiveActivity extends Activity {\n\t  \n\t\t//在监听息屏的广播中启动这个 Activity\n\t\tpublic static void startAvtivity(Context context){\n\t\t\tIntent intent = new Intent(context, KeepLiveActivity.class);\n\t\t\tcontext.startActivity(intent);\n\t  }\n\t  \n\t  private static final String TAG = \"KeepLiveActivity\";\n\t  @Override\n\t  protected void onCreate(Bundle savedInstanceState) {\n\t\t   super.onCreate(savedInstanceState);\n\t\t   Log.e(TAG,\"start Keep app activity\");\n\t\t   Window window = getWindow();\n\t\t   //设置 Activity 窗口位置在 START TOP 位置（也就是左上角）\n\t\t   window.setGravity(Gravity.START | Gravity.TOP);\n\t\t   //设置宽高都为 1\n\t\t   WindowManager.LayoutParams attributes = window.getAttributes();\n\t\t   attributes.width = 1;\n\t\t   attributes.height = 1;\n\t\t   attributes.x = 0;\n\t\t   attributes.y = 0;\n\t\t   window.setAttributes(attributes);\n\t   }\n\n\t   @Override\n\t   protected void onDestroy() {\n\t\t   super.onDestroy();\n\t\t   Log.e(TAG,\"stop keep app activity\");\n\t   }\n\t}\n\t```\n\n\t此外，还要设置 Activity 无背景且透明。KeepLiveActivity 的 taskAffinity 应与应用默认taskAffinity 不同。\n\n\t```xml\n\t<activity\n\t   android:taskAffinity=\"com.awqingnian.demo.keep.live\"\n\t   android:theme=\"@style/KeepLiveTheme\" />\n\n\t<style name=\"KeepLiveTheme\">\n\t   <item name=\"android:windowBackground\">@null</item>\n\t   <item name=\"android:windowIsTranslucent\">true</item>\n\t</style>\n\t```\n\n\t剩下就是添加息屏广播监听，在广播监听 onReceive() 中启动 KeepLiveActivity.\n\n\t- 方法二：开启一个通过调用 startForeground() 方法来绑定一个前台通知的 Service。（提高进程优先级）\n\n\t  此方法用户会看到通知栏中存在一个通知。\n\n\t  ```java\n\t  @Override\n\t  public int onStartCommand(Intent intent, int flags, int startId) {\n\t\t Intent intent = new Intent(this, MainActivity.class);\n\t\t PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0);\n\t\t NotificationCompat.Builder builder = new NotificationCompat.Builder(this)\n\t\t   .setSmallIcon(R.mipmap.ic_launcher);\n\t\t   .setContentTitle(\"Foreground\");\n\t\t   .setContentText(\"I am a foreground service\");\n\t\t   .setContentInfo(\"Content Info\");\n\t\t   .setWhen(System.currentTimeMillis());\n\t\t builder.setContentIntent(pi);\n\t\t Notification notification = builder.build();\n\t\t startForeground(FOREGROUND_ID, notification);\n\t\t return super.onStartCommand(intent, flags, startId);\n\t  }\n\t  ```\n\n\t- 方法三：在方法二基础上隐藏通知。能否实现隐藏与版本有关，SDK >= 19 可以实现。（提高进程优先级）\n\n\t  先修改绑定前台通知 Service 的 onStartCommand() 里面部分部分逻辑\n\n\t  ```java\n\t  @Override\n\t  public int onStartCommand(Intent intent, int flags, int startId) {\n\t\t try {\n\t\t\t Notification notification = new Notification();\n\t\t\t if (Build.VERSION.SDK_INT < 18) {\n\t\t\t\t startForeground(NOTIFICATION_ID, notification);\n\t\t\t } else {\n\t\t\t\t startForeground(NOTIFICATION_ID, notification);\n\t\t\t\t // start InnerService\n\t\t\t\t startService(new Intent(this, InnerService.class));\n\t\t\t }\n\t\t } catch (Throwable e) {\n\t\t\t e.printStackTrace();\n\t\t }\n\t  \n\t\t return super.onStartCommand(intent, flags, startId);\n\t  }\n\t  ```\n\n\t  然后再 InnerService 中关闭之前打开的 Notification （通知）\n\n\t  ```\n\t  @Override\n\t  public void onCreate() {\n\t\t super.onCreate();\n\t\t try {\n\t\t\t startForeground(NOTIFICATION_ID, new Notification());\n\t\t } catch (Throwable throwable) {\n\t\t\t throwable.printStackTrace();\n\t\t }\n\t\t stopSelf();\n\t  ```\n\n\t##### 拉活进程（在进程被杀死之后）\n\n\t- 方法一：广播拉活\n\n\t- 方法二：系统Service机制拉活\n\n\t- 方法三：使用账户同步拉活\n\n\t- 方法四：使用JobSchedule拉活\n\n\t- 方法五：双进程守护","slug":"Android 进程保活","published":1,"updated":"2018-07-06T09:15:24.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzck0008s8o5wbf90p4j","content":"<ul>\n<li><p>进程的理解</p>\n<ul>\n<li>通常情况下，Android 的四大组件都在同一进程中运行，但是也可以指定组件在特定的进程中进行，通过配置 Mainfest.xml 文件下，四大组件标签内配置 android：process 属性，则可以指定该组件在哪个进程中运行。</li>\n</ul>\n</li>\n<li><p>如何达到进程保活？</p>\n<ul>\n<li><p>避免被杀死，先提高进程的优先级（priority），进程优先级越低越易被杀死。查看进程优先级：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell ps | grep  packageName</span><br></pre></td></tr></table></figure>\n</code></pre></li>\n<li><p>在进程被杀死情况下，通过某些方法重新启动进程</p>\n</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li><p>为什么 Android 系统会杀死进程？</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000006252378\" alt=\"杀死进程原因\"></p>\n</li>\n<li><p>进程等级（优先级由低到高）</p>\n<ul>\n<li><p>前台进程</p>\n<ul>\n<li><p>正在交互的 Activity </p>\n</li>\n<li><p>绑定正在交互 Activity 的 Service </p>\n</li>\n<li><p>前台 Service （Service.startForeground( )）</p>\n</li>\n<li><p>正执行 onCreat(),  onStart(), onDestroy() 的 Service </p>\n</li>\n<li><p>正执行 onReceive() 的 BoradcastReceiver </p>\n</li>\n</ul>\n</li>\n<li><p>可见进程</p>\n<ul>\n<li><p>不在前台，但可见的 Activity（onPause()） ，如开启一个 D</p>\n</li>\n<li><p>绑定到可见（或前台）Activity 的 Service </p>\n</li>\n</ul>\n</li>\n<li><p>后台进程</p>\n<ul>\n<li>主要是不可见的 Activity 的进程。这些进程的关闭对用户没有多大影响，Android 系统内存不足可以直接关闭。</li>\n</ul>\n</li>\n<li><p>空进程</p>\n<ul>\n<li>不包含任何应用组件的进程，唯一作用：缓存，缩短下次运行组件所需的启动时间。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>杀进程回收内存的机制（Low Memory Killer）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">adj级别</th>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">UNKNOWN_ADJ</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">预留的最低级别，一般对于缓存的进程才有可能设置成这个级别</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CACHED_APP_MAX_ADJ</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">缓存进程，空进程，在内存不足的情况下就会优先被kill</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CACHED_APP_MIN_ADJ</td>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">缓存进程，也就是空进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERVICE_B_ADJ</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">不活跃的进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PREVIOUS_APP_ADJ</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">切换进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HOME_APP_ADJ</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">与Home交互的进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERVICE_ADJ</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">有Service的进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HEAVY_WEIGHT_APP_ADJ</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">高权重进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BACKUP_APP_ADJ</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">正在备份的进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PERCEPTIBLE_APP_ADJ</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">可感知的进程，比如那种播放音乐</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">VISIBLE_APP_ADJ</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">可见进程，如当前的Activity</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">FOREGROUND_APP_ADJ</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">前台进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PERSISTENT_SERVICE_ADJ</td>\n<td style=\"text-align:center\">-11</td>\n<td style=\"text-align:center\">重要进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PERSISTENT_PROC_ADJ</td>\n<td style=\"text-align:center\">-12</td>\n<td style=\"text-align:center\">核心进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SYSTEM_ADJ</td>\n<td style=\"text-align:center\">-16</td>\n<td style=\"text-align:center\">系统进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NATIVE_ADJ</td>\n<td style=\"text-align:center\">-17</td>\n<td style=\"text-align:center\">系统起的Native进程</td>\n</tr>\n</tbody>\n</table>\n<p>oom_adj 取值越高越易被杀死，oom_adj 与进程优先级成反比，oom_adj 越高进程优先级越低。</p>\n<ul>\n<li><p>如何达到进程保活？（让 APP 不被 Android 系统杀死）</p>\n<h5 id=\"提高进程优先级（在进程被杀死之前）\"><a href=\"#提高进程优先级（在进程被杀死之前）\" class=\"headerlink\" title=\"提高进程优先级（在进程被杀死之前）\"></a>提高进程优先级（在进程被杀死之前）</h5><ul>\n<li><p>方法一：若用户使用电源键息屏，监听息屏和解锁的广播，息屏时候启动一个只有一个像素的 Activity（息屏时候应用优先级很高），不易被杀死也不易被用户发现。（提高进程优先级）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeepLiveActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//在监听息屏的广播中启动这个 Activity</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startAvtivity</span><span class=\"params\">(Context context)</span></span>&#123;</span><br><span class=\"line\">\t\tIntent intent = <span class=\"keyword\">new</span> Intent(context, KeepLiveActivity.class);</span><br><span class=\"line\">\t\tcontext.startActivity(intent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"KeepLiveActivity\"</span>;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">\t   <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">\t   Log.e(TAG,<span class=\"string\">\"start Keep app activity\"</span>);</span><br><span class=\"line\">\t   Window window = getWindow();</span><br><span class=\"line\">\t   <span class=\"comment\">//设置 Activity 窗口位置在 START TOP 位置（也就是左上角）</span></span><br><span class=\"line\">\t   window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class=\"line\">\t   <span class=\"comment\">//设置宽高都为 1</span></span><br><span class=\"line\">\t   WindowManager.LayoutParams attributes = window.getAttributes();</span><br><span class=\"line\">\t   attributes.width = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t   attributes.height = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t   attributes.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t   attributes.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t   window.setAttributes(attributes);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t   <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">\t   Log.e(TAG,<span class=\"string\">\"stop keep app activity\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，还要设置 Activity 无背景且透明。KeepLiveActivity 的 taskAffinity 应与应用默认taskAffinity 不同。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">\"com.awqingnian.demo.keep.live\"</span></span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/KeepLiveTheme\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"KeepLiveTheme\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\">   <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowBackground\"</span>&gt;</span>@null<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">   <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowIsTranslucent\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>剩下就是添加息屏广播监听，在广播监听 onReceive() 中启动 KeepLiveActivity.</p>\n</li>\n<li><p>方法二：开启一个通过调用 startForeground() 方法来绑定一个前台通知的 Service。（提高进程优先级）</p>\n<p>此方法用户会看到通知栏中存在一个通知。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>&#123;</span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, MainActivity.class);</span><br><span class=\"line\">PendingIntent pi = PendingIntent.getActivity(<span class=\"keyword\">this</span>, <span class=\"number\">0</span>, intent, <span class=\"number\">0</span>);</span><br><span class=\"line\">NotificationCompat.Builder builder = <span class=\"keyword\">new</span> NotificationCompat.Builder(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  .setSmallIcon(R.mipmap.ic_launcher);</span><br><span class=\"line\">  .setContentTitle(<span class=\"string\">\"Foreground\"</span>);</span><br><span class=\"line\">  .setContentText(<span class=\"string\">\"I am a foreground service\"</span>);</span><br><span class=\"line\">  .setContentInfo(<span class=\"string\">\"Content Info\"</span>);</span><br><span class=\"line\">  .setWhen(System.currentTimeMillis());</span><br><span class=\"line\">builder.setContentIntent(pi);</span><br><span class=\"line\">Notification notification = builder.build();</span><br><span class=\"line\">startForeground(FOREGROUND_ID, notification);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent, flags, startId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三：在方法二基础上隐藏通知。能否实现隐藏与版本有关，SDK &gt;= 19 可以实现。（提高进程优先级）</p>\n<p>先修改绑定前台通知 Service 的 onStartCommand() 里面部分部分逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"> Notification notification = <span class=\"keyword\">new</span> Notification();</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">\t startForeground(NOTIFICATION_ID, notification);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t startForeground(NOTIFICATION_ID, notification);</span><br><span class=\"line\">\t <span class=\"comment\">// start InnerService</span></span><br><span class=\"line\">\t startService(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, InnerService.class));</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\"> e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent, flags, startId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再 InnerService 中关闭之前打开的 Notification （通知）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onCreate() &#123;</span><br><span class=\"line\">super.onCreate();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\"> startForeground(NOTIFICATION_ID, new Notification());</span><br><span class=\"line\">&#125; catch (Throwable throwable) &#123;</span><br><span class=\"line\"> throwable.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stopSelf();</span><br></pre></td></tr></table></figure>\n<h5 id=\"拉活进程（在进程被杀死之后）\"><a href=\"#拉活进程（在进程被杀死之后）\" class=\"headerlink\" title=\"拉活进程（在进程被杀死之后）\"></a>拉活进程（在进程被杀死之后）</h5></li>\n<li><p>方法一：广播拉活</p>\n</li>\n<li><p>方法二：系统Service机制拉活</p>\n</li>\n<li><p>方法三：使用账户同步拉活</p>\n</li>\n<li><p>方法四：使用JobSchedule拉活</p>\n</li>\n<li><p>方法五：双进程守护</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<ul>\n<li><p>进程的理解</p>\n<ul>\n<li>通常情况下，Android 的四大组件都在同一进程中运行，但是也可以指定组件在特定的进程中进行，通过配置 Mainfest.xml 文件下，四大组件标签内配置 android：process 属性，则可以指定该组件在哪个进程中运行。</li>\n</ul>\n</li>\n<li><p>如何达到进程保活？</p>\n<ul>\n<li><p>避免被杀死，先提高进程的优先级（priority），进程优先级越低越易被杀死。查看进程优先级：</p>\n<pre><code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb shell ps | grep  packageName</span><br></pre></td></tr></table></figure>\n</code></pre></li>\n<li><p>在进程被杀死情况下，通过某些方法重新启动进程</p>\n</li>\n</ul>\n</li>\n</ul>","more":"<ul>\n<li><p>为什么 Android 系统会杀死进程？</p>\n<p><img src=\"https://segmentfault.com/img/remote/1460000006252378\" alt=\"杀死进程原因\"></p>\n</li>\n<li><p>进程等级（优先级由低到高）</p>\n<ul>\n<li><p>前台进程</p>\n<ul>\n<li><p>正在交互的 Activity </p>\n</li>\n<li><p>绑定正在交互 Activity 的 Service </p>\n</li>\n<li><p>前台 Service （Service.startForeground( )）</p>\n</li>\n<li><p>正执行 onCreat(),  onStart(), onDestroy() 的 Service </p>\n</li>\n<li><p>正执行 onReceive() 的 BoradcastReceiver </p>\n</li>\n</ul>\n</li>\n<li><p>可见进程</p>\n<ul>\n<li><p>不在前台，但可见的 Activity（onPause()） ，如开启一个 D</p>\n</li>\n<li><p>绑定到可见（或前台）Activity 的 Service </p>\n</li>\n</ul>\n</li>\n<li><p>后台进程</p>\n<ul>\n<li>主要是不可见的 Activity 的进程。这些进程的关闭对用户没有多大影响，Android 系统内存不足可以直接关闭。</li>\n</ul>\n</li>\n<li><p>空进程</p>\n<ul>\n<li>不包含任何应用组件的进程，唯一作用：缓存，缩短下次运行组件所需的启动时间。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>杀进程回收内存的机制（Low Memory Killer）</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">adj级别</th>\n<th style=\"text-align:center\">值</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">UNKNOWN_ADJ</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">预留的最低级别，一般对于缓存的进程才有可能设置成这个级别</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CACHED_APP_MAX_ADJ</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">缓存进程，空进程，在内存不足的情况下就会优先被kill</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CACHED_APP_MIN_ADJ</td>\n<td style=\"text-align:center\">9</td>\n<td style=\"text-align:center\">缓存进程，也就是空进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERVICE_B_ADJ</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">不活跃的进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PREVIOUS_APP_ADJ</td>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">切换进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HOME_APP_ADJ</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">与Home交互的进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERVICE_ADJ</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">有Service的进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HEAVY_WEIGHT_APP_ADJ</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">高权重进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BACKUP_APP_ADJ</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">正在备份的进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PERCEPTIBLE_APP_ADJ</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">可感知的进程，比如那种播放音乐</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">VISIBLE_APP_ADJ</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">可见进程，如当前的Activity</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">FOREGROUND_APP_ADJ</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">前台进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PERSISTENT_SERVICE_ADJ</td>\n<td style=\"text-align:center\">-11</td>\n<td style=\"text-align:center\">重要进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PERSISTENT_PROC_ADJ</td>\n<td style=\"text-align:center\">-12</td>\n<td style=\"text-align:center\">核心进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SYSTEM_ADJ</td>\n<td style=\"text-align:center\">-16</td>\n<td style=\"text-align:center\">系统进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NATIVE_ADJ</td>\n<td style=\"text-align:center\">-17</td>\n<td style=\"text-align:center\">系统起的Native进程</td>\n</tr>\n</tbody>\n</table>\n<p>oom_adj 取值越高越易被杀死，oom_adj 与进程优先级成反比，oom_adj 越高进程优先级越低。</p>\n<ul>\n<li><p>如何达到进程保活？（让 APP 不被 Android 系统杀死）</p>\n<h5 id=\"提高进程优先级（在进程被杀死之前）\"><a href=\"#提高进程优先级（在进程被杀死之前）\" class=\"headerlink\" title=\"提高进程优先级（在进程被杀死之前）\"></a>提高进程优先级（在进程被杀死之前）</h5><ul>\n<li><p>方法一：若用户使用电源键息屏，监听息屏和解锁的广播，息屏时候启动一个只有一个像素的 Activity（息屏时候应用优先级很高），不易被杀死也不易被用户发现。（提高进程优先级）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeepLiveActivity</span> <span class=\"keyword\">extends</span> <span class=\"title\">Activity</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">\t<span class=\"comment\">//在监听息屏的广播中启动这个 Activity</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startAvtivity</span><span class=\"params\">(Context context)</span></span>&#123;</span><br><span class=\"line\">\t\tIntent intent = <span class=\"keyword\">new</span> Intent(context, KeepLiveActivity.class);</span><br><span class=\"line\">\t\tcontext.startActivity(intent);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String TAG = <span class=\"string\">\"KeepLiveActivity\"</span>;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onCreate</span><span class=\"params\">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class=\"line\">\t   <span class=\"keyword\">super</span>.onCreate(savedInstanceState);</span><br><span class=\"line\">\t   Log.e(TAG,<span class=\"string\">\"start Keep app activity\"</span>);</span><br><span class=\"line\">\t   Window window = getWindow();</span><br><span class=\"line\">\t   <span class=\"comment\">//设置 Activity 窗口位置在 START TOP 位置（也就是左上角）</span></span><br><span class=\"line\">\t   window.setGravity(Gravity.START | Gravity.TOP);</span><br><span class=\"line\">\t   <span class=\"comment\">//设置宽高都为 1</span></span><br><span class=\"line\">\t   WindowManager.LayoutParams attributes = window.getAttributes();</span><br><span class=\"line\">\t   attributes.width = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t   attributes.height = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t   attributes.x = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t   attributes.y = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t   window.setAttributes(attributes);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onDestroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t   <span class=\"keyword\">super</span>.onDestroy();</span><br><span class=\"line\">\t   Log.e(TAG,<span class=\"string\">\"stop keep app activity\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，还要设置 Activity 无背景且透明。KeepLiveActivity 的 taskAffinity 应与应用默认taskAffinity 不同。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">activity</span></span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">android:taskAffinity</span>=<span class=\"string\">\"com.awqingnian.demo.keep.live\"</span></span></span><br><span class=\"line\"><span class=\"tag\">   <span class=\"attr\">android:theme</span>=<span class=\"string\">\"@style/KeepLiveTheme\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">name</span>=<span class=\"string\">\"KeepLiveTheme\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"xml\">   <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowBackground\"</span>&gt;</span>@null<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">   <span class=\"tag\">&lt;<span class=\"name\">item</span> <span class=\"attr\">name</span>=<span class=\"string\">\"android:windowIsTranslucent\"</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">item</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>剩下就是添加息屏广播监听，在广播监听 onReceive() 中启动 KeepLiveActivity.</p>\n</li>\n<li><p>方法二：开启一个通过调用 startForeground() 方法来绑定一个前台通知的 Service。（提高进程优先级）</p>\n<p>此方法用户会看到通知栏中存在一个通知。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>&#123;</span><br><span class=\"line\">Intent intent = <span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, MainActivity.class);</span><br><span class=\"line\">PendingIntent pi = PendingIntent.getActivity(<span class=\"keyword\">this</span>, <span class=\"number\">0</span>, intent, <span class=\"number\">0</span>);</span><br><span class=\"line\">NotificationCompat.Builder builder = <span class=\"keyword\">new</span> NotificationCompat.Builder(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  .setSmallIcon(R.mipmap.ic_launcher);</span><br><span class=\"line\">  .setContentTitle(<span class=\"string\">\"Foreground\"</span>);</span><br><span class=\"line\">  .setContentText(<span class=\"string\">\"I am a foreground service\"</span>);</span><br><span class=\"line\">  .setContentInfo(<span class=\"string\">\"Content Info\"</span>);</span><br><span class=\"line\">  .setWhen(System.currentTimeMillis());</span><br><span class=\"line\">builder.setContentIntent(pi);</span><br><span class=\"line\">Notification notification = builder.build();</span><br><span class=\"line\">startForeground(FOREGROUND_ID, notification);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent, flags, startId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方法三：在方法二基础上隐藏通知。能否实现隐藏与版本有关，SDK &gt;= 19 可以实现。（提高进程优先级）</p>\n<p>先修改绑定前台通知 Service 的 onStartCommand() 里面部分部分逻辑</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">onStartCommand</span><span class=\"params\">(Intent intent, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> startId)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"> Notification notification = <span class=\"keyword\">new</span> Notification();</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (Build.VERSION.SDK_INT &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">\t startForeground(NOTIFICATION_ID, notification);</span><br><span class=\"line\"> &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t startForeground(NOTIFICATION_ID, notification);</span><br><span class=\"line\">\t <span class=\"comment\">// start InnerService</span></span><br><span class=\"line\">\t startService(<span class=\"keyword\">new</span> Intent(<span class=\"keyword\">this</span>, InnerService.class));</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</span><br><span class=\"line\"> e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.onStartCommand(intent, flags, startId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后再 InnerService 中关闭之前打开的 Notification （通知）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Override</span><br><span class=\"line\">public void onCreate() &#123;</span><br><span class=\"line\">super.onCreate();</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\"> startForeground(NOTIFICATION_ID, new Notification());</span><br><span class=\"line\">&#125; catch (Throwable throwable) &#123;</span><br><span class=\"line\"> throwable.printStackTrace();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">stopSelf();</span><br></pre></td></tr></table></figure>\n<h5 id=\"拉活进程（在进程被杀死之后）\"><a href=\"#拉活进程（在进程被杀死之后）\" class=\"headerlink\" title=\"拉活进程（在进程被杀死之后）\"></a>拉活进程（在进程被杀死之后）</h5></li>\n<li><p>方法一：广播拉活</p>\n</li>\n<li><p>方法二：系统Service机制拉活</p>\n</li>\n<li><p>方法三：使用账户同步拉活</p>\n</li>\n<li><p>方法四：使用JobSchedule拉活</p>\n</li>\n<li><p>方法五：双进程守护</p>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"操作系统","date":"2018-11-27T06:54:09.981Z","_content":"\n- 进程和线程的区别？\n  1. 进程是系统进行资源分配和调度的一个独立单位，拥有独立的系统资源空间（内存地址），一个应用程序至少有一个进程，一个进程至少有一个线程。\n  2. 线程是进程的一个实体，是 CPU 调度和分配的基本单位，必须依赖应用程序（进程）存在。线程只拥有一点在线程运行过程必须的资源，但是线程之间没有单独的地址空间。\n- ","source":"_posts/操作系统.md","raw":"title: 操作系统\ndate: 2018-11-30 14.00\ntags:\n\n------\n\n- 进程和线程的区别？\n  1. 进程是系统进行资源分配和调度的一个独立单位，拥有独立的系统资源空间（内存地址），一个应用程序至少有一个进程，一个进程至少有一个线程。\n  2. 线程是进程的一个实体，是 CPU 调度和分配的基本单位，必须依赖应用程序（进程）存在。线程只拥有一点在线程运行过程必须的资源，但是线程之间没有单独的地址空间。\n- ","slug":"操作系统","published":1,"updated":"2018-11-27T11:08:35.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzcn0009s8o5c9y3l9bc","content":"<ul>\n<li>进程和线程的区别？<ol>\n<li>进程是系统进行资源分配和调度的一个独立单位，拥有独立的系统资源空间（内存地址），一个应用程序至少有一个进程，一个进程至少有一个线程。</li>\n<li>线程是进程的一个实体，是 CPU 调度和分配的基本单位，必须依赖应用程序（进程）存在。线程只拥有一点在线程运行过程必须的资源，但是线程之间没有单独的地址空间。</li>\n</ol>\n</li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>进程和线程的区别？<ol>\n<li>进程是系统进行资源分配和调度的一个独立单位，拥有独立的系统资源空间（内存地址），一个应用程序至少有一个进程，一个进程至少有一个线程。</li>\n<li>线程是进程的一个实体，是 CPU 调度和分配的基本单位，必须依赖应用程序（进程）存在。线程只拥有一点在线程运行过程必须的资源，但是线程之间没有单独的地址空间。</li>\n</ol>\n</li>\n<li></li>\n</ul>\n"},{"title":"Java Thread","date":"2018-07-27T02:33:28.000Z","_content":"\n##### 简单介绍一下线程\n\n- 线程是一个程序的多个执行路径，执行调度的单位，依托于进程存在。 线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。\n\n<!--more-->\n\n##### 如何开启线程（三种方法）\n\n禁止直接调用 run 方法，否则不是另开线程，还是在原来的线程工作。\n\n```java\nclass MyThread extend Thread {\n    public void run {\n        //继承线程\n    }\n}\n\nMyThread myThread = new MyThread();\nmyThread.start();//开启线程\n```\n\n```java\nclass MyThread implement Runnable {\n    public void run {\n        //实现 Runnable 接口\n    }\n}\n\nMyThread myThread = new MyThread();\nThread t = new Thread(myThread);\nt.start();//开启线程\n```\n\n```java\nnew Thread(new Runnable(){\n    public void run() {\n        //匿名内部类实现线程开启\n    }\n}).start();\n```\n\n##### 线程中断的原因\n\n1. 线程的 run 方法执行完最后一句语句后\n2. 线程在 run 方法中出现没有捕获的异常\n3. 可以通过 interrupt 方法来请求终止线程\n4. 被中断的线程可以决定如何相应中断（中断线程只不过是引起线程的注意）\n\n```java\nvoid interrupt()//发送中断请求，线程中断状态设置为 true ，若线程被 sleep 阻塞，抛出 InterruptedException 异常。\nstatic boolean interrupted()//测试线程是否被中断（无论如何，中断状态重置为 false）\nboolean is Interrupted()//测试线程是否被终止（不改变线程的中断状态）\nstatic Thread currentThread()//获取当前执行线程的 Thread 对象\n```\n\n##### 线程的状态（5 种状态）\n\n![image](http://duqiblog.qiniudn.com/Java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)\n\n- New （新建状态） 即： Thread thread = new Thread();\n\n- Runnable （就绪状态） 其他线程调用 thread.start(); 等待 CPU 调度运行\n\n- Running （运行状态） 线程只能从就绪状态进入运行状态\n\n- Blocked （阻塞状态）放弃 CPU 运行。原因有三种  \n\n  - 等待阻塞 ：thread.wait();  \n\n  - 同步阻塞 ：synchronized 同步锁被其他线程占用  \n\n  - 其他阻塞 ：调用线程的 sleep() 或 join() 或 发出I/O请求。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 \n\n- Dead （死亡状态）执行完 或 因异常 退出 run 方法。\n\n##### 线程的属性\n\n- 优先级 ：由于在 Windows 操作系统下有 7 个优先级别，但在 Linux 操作系统，线程的优先级别被忽略，所有线程具有相同的优先级别。所以要少用优先级别来构建程序功能，避免出现因线程优先级别出现的程序烦恼。\n\n  ```java\n  void setPriority(int newPriority); //1 - 10 之间\n  static int MIN_PRIORITY //最小优先级别 1\n  static int MAX_PRIORITY //最大优先级别 10\n  static int NORM_PRIORITY //默认优先级别 5\n  static void yield();//线程让步（对相同优先级别的线程）\n  ```\n\n- 守护线程 ：没啥用，就为其他线程提供服务。\n\n- 未捕获异常处理器 setUncaughtExceptionHandler 方法为线程安装一个处理器。 setDefaultUncaughtExceptionHandler 为线程安装默认处理器。默认的处理器为空，替换处理器可以使用日志 API 来发送捕获异常的报告到日志文件中。  \n\n##### 线程同步\n\n为什么需要线程同步？  \n答：由于 2 个或多个线程共享同一数据，导致数据错乱。（也称竞争条件）  \n\n实现代码同步的方法：\n\n- 锁对象 （ReentrantLock 保护代码块）\n\n  ```java\n  myLock.lock(); //一个 ReentrantLock 对象\n  try {\n      //被锁的代码块\n  }finally {\n      myLock.Unlock(); //一定要解锁，否则其他线程永远阻塞\n  }\n  ```\n\n- 使用 synchronized 关键字（建议使用）\n\n  ```java\n  public sychronized void method (){\n      //同步代码块（同步方法）\n  }\n  \n          //等价于\n  \n  public void method(){\n      this,intrinsicLock.lock();\n      try {\n          //同步代码\n      } finally {\n              this,intrinsicLock.unlock();\n      }\n  }\n  ```\n\n##### 带返回值的线程（Callable 和 FutureTask）以及 线程池\n\n```java\nclass MyCallable implements Callable{ \n        private String oid; \n\n        MyCallable(String oid) { \n                this.oid = oid; \n        } \n\n        @Override \n        public Object call() throws Exception { \n                return oid+\"任务返回的内容\"; \n        } \n}\n\n//创建一个线程池 \nExecutorService pool = Executors.newFixedThreadPool(2); \n//创建两个有返回值的任务 \nCallable c1 = new MyCallable(\"A\"); \nCallable c2 = new MyCallable(\"B\"); \n//执行任务并获取Future对象 \nFuture f1 = pool.submit(c1); \nFuture f2 = pool.submit(c2); \n//从Future对象上获取任务的返回值，并输出到控制台 \nSystem.out.println(\">>>\"+f1.get().toString()); \nSystem.out.println(\">>>\"+f2.get().toString()); \n//关闭线程池 \npool.shutdown();\n```\n","source":"_posts/Java Thread.md","raw":"---\ntitle: Java Thread\ndate: 2018-07-27 10:33:28\ntags:\n---\n\n##### 简单介绍一下线程\n\n- 线程是一个程序的多个执行路径，执行调度的单位，依托于进程存在。 线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。\n\n<!--more-->\n\n##### 如何开启线程（三种方法）\n\n禁止直接调用 run 方法，否则不是另开线程，还是在原来的线程工作。\n\n```java\nclass MyThread extend Thread {\n    public void run {\n        //继承线程\n    }\n}\n\nMyThread myThread = new MyThread();\nmyThread.start();//开启线程\n```\n\n```java\nclass MyThread implement Runnable {\n    public void run {\n        //实现 Runnable 接口\n    }\n}\n\nMyThread myThread = new MyThread();\nThread t = new Thread(myThread);\nt.start();//开启线程\n```\n\n```java\nnew Thread(new Runnable(){\n    public void run() {\n        //匿名内部类实现线程开启\n    }\n}).start();\n```\n\n##### 线程中断的原因\n\n1. 线程的 run 方法执行完最后一句语句后\n2. 线程在 run 方法中出现没有捕获的异常\n3. 可以通过 interrupt 方法来请求终止线程\n4. 被中断的线程可以决定如何相应中断（中断线程只不过是引起线程的注意）\n\n```java\nvoid interrupt()//发送中断请求，线程中断状态设置为 true ，若线程被 sleep 阻塞，抛出 InterruptedException 异常。\nstatic boolean interrupted()//测试线程是否被中断（无论如何，中断状态重置为 false）\nboolean is Interrupted()//测试线程是否被终止（不改变线程的中断状态）\nstatic Thread currentThread()//获取当前执行线程的 Thread 对象\n```\n\n##### 线程的状态（5 种状态）\n\n![image](http://duqiblog.qiniudn.com/Java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)\n\n- New （新建状态） 即： Thread thread = new Thread();\n\n- Runnable （就绪状态） 其他线程调用 thread.start(); 等待 CPU 调度运行\n\n- Running （运行状态） 线程只能从就绪状态进入运行状态\n\n- Blocked （阻塞状态）放弃 CPU 运行。原因有三种  \n\n  - 等待阻塞 ：thread.wait();  \n\n  - 同步阻塞 ：synchronized 同步锁被其他线程占用  \n\n  - 其他阻塞 ：调用线程的 sleep() 或 join() 或 发出I/O请求。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 \n\n- Dead （死亡状态）执行完 或 因异常 退出 run 方法。\n\n##### 线程的属性\n\n- 优先级 ：由于在 Windows 操作系统下有 7 个优先级别，但在 Linux 操作系统，线程的优先级别被忽略，所有线程具有相同的优先级别。所以要少用优先级别来构建程序功能，避免出现因线程优先级别出现的程序烦恼。\n\n  ```java\n  void setPriority(int newPriority); //1 - 10 之间\n  static int MIN_PRIORITY //最小优先级别 1\n  static int MAX_PRIORITY //最大优先级别 10\n  static int NORM_PRIORITY //默认优先级别 5\n  static void yield();//线程让步（对相同优先级别的线程）\n  ```\n\n- 守护线程 ：没啥用，就为其他线程提供服务。\n\n- 未捕获异常处理器 setUncaughtExceptionHandler 方法为线程安装一个处理器。 setDefaultUncaughtExceptionHandler 为线程安装默认处理器。默认的处理器为空，替换处理器可以使用日志 API 来发送捕获异常的报告到日志文件中。  \n\n##### 线程同步\n\n为什么需要线程同步？  \n答：由于 2 个或多个线程共享同一数据，导致数据错乱。（也称竞争条件）  \n\n实现代码同步的方法：\n\n- 锁对象 （ReentrantLock 保护代码块）\n\n  ```java\n  myLock.lock(); //一个 ReentrantLock 对象\n  try {\n      //被锁的代码块\n  }finally {\n      myLock.Unlock(); //一定要解锁，否则其他线程永远阻塞\n  }\n  ```\n\n- 使用 synchronized 关键字（建议使用）\n\n  ```java\n  public sychronized void method (){\n      //同步代码块（同步方法）\n  }\n  \n          //等价于\n  \n  public void method(){\n      this,intrinsicLock.lock();\n      try {\n          //同步代码\n      } finally {\n              this,intrinsicLock.unlock();\n      }\n  }\n  ```\n\n##### 带返回值的线程（Callable 和 FutureTask）以及 线程池\n\n```java\nclass MyCallable implements Callable{ \n        private String oid; \n\n        MyCallable(String oid) { \n                this.oid = oid; \n        } \n\n        @Override \n        public Object call() throws Exception { \n                return oid+\"任务返回的内容\"; \n        } \n}\n\n//创建一个线程池 \nExecutorService pool = Executors.newFixedThreadPool(2); \n//创建两个有返回值的任务 \nCallable c1 = new MyCallable(\"A\"); \nCallable c2 = new MyCallable(\"B\"); \n//执行任务并获取Future对象 \nFuture f1 = pool.submit(c1); \nFuture f2 = pool.submit(c2); \n//从Future对象上获取任务的返回值，并输出到控制台 \nSystem.out.println(\">>>\"+f1.get().toString()); \nSystem.out.println(\">>>\"+f2.get().toString()); \n//关闭线程池 \npool.shutdown();\n```\n","slug":"Java Thread","published":1,"updated":"2018-11-27T11:41:17.262Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzcs000as8o5d6ewj0fw","content":"<h5 id=\"简单介绍一下线程\"><a href=\"#简单介绍一下线程\" class=\"headerlink\" title=\"简单介绍一下线程\"></a>简单介绍一下线程</h5><ul>\n<li>线程是一个程序的多个执行路径，执行调度的单位，依托于进程存在。 线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。</li>\n</ul>\n<a id=\"more\"></a>\n<h5 id=\"如何开启线程（三种方法）\"><a href=\"#如何开启线程（三种方法）\" class=\"headerlink\" title=\"如何开启线程（三种方法）\"></a>如何开启线程（三种方法）</h5><p>禁止直接调用 run 方法，否则不是另开线程，还是在原来的线程工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"title\">extend</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> run &#123;</span><br><span class=\"line\">        <span class=\"comment\">//继承线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyThread myThread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">myThread.start();<span class=\"comment\">//开启线程</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"title\">implement</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> run &#123;</span><br><span class=\"line\">        <span class=\"comment\">//实现 Runnable 接口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyThread myThread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">Thread t = <span class=\"keyword\">new</span> Thread(myThread);</span><br><span class=\"line\">t.start();<span class=\"comment\">//开启线程</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//匿名内部类实现线程开启</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<h5 id=\"线程中断的原因\"><a href=\"#线程中断的原因\" class=\"headerlink\" title=\"线程中断的原因\"></a>线程中断的原因</h5><ol>\n<li>线程的 run 方法执行完最后一句语句后</li>\n<li>线程在 run 方法中出现没有捕获的异常</li>\n<li>可以通过 interrupt 方法来请求终止线程</li>\n<li>被中断的线程可以决定如何相应中断（中断线程只不过是引起线程的注意）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span><span class=\"comment\">//发送中断请求，线程中断状态设置为 true ，若线程被 sleep 阻塞，抛出 InterruptedException 异常。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interrupted</span><span class=\"params\">()</span><span class=\"comment\">//测试线程是否被中断（无论如何，中断状态重置为 false）</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> is <span class=\"title\">Interrupted</span><span class=\"params\">()</span><span class=\"comment\">//测试线程是否被终止（不改变线程的中断状态）</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Thread <span class=\"title\">currentThread</span><span class=\"params\">()</span><span class=\"comment\">//获取当前执行线程的 Thread 对象</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"线程的状态（5-种状态）\"><a href=\"#线程的状态（5-种状态）\" class=\"headerlink\" title=\"线程的状态（5 种状态）\"></a>线程的状态（5 种状态）</h5><p><img src=\"http://duqiblog.qiniudn.com/Java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"image\"></p>\n<ul>\n<li><p>New （新建状态） 即： Thread thread = new Thread();</p>\n</li>\n<li><p>Runnable （就绪状态） 其他线程调用 thread.start(); 等待 CPU 调度运行</p>\n</li>\n<li><p>Running （运行状态） 线程只能从就绪状态进入运行状态</p>\n</li>\n<li><p>Blocked （阻塞状态）放弃 CPU 运行。原因有三种  </p>\n<ul>\n<li><p>等待阻塞 ：thread.wait();  </p>\n</li>\n<li><p>同步阻塞 ：synchronized 同步锁被其他线程占用  </p>\n</li>\n<li><p>其他阻塞 ：调用线程的 sleep() 或 join() 或 发出I/O请求。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 </p>\n</li>\n</ul>\n</li>\n<li><p>Dead （死亡状态）执行完 或 因异常 退出 run 方法。</p>\n</li>\n</ul>\n<h5 id=\"线程的属性\"><a href=\"#线程的属性\" class=\"headerlink\" title=\"线程的属性\"></a>线程的属性</h5><ul>\n<li><p>优先级 ：由于在 Windows 操作系统下有 7 个优先级别，但在 Linux 操作系统，线程的优先级别被忽略，所有线程具有相同的优先级别。所以要少用优先级别来构建程序功能，避免出现因线程优先级别出现的程序烦恼。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setPriority</span><span class=\"params\">(<span class=\"keyword\">int</span> newPriority)</span></span>; <span class=\"comment\">//1 - 10 之间</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MIN_PRIORITY <span class=\"comment\">//最小优先级别 1</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAX_PRIORITY <span class=\"comment\">//最大优先级别 10</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> NORM_PRIORITY <span class=\"comment\">//默认优先级别 5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">yield</span><span class=\"params\">()</span></span>;<span class=\"comment\">//线程让步（对相同优先级别的线程）</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>守护线程 ：没啥用，就为其他线程提供服务。</p>\n</li>\n<li><p>未捕获异常处理器 setUncaughtExceptionHandler 方法为线程安装一个处理器。 setDefaultUncaughtExceptionHandler 为线程安装默认处理器。默认的处理器为空，替换处理器可以使用日志 API 来发送捕获异常的报告到日志文件中。  </p>\n</li>\n</ul>\n<h5 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h5><p>为什么需要线程同步？<br>答：由于 2 个或多个线程共享同一数据，导致数据错乱。（也称竞争条件）  </p>\n<p>实现代码同步的方法：</p>\n<ul>\n<li><p>锁对象 （ReentrantLock 保护代码块）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myLock.lock(); <span class=\"comment\">//一个 ReentrantLock 对象</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//被锁的代码块</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    myLock.Unlock(); <span class=\"comment\">//一定要解锁，否则其他线程永远阻塞</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 synchronized 关键字（建议使用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> sychronized <span class=\"keyword\">void</span> <span class=\"title\">method</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//同步代码块（同步方法）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//等价于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>,intrinsicLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//同步代码</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>,intrinsicLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"带返回值的线程（Callable-和-FutureTask）以及-线程池\"><a href=\"#带返回值的线程（Callable-和-FutureTask）以及-线程池\" class=\"headerlink\" title=\"带返回值的线程（Callable 和 FutureTask）以及 线程池\"></a>带返回值的线程（Callable 和 FutureTask）以及 线程池</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCallable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span></span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> String oid; </span><br><span class=\"line\"></span><br><span class=\"line\">        MyCallable(String oid) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">this</span>.oid = oid; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span> oid+<span class=\"string\">\"任务返回的内容\"</span>; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个线程池 </span></span><br><span class=\"line\">ExecutorService pool = Executors.newFixedThreadPool(<span class=\"number\">2</span>); </span><br><span class=\"line\"><span class=\"comment\">//创建两个有返回值的任务 </span></span><br><span class=\"line\">Callable c1 = <span class=\"keyword\">new</span> MyCallable(<span class=\"string\">\"A\"</span>); </span><br><span class=\"line\">Callable c2 = <span class=\"keyword\">new</span> MyCallable(<span class=\"string\">\"B\"</span>); </span><br><span class=\"line\"><span class=\"comment\">//执行任务并获取Future对象 </span></span><br><span class=\"line\">Future f1 = pool.submit(c1); </span><br><span class=\"line\">Future f2 = pool.submit(c2); </span><br><span class=\"line\"><span class=\"comment\">//从Future对象上获取任务的返回值，并输出到控制台 </span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"&gt;&gt;&gt;\"</span>+f1.get().toString()); </span><br><span class=\"line\">System.out.println(<span class=\"string\">\"&gt;&gt;&gt;\"</span>+f2.get().toString()); </span><br><span class=\"line\"><span class=\"comment\">//关闭线程池 </span></span><br><span class=\"line\">pool.shutdown();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h5 id=\"简单介绍一下线程\"><a href=\"#简单介绍一下线程\" class=\"headerlink\" title=\"简单介绍一下线程\"></a>简单介绍一下线程</h5><ul>\n<li>线程是一个程序的多个执行路径，执行调度的单位，依托于进程存在。 线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。</li>\n</ul>","more":"<h5 id=\"如何开启线程（三种方法）\"><a href=\"#如何开启线程（三种方法）\" class=\"headerlink\" title=\"如何开启线程（三种方法）\"></a>如何开启线程（三种方法）</h5><p>禁止直接调用 run 方法，否则不是另开线程，还是在原来的线程工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"title\">extend</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> run &#123;</span><br><span class=\"line\">        <span class=\"comment\">//继承线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyThread myThread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">myThread.start();<span class=\"comment\">//开启线程</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"title\">implement</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> run &#123;</span><br><span class=\"line\">        <span class=\"comment\">//实现 Runnable 接口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyThread myThread = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">Thread t = <span class=\"keyword\">new</span> Thread(myThread);</span><br><span class=\"line\">t.start();<span class=\"comment\">//开启线程</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//匿名内部类实现线程开启</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<h5 id=\"线程中断的原因\"><a href=\"#线程中断的原因\" class=\"headerlink\" title=\"线程中断的原因\"></a>线程中断的原因</h5><ol>\n<li>线程的 run 方法执行完最后一句语句后</li>\n<li>线程在 run 方法中出现没有捕获的异常</li>\n<li>可以通过 interrupt 方法来请求终止线程</li>\n<li>被中断的线程可以决定如何相应中断（中断线程只不过是引起线程的注意）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span><span class=\"comment\">//发送中断请求，线程中断状态设置为 true ，若线程被 sleep 阻塞，抛出 InterruptedException 异常。</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">interrupted</span><span class=\"params\">()</span><span class=\"comment\">//测试线程是否被中断（无论如何，中断状态重置为 false）</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> is <span class=\"title\">Interrupted</span><span class=\"params\">()</span><span class=\"comment\">//测试线程是否被终止（不改变线程的中断状态）</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> Thread <span class=\"title\">currentThread</span><span class=\"params\">()</span><span class=\"comment\">//获取当前执行线程的 Thread 对象</span></span></span><br></pre></td></tr></table></figure>\n<h5 id=\"线程的状态（5-种状态）\"><a href=\"#线程的状态（5-种状态）\" class=\"headerlink\" title=\"线程的状态（5 种状态）\"></a>线程的状态（5 种状态）</h5><p><img src=\"http://duqiblog.qiniudn.com/Java%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"image\"></p>\n<ul>\n<li><p>New （新建状态） 即： Thread thread = new Thread();</p>\n</li>\n<li><p>Runnable （就绪状态） 其他线程调用 thread.start(); 等待 CPU 调度运行</p>\n</li>\n<li><p>Running （运行状态） 线程只能从就绪状态进入运行状态</p>\n</li>\n<li><p>Blocked （阻塞状态）放弃 CPU 运行。原因有三种  </p>\n<ul>\n<li><p>等待阻塞 ：thread.wait();  </p>\n</li>\n<li><p>同步阻塞 ：synchronized 同步锁被其他线程占用  </p>\n</li>\n<li><p>其他阻塞 ：调用线程的 sleep() 或 join() 或 发出I/O请求。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 </p>\n</li>\n</ul>\n</li>\n<li><p>Dead （死亡状态）执行完 或 因异常 退出 run 方法。</p>\n</li>\n</ul>\n<h5 id=\"线程的属性\"><a href=\"#线程的属性\" class=\"headerlink\" title=\"线程的属性\"></a>线程的属性</h5><ul>\n<li><p>优先级 ：由于在 Windows 操作系统下有 7 个优先级别，但在 Linux 操作系统，线程的优先级别被忽略，所有线程具有相同的优先级别。所以要少用优先级别来构建程序功能，避免出现因线程优先级别出现的程序烦恼。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setPriority</span><span class=\"params\">(<span class=\"keyword\">int</span> newPriority)</span></span>; <span class=\"comment\">//1 - 10 之间</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MIN_PRIORITY <span class=\"comment\">//最小优先级别 1</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> MAX_PRIORITY <span class=\"comment\">//最大优先级别 10</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> NORM_PRIORITY <span class=\"comment\">//默认优先级别 5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">yield</span><span class=\"params\">()</span></span>;<span class=\"comment\">//线程让步（对相同优先级别的线程）</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>守护线程 ：没啥用，就为其他线程提供服务。</p>\n</li>\n<li><p>未捕获异常处理器 setUncaughtExceptionHandler 方法为线程安装一个处理器。 setDefaultUncaughtExceptionHandler 为线程安装默认处理器。默认的处理器为空，替换处理器可以使用日志 API 来发送捕获异常的报告到日志文件中。  </p>\n</li>\n</ul>\n<h5 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h5><p>为什么需要线程同步？<br>答：由于 2 个或多个线程共享同一数据，导致数据错乱。（也称竞争条件）  </p>\n<p>实现代码同步的方法：</p>\n<ul>\n<li><p>锁对象 （ReentrantLock 保护代码块）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myLock.lock(); <span class=\"comment\">//一个 ReentrantLock 对象</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//被锁的代码块</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    myLock.Unlock(); <span class=\"comment\">//一定要解锁，否则其他线程永远阻塞</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用 synchronized 关键字（建议使用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> sychronized <span class=\"keyword\">void</span> <span class=\"title\">method</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//同步代码块（同步方法）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//等价于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>,intrinsicLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//同步代码</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>,intrinsicLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"带返回值的线程（Callable-和-FutureTask）以及-线程池\"><a href=\"#带返回值的线程（Callable-和-FutureTask）以及-线程池\" class=\"headerlink\" title=\"带返回值的线程（Callable 和 FutureTask）以及 线程池\"></a>带返回值的线程（Callable 和 FutureTask）以及 线程池</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCallable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span></span>&#123; </span><br><span class=\"line\">        <span class=\"keyword\">private</span> String oid; </span><br><span class=\"line\"></span><br><span class=\"line\">        MyCallable(String oid) &#123; </span><br><span class=\"line\">                <span class=\"keyword\">this</span>.oid = oid; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span> </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123; </span><br><span class=\"line\">                <span class=\"keyword\">return</span> oid+<span class=\"string\">\"任务返回的内容\"</span>; </span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建一个线程池 </span></span><br><span class=\"line\">ExecutorService pool = Executors.newFixedThreadPool(<span class=\"number\">2</span>); </span><br><span class=\"line\"><span class=\"comment\">//创建两个有返回值的任务 </span></span><br><span class=\"line\">Callable c1 = <span class=\"keyword\">new</span> MyCallable(<span class=\"string\">\"A\"</span>); </span><br><span class=\"line\">Callable c2 = <span class=\"keyword\">new</span> MyCallable(<span class=\"string\">\"B\"</span>); </span><br><span class=\"line\"><span class=\"comment\">//执行任务并获取Future对象 </span></span><br><span class=\"line\">Future f1 = pool.submit(c1); </span><br><span class=\"line\">Future f2 = pool.submit(c2); </span><br><span class=\"line\"><span class=\"comment\">//从Future对象上获取任务的返回值，并输出到控制台 </span></span><br><span class=\"line\">System.out.println(<span class=\"string\">\"&gt;&gt;&gt;\"</span>+f1.get().toString()); </span><br><span class=\"line\">System.out.println(<span class=\"string\">\"&gt;&gt;&gt;\"</span>+f2.get().toString()); </span><br><span class=\"line\"><span class=\"comment\">//关闭线程池 </span></span><br><span class=\"line\">pool.shutdown();</span><br></pre></td></tr></table></figure>"},{"title":"计算机网络","date":"2018-11-27T06:53:40.240Z","_content":"","source":"_posts/计算机网络.md","raw":"title: 计算机网络\ndate: 2018-11-30 14.00\ntags:\n\n---\n","slug":"计算机网络","published":1,"updated":"2018-12-03T10:58:34.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzcu000bs8o504e8lpjd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"设计模式","date":"2018-11-27T06:54:28.580Z","_content":"","source":"_posts/设计模式.md","raw":"title: 设计模式\ndate: 2018-11-30 14.00\ntags:\n\n---\n","slug":"设计模式","published":1,"updated":"2018-12-03T10:58:38.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzcu000cs8o5cgfyuzmg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"数据结构和算法","date":"2018-11-27T06:54:54.448Z","_content":"### [红黑树](https://blog.csdn.net/v_july_v/article/details/6105630)\n- 红黑树的基本介绍\n  是一种二叉查找树，满足二叉查找树的一般性质，并且每个节点上都存储一个表示颜色的字段（Red 或 Black），通过颜色限制确保没有一条路径比其他路径长 2 倍，相对平衡的一种树状结构。\n  **保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)**\n- 红黑树的性质\n 1. 根结点是黑色。\n 2. 树尾端的 Null 指针或 Null 结点是黑色的。\n 3. 红色节点的子树都是黑色的。\n 4. 对于任意结点，它到最底叶子结点的每条路径都包含相同数目的黑结点。\n- 红黑树的插入操作\n  先进行二叉查找树的插入，然后把插入结点置为红色，最后进行对红黑树的颜色修复。\n  红黑树插入操作的颜色修复 5 个步骤：当前结点现在指向插入结点。\n  1. 当前结点的 **父结点是黑色** ：并不会违反红黑树的性质（可以终止算法）。\n  2. 当前的是 **根结点** ：说明只违反根结点是黑色的性质，只需把插入结点置为黑色即可（可以终止算法）。\n  3. 当前结点的 **父节点是红色** 分 3 种情况讨论，这个是一个递归的操作，直到当前结点指向 Null：\n    3.1. 当前结点的 **父结点是红色** 且 **父结点的兄弟结点是红色** ：当前结点的父节点和父节点的兄弟结点置黑，当前结点的祖父结点置红， **当前结点指向祖父结点** 。（继续第三步判断）。\n    3.2. 当前结点的 **父结点是红色** 且 **父结点的兄弟结点是黑色** ，插入结点是右结点 ：将当前结点指向父节点，在当前结点进行 **平衡二叉树的左旋操作** 。（继续第三步判断）\n    3.3 当前结点是 **父结是红色** 且 **父结点的兄弟结点是黑色** ，插入结点是左结点 ：当前结点的父节点置黑，祖父结点置红，然后当前结点指向祝福结点， 在当前结点进行 **平衡二叉树的右旋操作** 。（继续第三步判断）\n  4. 最后把根节点涂为黑色，即可恢复红黑树的平衡。\n- 红黑树的删除操作\n  先进行对二叉查找树的删除操作，然后进行对红黑树的颜色修复。\n  红黑树删除操作的颜色修复 个步骤：当前结点现在指向删除结点的位置。\n  1. **当前结点是红色** ：则红黑树的性质依旧保持。（可以终止算法）\n  2. **当前结点是黑色**\n    2.1 当前结点是 **黑 + 黑** 且 **兄弟结点是红色** （即：父节点和兄弟节点的子结点全为黑）：把当前结点的父结点置红和兄弟结点置黑。（继续第二步的判断）\n    2.2  当前结点是 **黑 + 黑** 且 **兄弟结点是黑色** 且 **兄弟结点的子结点全为黑** ：把当前结点和兄弟结点中抽取一重黑色追加到父结点上，把父结点当成新的当前结点。（继续第二步的判断）\n    2.3 当前结点是 **黑 + 黑** 且 **兄弟结点是黑色** 且 **兄弟结点左子树是红色，右子树是黑色** ：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋。（继续第二步的判断）\n    2.4 当前结点是 **黑 + 黑** 且 **兄弟结点是黑色** 且 **兄弟结点右子树是红色，左子树随意** ：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋。（此时算法结束，已经修复红黑树颜色平衡）\n  **注明：“黑 + 黑” 表示格式是 “自身颜色 + 继承父结点的颜色”**\n","source":"_posts/数据结构和算法.md","raw":"title: 数据结构和算法\ndate: 2018-11-30 14.00\ntags:\n\n----\n### [红黑树](https://blog.csdn.net/v_july_v/article/details/6105630)\n- 红黑树的基本介绍\n  是一种二叉查找树，满足二叉查找树的一般性质，并且每个节点上都存储一个表示颜色的字段（Red 或 Black），通过颜色限制确保没有一条路径比其他路径长 2 倍，相对平衡的一种树状结构。\n  **保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)**\n- 红黑树的性质\n 1. 根结点是黑色。\n 2. 树尾端的 Null 指针或 Null 结点是黑色的。\n 3. 红色节点的子树都是黑色的。\n 4. 对于任意结点，它到最底叶子结点的每条路径都包含相同数目的黑结点。\n- 红黑树的插入操作\n  先进行二叉查找树的插入，然后把插入结点置为红色，最后进行对红黑树的颜色修复。\n  红黑树插入操作的颜色修复 5 个步骤：当前结点现在指向插入结点。\n  1. 当前结点的 **父结点是黑色** ：并不会违反红黑树的性质（可以终止算法）。\n  2. 当前的是 **根结点** ：说明只违反根结点是黑色的性质，只需把插入结点置为黑色即可（可以终止算法）。\n  3. 当前结点的 **父节点是红色** 分 3 种情况讨论，这个是一个递归的操作，直到当前结点指向 Null：\n    3.1. 当前结点的 **父结点是红色** 且 **父结点的兄弟结点是红色** ：当前结点的父节点和父节点的兄弟结点置黑，当前结点的祖父结点置红， **当前结点指向祖父结点** 。（继续第三步判断）。\n    3.2. 当前结点的 **父结点是红色** 且 **父结点的兄弟结点是黑色** ，插入结点是右结点 ：将当前结点指向父节点，在当前结点进行 **平衡二叉树的左旋操作** 。（继续第三步判断）\n    3.3 当前结点是 **父结是红色** 且 **父结点的兄弟结点是黑色** ，插入结点是左结点 ：当前结点的父节点置黑，祖父结点置红，然后当前结点指向祝福结点， 在当前结点进行 **平衡二叉树的右旋操作** 。（继续第三步判断）\n  4. 最后把根节点涂为黑色，即可恢复红黑树的平衡。\n- 红黑树的删除操作\n  先进行对二叉查找树的删除操作，然后进行对红黑树的颜色修复。\n  红黑树删除操作的颜色修复 个步骤：当前结点现在指向删除结点的位置。\n  1. **当前结点是红色** ：则红黑树的性质依旧保持。（可以终止算法）\n  2. **当前结点是黑色**\n    2.1 当前结点是 **黑 + 黑** 且 **兄弟结点是红色** （即：父节点和兄弟节点的子结点全为黑）：把当前结点的父结点置红和兄弟结点置黑。（继续第二步的判断）\n    2.2  当前结点是 **黑 + 黑** 且 **兄弟结点是黑色** 且 **兄弟结点的子结点全为黑** ：把当前结点和兄弟结点中抽取一重黑色追加到父结点上，把父结点当成新的当前结点。（继续第二步的判断）\n    2.3 当前结点是 **黑 + 黑** 且 **兄弟结点是黑色** 且 **兄弟结点左子树是红色，右子树是黑色** ：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋。（继续第二步的判断）\n    2.4 当前结点是 **黑 + 黑** 且 **兄弟结点是黑色** 且 **兄弟结点右子树是红色，左子树随意** ：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋。（此时算法结束，已经修复红黑树颜色平衡）\n  **注明：“黑 + 黑” 表示格式是 “自身颜色 + 继承父结点的颜色”**\n","slug":"数据结构和算法","published":1,"updated":"2018-12-03T11:00:52.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzd3000ds8o5iax07i4w","content":"<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a><a href=\"https://blog.csdn.net/v_july_v/article/details/6105630\" target=\"_blank\" rel=\"noopener\">红黑树</a></h3><ul>\n<li>红黑树的基本介绍<br>是一种二叉查找树，满足二叉查找树的一般性质，并且每个节点上都存储一个表示颜色的字段（Red 或 Black），通过颜色限制确保没有一条路径比其他路径长 2 倍，相对平衡的一种树状结构。<br><strong>保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</strong></li>\n<li>红黑树的性质<ol>\n<li>根结点是黑色。</li>\n<li>树尾端的 Null 指针或 Null 结点是黑色的。</li>\n<li>红色节点的子树都是黑色的。</li>\n<li>对于任意结点，它到最底叶子结点的每条路径都包含相同数目的黑结点。</li>\n</ol>\n</li>\n<li>红黑树的插入操作<br>先进行二叉查找树的插入，然后把插入结点置为红色，最后进行对红黑树的颜色修复。<br>红黑树插入操作的颜色修复 5 个步骤：当前结点现在指向插入结点。<ol>\n<li>当前结点的 <strong>父结点是黑色</strong> ：并不会违反红黑树的性质（可以终止算法）。</li>\n<li>当前的是 <strong>根结点</strong> ：说明只违反根结点是黑色的性质，只需把插入结点置为黑色即可（可以终止算法）。</li>\n<li>当前结点的 <strong>父节点是红色</strong> 分 3 种情况讨论，这个是一个递归的操作，直到当前结点指向 Null：<br>3.1. 当前结点的 <strong>父结点是红色</strong> 且 <strong>父结点的兄弟结点是红色</strong> ：当前结点的父节点和父节点的兄弟结点置黑，当前结点的祖父结点置红， <strong>当前结点指向祖父结点</strong> 。（继续第三步判断）。<br>3.2. 当前结点的 <strong>父结点是红色</strong> 且 <strong>父结点的兄弟结点是黑色</strong> ，插入结点是右结点 ：将当前结点指向父节点，在当前结点进行 <strong>平衡二叉树的左旋操作</strong> 。（继续第三步判断）<br>3.3 当前结点是 <strong>父结是红色</strong> 且 <strong>父结点的兄弟结点是黑色</strong> ，插入结点是左结点 ：当前结点的父节点置黑，祖父结点置红，然后当前结点指向祝福结点， 在当前结点进行 <strong>平衡二叉树的右旋操作</strong> 。（继续第三步判断）</li>\n<li>最后把根节点涂为黑色，即可恢复红黑树的平衡。</li>\n</ol>\n</li>\n<li>红黑树的删除操作<br>先进行对二叉查找树的删除操作，然后进行对红黑树的颜色修复。<br>红黑树删除操作的颜色修复 个步骤：当前结点现在指向删除结点的位置。<ol>\n<li><strong>当前结点是红色</strong> ：则红黑树的性质依旧保持。（可以终止算法）</li>\n<li><strong>当前结点是黑色</strong><br>2.1 当前结点是 <strong>黑 + 黑</strong> 且 <strong>兄弟结点是红色</strong> （即：父节点和兄弟节点的子结点全为黑）：把当前结点的父结点置红和兄弟结点置黑。（继续第二步的判断）<br>2.2  当前结点是 <strong>黑 + 黑</strong> 且 <strong>兄弟结点是黑色</strong> 且 <strong>兄弟结点的子结点全为黑</strong> ：把当前结点和兄弟结点中抽取一重黑色追加到父结点上，把父结点当成新的当前结点。（继续第二步的判断）<br>2.3 当前结点是 <strong>黑 + 黑</strong> 且 <strong>兄弟结点是黑色</strong> 且 <strong>兄弟结点左子树是红色，右子树是黑色</strong> ：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋。（继续第二步的判断）<br>2.4 当前结点是 <strong>黑 + 黑</strong> 且 <strong>兄弟结点是黑色</strong> 且 <strong>兄弟结点右子树是红色，左子树随意</strong> ：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋。（此时算法结束，已经修复红黑树颜色平衡）<br><strong>注明：“黑 + 黑” 表示格式是 “自身颜色 + 继承父结点的颜色”</strong></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a><a href=\"https://blog.csdn.net/v_july_v/article/details/6105630\" target=\"_blank\" rel=\"noopener\">红黑树</a></h3><ul>\n<li>红黑树的基本介绍<br>是一种二叉查找树，满足二叉查找树的一般性质，并且每个节点上都存储一个表示颜色的字段（Red 或 Black），通过颜色限制确保没有一条路径比其他路径长 2 倍，相对平衡的一种树状结构。<br><strong>保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)</strong></li>\n<li>红黑树的性质<ol>\n<li>根结点是黑色。</li>\n<li>树尾端的 Null 指针或 Null 结点是黑色的。</li>\n<li>红色节点的子树都是黑色的。</li>\n<li>对于任意结点，它到最底叶子结点的每条路径都包含相同数目的黑结点。</li>\n</ol>\n</li>\n<li>红黑树的插入操作<br>先进行二叉查找树的插入，然后把插入结点置为红色，最后进行对红黑树的颜色修复。<br>红黑树插入操作的颜色修复 5 个步骤：当前结点现在指向插入结点。<ol>\n<li>当前结点的 <strong>父结点是黑色</strong> ：并不会违反红黑树的性质（可以终止算法）。</li>\n<li>当前的是 <strong>根结点</strong> ：说明只违反根结点是黑色的性质，只需把插入结点置为黑色即可（可以终止算法）。</li>\n<li>当前结点的 <strong>父节点是红色</strong> 分 3 种情况讨论，这个是一个递归的操作，直到当前结点指向 Null：<br>3.1. 当前结点的 <strong>父结点是红色</strong> 且 <strong>父结点的兄弟结点是红色</strong> ：当前结点的父节点和父节点的兄弟结点置黑，当前结点的祖父结点置红， <strong>当前结点指向祖父结点</strong> 。（继续第三步判断）。<br>3.2. 当前结点的 <strong>父结点是红色</strong> 且 <strong>父结点的兄弟结点是黑色</strong> ，插入结点是右结点 ：将当前结点指向父节点，在当前结点进行 <strong>平衡二叉树的左旋操作</strong> 。（继续第三步判断）<br>3.3 当前结点是 <strong>父结是红色</strong> 且 <strong>父结点的兄弟结点是黑色</strong> ，插入结点是左结点 ：当前结点的父节点置黑，祖父结点置红，然后当前结点指向祝福结点， 在当前结点进行 <strong>平衡二叉树的右旋操作</strong> 。（继续第三步判断）</li>\n<li>最后把根节点涂为黑色，即可恢复红黑树的平衡。</li>\n</ol>\n</li>\n<li>红黑树的删除操作<br>先进行对二叉查找树的删除操作，然后进行对红黑树的颜色修复。<br>红黑树删除操作的颜色修复 个步骤：当前结点现在指向删除结点的位置。<ol>\n<li><strong>当前结点是红色</strong> ：则红黑树的性质依旧保持。（可以终止算法）</li>\n<li><strong>当前结点是黑色</strong><br>2.1 当前结点是 <strong>黑 + 黑</strong> 且 <strong>兄弟结点是红色</strong> （即：父节点和兄弟节点的子结点全为黑）：把当前结点的父结点置红和兄弟结点置黑。（继续第二步的判断）<br>2.2  当前结点是 <strong>黑 + 黑</strong> 且 <strong>兄弟结点是黑色</strong> 且 <strong>兄弟结点的子结点全为黑</strong> ：把当前结点和兄弟结点中抽取一重黑色追加到父结点上，把父结点当成新的当前结点。（继续第二步的判断）<br>2.3 当前结点是 <strong>黑 + 黑</strong> 且 <strong>兄弟结点是黑色</strong> 且 <strong>兄弟结点左子树是红色，右子树是黑色</strong> ：把兄弟结点染红，兄弟左子节点染黑，之后再在兄弟节点为支点解右旋。（继续第二步的判断）<br>2.4 当前结点是 <strong>黑 + 黑</strong> 且 <strong>兄弟结点是黑色</strong> 且 <strong>兄弟结点右子树是红色，左子树随意</strong> ：把兄弟节点染成当前节点父节点的颜色，把当前节点父节点染成黑色，兄弟节点右子染成黑色，之后以当前节点的父节点为支点进行左旋。（此时算法结束，已经修复红黑树颜色平衡）<br><strong>注明：“黑 + 黑” 表示格式是 “自身颜色 + 继承父结点的颜色”</strong></li>\n</ol>\n</li>\n</ul>\n"},{"title":"随手记","date":"2018-11-28T14:08:30.062Z","_content":"- JAVA 是静态的强类型语言，JAVA 反射是运行时的自省能力。\n- **反射机制** 的了解和掌握程度 java.lang 或 java.lang.reflect。\n- 运行时修改成员访问限制\n- 什么是CGLIB?  CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。\n- Android 的崩溃（Crash）类型：\n  1. 未捕获的 JAVA 异常\n  2. Native 层的 Crash\n- Activity的生命周期\n- Activity的任务栈\n- Activity的启动模式\n- Fragment的生命周期\n- Fragment的通讯，Fragment之间，Fragment和Activity\n- 什么是Service，和Thread的区别\n- Broadcast的作用和注册方式\n- 什么是本地广播\n- 什么是有序广播\n- Android的异步处理方式有哪些\n- AsycnTask、HandlerThread、IntentService源码\n- Binder\n- View的绘制流程\n- 事件分发机制\n- 自定义View的几种场景和方式\n- ListView的缓存机制\n- Handler、Message、MessageQueue、Looper\n- 第三方开源框架设计和原理\n- ANR是什么，怎么避免和排查\n- OOM是什么，一般如果避免和解决\n- 内存泄露是什么，常见的内存泄露有哪些\n- 版本管理工具的使用，Git、SVN\n- 代码编译工具\n- 代码混淆\n-  Java IO\n- 多线程\n- 类加载器\n- 23种设计模式\n- HTTP、TCP、UDP协议\n- 计算机网络\n- 操作系统原理\n- 算法和数据结构：排序、二叉树遍历、动态规划\n- 常见加密方式和原理\n","source":"_posts/随手记.md","raw":"title: 随手记\ndate: 2018-11-30 14.00\ntags:\n\n-----\n- JAVA 是静态的强类型语言，JAVA 反射是运行时的自省能力。\n- **反射机制** 的了解和掌握程度 java.lang 或 java.lang.reflect。\n- 运行时修改成员访问限制\n- 什么是CGLIB?  CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。\n- Android 的崩溃（Crash）类型：\n  1. 未捕获的 JAVA 异常\n  2. Native 层的 Crash\n- Activity的生命周期\n- Activity的任务栈\n- Activity的启动模式\n- Fragment的生命周期\n- Fragment的通讯，Fragment之间，Fragment和Activity\n- 什么是Service，和Thread的区别\n- Broadcast的作用和注册方式\n- 什么是本地广播\n- 什么是有序广播\n- Android的异步处理方式有哪些\n- AsycnTask、HandlerThread、IntentService源码\n- Binder\n- View的绘制流程\n- 事件分发机制\n- 自定义View的几种场景和方式\n- ListView的缓存机制\n- Handler、Message、MessageQueue、Looper\n- 第三方开源框架设计和原理\n- ANR是什么，怎么避免和排查\n- OOM是什么，一般如果避免和解决\n- 内存泄露是什么，常见的内存泄露有哪些\n- 版本管理工具的使用，Git、SVN\n- 代码编译工具\n- 代码混淆\n-  Java IO\n- 多线程\n- 类加载器\n- 23种设计模式\n- HTTP、TCP、UDP协议\n- 计算机网络\n- 操作系统原理\n- 算法和数据结构：排序、二叉树遍历、动态规划\n- 常见加密方式和原理\n","slug":"随手记","published":1,"updated":"2018-12-01T14:05:34.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjpg9fzd3000es8o51hei2got","content":"<ul>\n<li>JAVA 是静态的强类型语言，JAVA 反射是运行时的自省能力。</li>\n<li><strong>反射机制</strong> 的了解和掌握程度 java.lang 或 java.lang.reflect。</li>\n<li>运行时修改成员访问限制</li>\n<li>什么是CGLIB?  CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。</li>\n<li>Android 的崩溃（Crash）类型：<ol>\n<li>未捕获的 JAVA 异常</li>\n<li>Native 层的 Crash</li>\n</ol>\n</li>\n<li>Activity的生命周期</li>\n<li>Activity的任务栈</li>\n<li>Activity的启动模式</li>\n<li>Fragment的生命周期</li>\n<li>Fragment的通讯，Fragment之间，Fragment和Activity</li>\n<li>什么是Service，和Thread的区别</li>\n<li>Broadcast的作用和注册方式</li>\n<li>什么是本地广播</li>\n<li>什么是有序广播</li>\n<li>Android的异步处理方式有哪些</li>\n<li>AsycnTask、HandlerThread、IntentService源码</li>\n<li>Binder</li>\n<li>View的绘制流程</li>\n<li>事件分发机制</li>\n<li>自定义View的几种场景和方式</li>\n<li>ListView的缓存机制</li>\n<li>Handler、Message、MessageQueue、Looper</li>\n<li>第三方开源框架设计和原理</li>\n<li>ANR是什么，怎么避免和排查</li>\n<li>OOM是什么，一般如果避免和解决</li>\n<li>内存泄露是什么，常见的内存泄露有哪些</li>\n<li>版本管理工具的使用，Git、SVN</li>\n<li>代码编译工具</li>\n<li>代码混淆</li>\n<li>Java IO</li>\n<li>多线程</li>\n<li>类加载器</li>\n<li>23种设计模式</li>\n<li>HTTP、TCP、UDP协议</li>\n<li>计算机网络</li>\n<li>操作系统原理</li>\n<li>算法和数据结构：排序、二叉树遍历、动态规划</li>\n<li>常见加密方式和原理</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>JAVA 是静态的强类型语言，JAVA 反射是运行时的自省能力。</li>\n<li><strong>反射机制</strong> 的了解和掌握程度 java.lang 或 java.lang.reflect。</li>\n<li>运行时修改成员访问限制</li>\n<li>什么是CGLIB?  CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。通常可以使用Java的动态代理创建代理，但当要代理的类没有实现接口或者为了更好的性能，CGLIB是一个好的选择。</li>\n<li>Android 的崩溃（Crash）类型：<ol>\n<li>未捕获的 JAVA 异常</li>\n<li>Native 层的 Crash</li>\n</ol>\n</li>\n<li>Activity的生命周期</li>\n<li>Activity的任务栈</li>\n<li>Activity的启动模式</li>\n<li>Fragment的生命周期</li>\n<li>Fragment的通讯，Fragment之间，Fragment和Activity</li>\n<li>什么是Service，和Thread的区别</li>\n<li>Broadcast的作用和注册方式</li>\n<li>什么是本地广播</li>\n<li>什么是有序广播</li>\n<li>Android的异步处理方式有哪些</li>\n<li>AsycnTask、HandlerThread、IntentService源码</li>\n<li>Binder</li>\n<li>View的绘制流程</li>\n<li>事件分发机制</li>\n<li>自定义View的几种场景和方式</li>\n<li>ListView的缓存机制</li>\n<li>Handler、Message、MessageQueue、Looper</li>\n<li>第三方开源框架设计和原理</li>\n<li>ANR是什么，怎么避免和排查</li>\n<li>OOM是什么，一般如果避免和解决</li>\n<li>内存泄露是什么，常见的内存泄露有哪些</li>\n<li>版本管理工具的使用，Git、SVN</li>\n<li>代码编译工具</li>\n<li>代码混淆</li>\n<li>Java IO</li>\n<li>多线程</li>\n<li>类加载器</li>\n<li>23种设计模式</li>\n<li>HTTP、TCP、UDP协议</li>\n<li>计算机网络</li>\n<li>操作系统原理</li>\n<li>算法和数据结构：排序、二叉树遍历、动态规划</li>\n<li>常见加密方式和原理</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}